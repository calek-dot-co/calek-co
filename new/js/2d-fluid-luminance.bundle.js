!(function (e) {
    var t = {};
    function n(i) {
        if (t[i]) return t[i].exports;
        var r = (t[i] = { i: i, l: !1, exports: {} });
        return e[i].call(r.exports, r, r.exports, n), (r.l = !0), r.exports;
    }
    (n.m = e),
        (n.c = t),
        (n.d = function (e, t, i) {
            n.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: i });
        }),
        (n.r = function (e) {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 });
        }),
        (n.t = function (e, t) {
            if ((1 & t && (e = n(e)), 8 & t)) return e;
            if (4 & t && "object" == typeof e && e && e.__esModule) return e;
            var i = Object.create(null);
            if ((n.r(i), Object.defineProperty(i, "default", { enumerable: !0, value: e }), 2 & t && "string" != typeof e))
                for (var r in e)
                    n.d(
                        i,
                        r,
                        function (t) {
                            return e[t];
                        }.bind(null, r)
                    );
            return i;
        }),
        (n.n = function (e) {
            var t =
                e && e.__esModule
                    ? function () {
                          return e.default;
                      }
                    : function () {
                          return e;
                      };
            return n.d(t, "a", t), t;
        }),
        (n.o = function (e, t) {
            return Object.prototype.hasOwnProperty.call(e, t);
        }),
        (n.p = ""),
        n((n.s = 1));
})([
    function (e, t, n) {
        "use strict";
        n.r(t),
            n.d(t, "ACESFilmicToneMapping", function () {
                return ce;
            }),
            n.d(t, "AddEquation", function () {
                return R;
            }),
            n.d(t, "AddOperation", function () {
                return ne;
            }),
            n.d(t, "AdditiveBlending", function () {
                return T;
            }),
            n.d(t, "AlphaFormat", function () {
                return Ve;
            }),
            n.d(t, "AlwaysDepth", function () {
                return X;
            }),
            n.d(t, "AlwaysStencilFunc", function () {
                return an;
            }),
            n.d(t, "AmbientLight", function () {
                return $u;
            }),
            n.d(t, "AmbientLightProbe", function () {
                return wh;
            }),
            n.d(t, "AnimationClip", function () {
                return au;
            }),
            n.d(t, "AnimationLoader", function () {
                return fu;
            }),
            n.d(t, "AnimationMixer", function () {
                return Qh;
            }),
            n.d(t, "AnimationObjectGroup", function () {
                return Zh;
            }),
            n.d(t, "AnimationUtils", function () {
                return Xl;
            }),
            n.d(t, "ArcCurve", function () {
                return wu;
            }),
            n.d(t, "ArrayCamera", function () {
                return ms;
            }),
            n.d(t, "ArrowHelper", function () {
                return Qd;
            }),
            n.d(t, "Audio", function () {
                return Oh;
            }),
            n.d(t, "AudioAnalyser", function () {
                return zh;
            }),
            n.d(t, "AudioContext", function () {
                return gh;
            }),
            n.d(t, "AudioListener", function () {
                return Ph;
            }),
            n.d(t, "AudioLoader", function () {
                return yh;
            }),
            n.d(t, "AxesHelper", function () {
                return $d;
            }),
            n.d(t, "AxisHelper", function () {
                return Ep;
            }),
            n.d(t, "BackSide", function () {
                return g;
            }),
            n.d(t, "BasicDepthPacking", function () {
                return Gt;
            }),
            n.d(t, "BasicShadowMap", function () {
                return d;
            }),
            n.d(t, "BinaryTextureLoader", function () {
                return Rp;
            }),
            n.d(t, "Bone", function () {
                return Js;
            }),
            n.d(t, "BooleanKeyframeTrack", function () {
                return $l;
            }),
            n.d(t, "BoundingBoxHelper", function () {
                return Tp;
            }),
            n.d(t, "Box2", function () {
                return sd;
            }),
            n.d(t, "Box3", function () {
                return _i;
            }),
            n.d(t, "Box3Helper", function () {
                return Xd;
            }),
            n.d(t, "BoxBufferGeometry", function () {
                return Zr;
            }),
            n.d(t, "BoxGeometry", function () {
                return Jr;
            }),
            n.d(t, "BoxHelper", function () {
                return qd;
            }),
            n.d(t, "BufferAttribute", function () {
                return rr;
            }),
            n.d(t, "BufferGeometry", function () {
                return Mr;
            }),
            n.d(t, "BufferGeometryLoader", function () {
                return oh;
            }),
            n.d(t, "ByteType", function () {
                return Pe;
            }),
            n.d(t, "Cache", function () {
                return cu;
            }),
            n.d(t, "Camera", function () {
                return io;
            }),
            n.d(t, "CameraHelper", function () {
                return kd;
            }),
            n.d(t, "CanvasRenderer", function () {
                return Op;
            }),
            n.d(t, "CanvasTexture", function () {
                return bc;
            }),
            n.d(t, "CatmullRomCurve3", function () {
                return Lu;
            }),
            n.d(t, "CineonToneMapping", function () {
                return se;
            }),
            n.d(t, "CircleBufferGeometry", function () {
                return Il;
            }),
            n.d(t, "CircleGeometry", function () {
                return Dl;
            }),
            n.d(t, "ClampToEdgeWrapping", function () {
                return ye;
            }),
            n.d(t, "Clock", function () {
                return Th;
            }),
            n.d(t, "ClosedSplineCurve3", function () {
                return wp;
            }),
            n.d(t, "Color", function () {
                return Zi;
            }),
            n.d(t, "ColorKeyframeTrack", function () {
                return eu;
            }),
            n.d(t, "CompressedTexture", function () {
                return _c;
            }),
            n.d(t, "CompressedTextureLoader", function () {
                return mu;
            }),
            n.d(t, "ConeBufferGeometry", function () {
                return Ol;
            }),
            n.d(t, "ConeGeometry", function () {
                return Pl;
            }),
            n.d(t, "CubeCamera", function () {
                return so;
            }),
            n.d(t, "CubeGeometry", function () {
                return Jr;
            }),
            n.d(t, "CubeReflectionMapping", function () {
                return ue;
            }),
            n.d(t, "CubeRefractionMapping", function () {
                return he;
            }),
            n.d(t, "CubeTexture", function () {
                return Oo;
            }),
            n.d(t, "CubeTextureLoader", function () {
                return yu;
            }),
            n.d(t, "CubeUVReflectionMapping", function () {
                return me;
            }),
            n.d(t, "CubeUVRefractionMapping", function () {
                return ve;
            }),
            n.d(t, "CubicBezierCurve", function () {
                return Ou;
            }),
            n.d(t, "CubicBezierCurve3", function () {
                return Du;
            }),
            n.d(t, "CubicInterpolant", function () {
                return Jl;
            }),
            n.d(t, "CullFaceBack", function () {
                return s;
            }),
            n.d(t, "CullFaceFront", function () {
                return c;
            }),
            n.d(t, "CullFaceFrontBack", function () {
                return l;
            }),
            n.d(t, "CullFaceNone", function () {
                return a;
            }),
            n.d(t, "Curve", function () {
                return _u;
            }),
            n.d(t, "CurvePath", function () {
                return Gu;
            }),
            n.d(t, "CustomBlending", function () {
                return C;
            }),
            n.d(t, "CylinderBufferGeometry", function () {
                return Rl;
            }),
            n.d(t, "CylinderGeometry", function () {
                return Cl;
            }),
            n.d(t, "Cylindrical", function () {
                return od;
            }),
            n.d(t, "DataTexture", function () {
                return lo;
            }),
            n.d(t, "DataTexture2DArray", function () {
                return Do;
            }),
            n.d(t, "DataTexture3D", function () {
                return Io;
            }),
            n.d(t, "DataTextureLoader", function () {
                return vu;
            }),
            n.d(t, "DecrementStencilOp", function () {
                return Yt;
            }),
            n.d(t, "DecrementWrapStencilOp", function () {
                return Zt;
            }),
            n.d(t, "DefaultLoadingManager", function () {
                return uu;
            }),
            n.d(t, "DepthFormat", function () {
                return Ye;
            }),
            n.d(t, "DepthStencilFormat", function () {
                return Je;
            }),
            n.d(t, "DepthTexture", function () {
                return wc;
            }),
            n.d(t, "DirectionalLight", function () {
                return Qu;
            }),
            n.d(t, "DirectionalLightHelper", function () {
                return Gd;
            }),
            n.d(t, "DirectionalLightShadow", function () {
                return Ku;
            }),
            n.d(t, "DiscreteInterpolant", function () {
                return Kl;
            }),
            n.d(t, "DodecahedronBufferGeometry", function () {
                return Nc;
            }),
            n.d(t, "DodecahedronGeometry", function () {
                return Ic;
            }),
            n.d(t, "DoubleSide", function () {
                return y;
            }),
            n.d(t, "DstAlphaFactor", function () {
                return H;
            }),
            n.d(t, "DstColorFactor", function () {
                return k;
            }),
            n.d(t, "DynamicBufferAttribute", function () {
                return dp;
            }),
            n.d(t, "DynamicCopyUsage", function () {
                return fn;
            }),
            n.d(t, "DynamicDrawUsage", function () {
                return cn;
            }),
            n.d(t, "DynamicReadUsage", function () {
                return hn;
            }),
            n.d(t, "EdgesGeometry", function () {
                return Ll;
            }),
            n.d(t, "EdgesHelper", function () {
                return Ap;
            }),
            n.d(t, "EllipseCurve", function () {
                return bu;
            }),
            n.d(t, "EqualDepth", function () {
                return Z;
            }),
            n.d(t, "EqualStencilFunc", function () {
                return en;
            }),
            n.d(t, "EquirectangularReflectionMapping", function () {
                return de;
            }),
            n.d(t, "EquirectangularRefractionMapping", function () {
                return pe;
            }),
            n.d(t, "Euler", function () {
                return jn;
            }),
            n.d(t, "EventDispatcher", function () {
                return vn;
            }),
            n.d(t, "ExtrudeBufferGeometry", function () {
                return fl;
            }),
            n.d(t, "ExtrudeGeometry", function () {
                return pl;
            }),
            n.d(t, "Face3", function () {
                return er;
            }),
            n.d(t, "Face4", function () {
                return ep;
            }),
            n.d(t, "FaceColors", function () {
                return w;
            }),
            n.d(t, "FaceNormalsHelper", function () {
                return Ud;
            }),
            n.d(t, "FileLoader", function () {
                return pu;
            }),
            n.d(t, "FlatShading", function () {
                return x;
            }),
            n.d(t, "Float32Attribute", function () {
                return _p;
            }),
            n.d(t, "Float32BufferAttribute", function () {
                return dr;
            }),
            n.d(t, "Float64Attribute", function () {
                return bp;
            }),
            n.d(t, "Float64BufferAttribute", function () {
                return pr;
            }),
            n.d(t, "FloatType", function () {
                return Ue;
            }),
            n.d(t, "Fog", function () {
                return Ss;
            }),
            n.d(t, "FogExp2", function () {
                return Ms;
            }),
            n.d(t, "Font", function () {
                return fh;
            }),
            n.d(t, "FontLoader", function () {
                return vh;
            }),
            n.d(t, "FrontFaceDirectionCCW", function () {
                return h;
            }),
            n.d(t, "FrontFaceDirectionCW", function () {
                return u;
            }),
            n.d(t, "FrontSide", function () {
                return v;
            }),
            n.d(t, "Frustum", function () {
                return po;
            }),
            n.d(t, "GammaEncoding", function () {
                return It;
            }),
            n.d(t, "Geometry", function () {
                return Yr;
            }),
            n.d(t, "GeometryUtils", function () {
                return Pp;
            }),
            n.d(t, "GreaterDepth", function () {
                return Q;
            }),
            n.d(t, "GreaterEqualDepth", function () {
                return K;
            }),
            n.d(t, "GreaterEqualStencilFunc", function () {
                return on;
            }),
            n.d(t, "GreaterStencilFunc", function () {
                return nn;
            }),
            n.d(t, "GridHelper", function () {
                return Rd;
            }),
            n.d(t, "Group", function () {
                return fs;
            }),
            n.d(t, "HalfFloatType", function () {
                return Be;
            }),
            n.d(t, "HemisphereLight", function () {
                return ju;
            }),
            n.d(t, "HemisphereLightHelper", function () {
                return Ld;
            }),
            n.d(t, "HemisphereLightProbe", function () {
                return bh;
            }),
            n.d(t, "IcosahedronBufferGeometry", function () {
                return Dc;
            }),
            n.d(t, "IcosahedronGeometry", function () {
                return Oc;
            }),
            n.d(t, "ImageBitmapLoader", function () {
                return dh;
            }),
            n.d(t, "ImageLoader", function () {
                return gu;
            }),
            n.d(t, "ImageUtils", function () {
                return Ln;
            }),
            n.d(t, "ImmediateRenderObject", function () {
                return hd;
            }),
            n.d(t, "IncrementStencilOp", function () {
                return Xt;
            }),
            n.d(t, "IncrementWrapStencilOp", function () {
                return Jt;
            }),
            n.d(t, "InstancedBufferAttribute", function () {
                return rh;
            }),
            n.d(t, "InstancedBufferGeometry", function () {
                return ih;
            }),
            n.d(t, "InstancedInterleavedBuffer", function () {
                return ed;
            }),
            n.d(t, "InstancedMesh", function () {
                return ec;
            }),
            n.d(t, "Int16Attribute", function () {
                return vp;
            }),
            n.d(t, "Int16BufferAttribute", function () {
                return cr;
            }),
            n.d(t, "Int32Attribute", function () {
                return yp;
            }),
            n.d(t, "Int32BufferAttribute", function () {
                return ur;
            }),
            n.d(t, "Int8Attribute", function () {
                return pp;
            }),
            n.d(t, "Int8BufferAttribute", function () {
                return or;
            }),
            n.d(t, "IntType", function () {
                return Ie;
            }),
            n.d(t, "InterleavedBuffer", function () {
                return Es;
            }),
            n.d(t, "InterleavedBufferAttribute", function () {
                return Ts;
            }),
            n.d(t, "Interpolant", function () {
                return Yl;
            }),
            n.d(t, "InterpolateDiscrete", function () {
                return Mt;
            }),
            n.d(t, "InterpolateLinear", function () {
                return St;
            }),
            n.d(t, "InterpolateSmooth", function () {
                return Et;
            }),
            n.d(t, "InvertStencilOp", function () {
                return Kt;
            }),
            n.d(t, "JSONLoader", function () {
                return Dp;
            }),
            n.d(t, "KeepStencilOp", function () {
                return Wt;
            }),
            n.d(t, "KeyframeTrack", function () {
                return Ql;
            }),
            n.d(t, "LOD", function () {
                return js;
            }),
            n.d(t, "LatheBufferGeometry", function () {
                return Sl;
            }),
            n.d(t, "LatheGeometry", function () {
                return Ml;
            }),
            n.d(t, "Layers", function () {
                return Wn;
            }),
            n.d(t, "LensFlare", function () {
                return Np;
            }),
            n.d(t, "LessDepth", function () {
                return Y;
            }),
            n.d(t, "LessEqualDepth", function () {
                return J;
            }),
            n.d(t, "LessEqualStencilFunc", function () {
                return tn;
            }),
            n.d(t, "LessStencilFunc", function () {
                return $t;
            }),
            n.d(t, "Light", function () {
                return ku;
            }),
            n.d(t, "LightProbe", function () {
                return _h;
            }),
            n.d(t, "LightProbeHelper", function () {
                return Cd;
            }),
            n.d(t, "LightShadow", function () {
                return Wu;
            }),
            n.d(t, "Line", function () {
                return sc;
            }),
            n.d(t, "Line3", function () {
                return ud;
            }),
            n.d(t, "LineBasicMaterial", function () {
                return tc;
            }),
            n.d(t, "LineCurve", function () {
                return Iu;
            }),
            n.d(t, "LineCurve3", function () {
                return Nu;
            }),
            n.d(t, "LineDashedMaterial", function () {
                return Wl;
            }),
            n.d(t, "LineLoop", function () {
                return hc;
            }),
            n.d(t, "LinePieces", function () {
                return np;
            }),
            n.d(t, "LineSegments", function () {
                return uc;
            }),
            n.d(t, "LineStrip", function () {
                return tp;
            }),
            n.d(t, "LinearEncoding", function () {
                return Ot;
            }),
            n.d(t, "LinearFilter", function () {
                return Ee;
            }),
            n.d(t, "LinearInterpolant", function () {
                return Zl;
            }),
            n.d(t, "LinearMipMapLinearFilter", function () {
                return Ce;
            }),
            n.d(t, "LinearMipMapNearestFilter", function () {
                return Ae;
            }),
            n.d(t, "LinearMipmapLinearFilter", function () {
                return Le;
            }),
            n.d(t, "LinearMipmapNearestFilter", function () {
                return Te;
            }),
            n.d(t, "LinearToneMapping", function () {
                return re;
            }),
            n.d(t, "Loader", function () {
                return hu;
            }),
            n.d(t, "LoaderUtils", function () {
                return nh;
            }),
            n.d(t, "LoadingManager", function () {
                return lu;
            }),
            n.d(t, "LogLuvEncoding", function () {
                return Ut;
            }),
            n.d(t, "LoopOnce", function () {
                return _t;
            }),
            n.d(t, "LoopPingPong", function () {
                return wt;
            }),
            n.d(t, "LoopRepeat", function () {
                return bt;
            }),
            n.d(t, "LuminanceAlphaFormat", function () {
                return qe;
            }),
            n.d(t, "LuminanceFormat", function () {
                return We;
            }),
            n.d(t, "MOUSE", function () {
                return r;
            }),
            n.d(t, "Material", function () {
                return nr;
            }),
            n.d(t, "MaterialLoader", function () {
                return th;
            }),
            n.d(t, "Math", function () {
                return xn;
            }),
            n.d(t, "Matrix3", function () {
                return An;
            }),
            n.d(t, "Matrix4", function () {
                return Hn;
            }),
            n.d(t, "MaxEquation", function () {
                return I;
            }),
            n.d(t, "Mesh", function () {
                return Hr;
            }),
            n.d(t, "MeshBasicMaterial", function () {
                return ir;
            }),
            n.d(t, "MeshDepthMaterial", function () {
                return rs;
            }),
            n.d(t, "MeshDistanceMaterial", function () {
                return os;
            }),
            n.d(t, "MeshFaceMaterial", function () {
                return ip;
            }),
            n.d(t, "MeshLambertMaterial", function () {
                return kl;
            }),
            n.d(t, "MeshMatcapMaterial", function () {
                return jl;
            }),
            n.d(t, "MeshNormalMaterial", function () {
                return Vl;
            }),
            n.d(t, "MeshPhongMaterial", function () {
                return Gl;
            }),
            n.d(t, "MeshPhysicalMaterial", function () {
                return Fl;
            }),
            n.d(t, "MeshStandardMaterial", function () {
                return zl;
            }),
            n.d(t, "MeshToonMaterial", function () {
                return Hl;
            }),
            n.d(t, "MinEquation", function () {
                return D;
            }),
            n.d(t, "MirroredRepeatWrapping", function () {
                return xe;
            }),
            n.d(t, "MixOperation", function () {
                return te;
            }),
            n.d(t, "MultiMaterial", function () {
                return rp;
            }),
            n.d(t, "MultiplyBlending", function () {
                return L;
            }),
            n.d(t, "MultiplyOperation", function () {
                return ee;
            }),
            n.d(t, "NearestFilter", function () {
                return _e;
            }),
            n.d(t, "NearestMipMapLinearFilter", function () {
                return Se;
            }),
            n.d(t, "NearestMipMapNearestFilter", function () {
                return we;
            }),
            n.d(t, "NearestMipmapLinearFilter", function () {
                return Me;
            }),
            n.d(t, "NearestMipmapNearestFilter", function () {
                return be;
            }),
            n.d(t, "NeverDepth", function () {
                return q;
            }),
            n.d(t, "NeverStencilFunc", function () {
                return Qt;
            }),
            n.d(t, "NoBlending", function () {
                return S;
            }),
            n.d(t, "NoColors", function () {
                return b;
            }),
            n.d(t, "NoToneMapping", function () {
                return ie;
            }),
            n.d(t, "NormalBlending", function () {
                return E;
            }),
            n.d(t, "NotEqualDepth", function () {
                return $;
            }),
            n.d(t, "NotEqualStencilFunc", function () {
                return rn;
            }),
            n.d(t, "NumberKeyframeTrack", function () {
                return tu;
            }),
            n.d(t, "Object3D", function () {
                return oi;
            }),
            n.d(t, "ObjectLoader", function () {
                return sh;
            }),
            n.d(t, "ObjectSpaceNormalMap", function () {
                return kt;
            }),
            n.d(t, "OctahedronBufferGeometry", function () {
                return Pc;
            }),
            n.d(t, "OctahedronGeometry", function () {
                return Rc;
            }),
            n.d(t, "OneFactor", function () {
                return U;
            }),
            n.d(t, "OneMinusDstAlphaFactor", function () {
                return V;
            }),
            n.d(t, "OneMinusDstColorFactor", function () {
                return j;
            }),
            n.d(t, "OneMinusSrcAlphaFactor", function () {
                return G;
            }),
            n.d(t, "OneMinusSrcColorFactor", function () {
                return z;
            }),
            n.d(t, "OrthographicCamera", function () {
                return Zu;
            }),
            n.d(t, "PCFShadowMap", function () {
                return p;
            }),
            n.d(t, "PCFSoftShadowMap", function () {
                return f;
            }),
            n.d(t, "ParametricBufferGeometry", function () {
                return Ec;
            }),
            n.d(t, "ParametricGeometry", function () {
                return Sc;
            }),
            n.d(t, "Particle", function () {
                return ap;
            }),
            n.d(t, "ParticleBasicMaterial", function () {
                return lp;
            }),
            n.d(t, "ParticleSystem", function () {
                return sp;
            }),
            n.d(t, "ParticleSystemMaterial", function () {
                return up;
            }),
            n.d(t, "Path", function () {
                return Hu;
            }),
            n.d(t, "PerspectiveCamera", function () {
                return ro;
            }),
            n.d(t, "Plane", function () {
                return Ni;
            }),
            n.d(t, "PlaneBufferGeometry", function () {
                return _o;
            }),
            n.d(t, "PlaneGeometry", function () {
                return xo;
            }),
            n.d(t, "PlaneHelper", function () {
                return Yd;
            }),
            n.d(t, "PointCloud", function () {
                return op;
            }),
            n.d(t, "PointCloudMaterial", function () {
                return cp;
            }),
            n.d(t, "PointLight", function () {
                return Ju;
            }),
            n.d(t, "PointLightHelper", function () {
                return Md;
            }),
            n.d(t, "Points", function () {
                return gc;
            }),
            n.d(t, "PointsMaterial", function () {
                return dc;
            }),
            n.d(t, "PolarGridHelper", function () {
                return Pd;
            }),
            n.d(t, "PolyhedronBufferGeometry", function () {
                return Ac;
            }),
            n.d(t, "PolyhedronGeometry", function () {
                return Tc;
            }),
            n.d(t, "PositionalAudio", function () {
                return Bh;
            }),
            n.d(t, "PositionalAudioHelper", function () {
                return Od;
            }),
            n.d(t, "PropertyBinding", function () {
                return Jh;
            }),
            n.d(t, "PropertyMixer", function () {
                return Fh;
            }),
            n.d(t, "QuadraticBezierCurve", function () {
                return Uu;
            }),
            n.d(t, "QuadraticBezierCurve3", function () {
                return Bu;
            }),
            n.d(t, "Quaternion", function () {
                return bn;
            }),
            n.d(t, "QuaternionKeyframeTrack", function () {
                return iu;
            }),
            n.d(t, "QuaternionLinearInterpolant", function () {
                return nu;
            }),
            n.d(t, "REVISION", function () {
                return i;
            }),
            n.d(t, "RGBADepthPacking", function () {
                return Ht;
            }),
            n.d(t, "RGBAFormat", function () {
                return je;
            }),
            n.d(t, "RGBA_ASTC_10x10_Format", function () {
                return gt;
            }),
            n.d(t, "RGBA_ASTC_10x5_Format", function () {
                return ft;
            }),
            n.d(t, "RGBA_ASTC_10x6_Format", function () {
                return mt;
            }),
            n.d(t, "RGBA_ASTC_10x8_Format", function () {
                return vt;
            }),
            n.d(t, "RGBA_ASTC_12x10_Format", function () {
                return yt;
            }),
            n.d(t, "RGBA_ASTC_12x12_Format", function () {
                return xt;
            }),
            n.d(t, "RGBA_ASTC_4x4_Format", function () {
                return at;
            }),
            n.d(t, "RGBA_ASTC_5x4_Format", function () {
                return st;
            }),
            n.d(t, "RGBA_ASTC_5x5_Format", function () {
                return ct;
            }),
            n.d(t, "RGBA_ASTC_6x5_Format", function () {
                return lt;
            }),
            n.d(t, "RGBA_ASTC_6x6_Format", function () {
                return ut;
            }),
            n.d(t, "RGBA_ASTC_8x5_Format", function () {
                return ht;
            }),
            n.d(t, "RGBA_ASTC_8x6_Format", function () {
                return dt;
            }),
            n.d(t, "RGBA_ASTC_8x8_Format", function () {
                return pt;
            }),
            n.d(t, "RGBA_PVRTC_2BPPV1_Format", function () {
                return rt;
            }),
            n.d(t, "RGBA_PVRTC_4BPPV1_Format", function () {
                return it;
            }),
            n.d(t, "RGBA_S3TC_DXT1_Format", function () {
                return Qe;
            }),
            n.d(t, "RGBA_S3TC_DXT3_Format", function () {
                return $e;
            }),
            n.d(t, "RGBA_S3TC_DXT5_Format", function () {
                return et;
            }),
            n.d(t, "RGBDEncoding", function () {
                return Ft;
            }),
            n.d(t, "RGBEEncoding", function () {
                return Nt;
            }),
            n.d(t, "RGBEFormat", function () {
                return Xe;
            }),
            n.d(t, "RGBFormat", function () {
                return ke;
            }),
            n.d(t, "RGBM16Encoding", function () {
                return zt;
            }),
            n.d(t, "RGBM7Encoding", function () {
                return Bt;
            }),
            n.d(t, "RGB_ETC1_Format", function () {
                return ot;
            }),
            n.d(t, "RGB_PVRTC_2BPPV1_Format", function () {
                return nt;
            }),
            n.d(t, "RGB_PVRTC_4BPPV1_Format", function () {
                return tt;
            }),
            n.d(t, "RGB_S3TC_DXT1_Format", function () {
                return Ke;
            }),
            n.d(t, "RawShaderMaterial", function () {
                return Bl;
            }),
            n.d(t, "Ray", function () {
                return Pi;
            }),
            n.d(t, "Raycaster", function () {
                return td;
            }),
            n.d(t, "RectAreaLight", function () {
                return eh;
            }),
            n.d(t, "RectAreaLightHelper", function () {
                return Sd;
            }),
            n.d(t, "RedFormat", function () {
                return Ze;
            }),
            n.d(t, "ReinhardToneMapping", function () {
                return oe;
            }),
            n.d(t, "RepeatWrapping", function () {
                return ge;
            }),
            n.d(t, "ReplaceStencilOp", function () {
                return qt;
            }),
            n.d(t, "ReverseSubtractEquation", function () {
                return O;
            }),
            n.d(t, "RingBufferGeometry", function () {
                return wl;
            }),
            n.d(t, "RingGeometry", function () {
                return bl;
            }),
            n.d(t, "Scene", function () {
                return ai;
            }),
            n.d(t, "SceneUtils", function () {
                return Ip;
            }),
            n.d(t, "ShaderChunk", function () {
                return fo;
            }),
            n.d(t, "ShaderLib", function () {
                return vo;
            }),
            n.d(t, "ShaderMaterial", function () {
                return no;
            }),
            n.d(t, "ShadowMaterial", function () {
                return Ul;
            }),
            n.d(t, "Shape", function () {
                return Vu;
            }),
            n.d(t, "ShapeBufferGeometry", function () {
                return Tl;
            }),
            n.d(t, "ShapeGeometry", function () {
                return El;
            }),
            n.d(t, "ShapePath", function () {
                return ph;
            }),
            n.d(t, "ShapeUtils", function () {
                return ul;
            }),
            n.d(t, "ShortType", function () {
                return Oe;
            }),
            n.d(t, "Skeleton", function () {
                return Ys;
            }),
            n.d(t, "SkeletonHelper", function () {
                return wd;
            }),
            n.d(t, "SkinnedMesh", function () {
                return Ws;
            }),
            n.d(t, "SmoothShading", function () {
                return _;
            }),
            n.d(t, "Sphere", function () {
                return Mi;
            }),
            n.d(t, "SphereBufferGeometry", function () {
                return _l;
            }),
            n.d(t, "SphereGeometry", function () {
                return xl;
            }),
            n.d(t, "Spherical", function () {
                return rd;
            }),
            n.d(t, "SphericalHarmonics3", function () {
                return xh;
            }),
            n.d(t, "SphericalReflectionMapping", function () {
                return fe;
            }),
            n.d(t, "Spline", function () {
                return Sp;
            }),
            n.d(t, "SplineCurve", function () {
                return zu;
            }),
            n.d(t, "SplineCurve3", function () {
                return Mp;
            }),
            n.d(t, "SpotLight", function () {
                return Xu;
            }),
            n.d(t, "SpotLightHelper", function () {
                return yd;
            }),
            n.d(t, "SpotLightShadow", function () {
                return qu;
            }),
            n.d(t, "Sprite", function () {
                return Gs;
            }),
            n.d(t, "SpriteMaterial", function () {
                return As;
            }),
            n.d(t, "SrcAlphaFactor", function () {
                return F;
            }),
            n.d(t, "SrcAlphaSaturateFactor", function () {
                return W;
            }),
            n.d(t, "SrcColorFactor", function () {
                return B;
            }),
            n.d(t, "StaticCopyUsage", function () {
                return pn;
            }),
            n.d(t, "StaticDrawUsage", function () {
                return sn;
            }),
            n.d(t, "StaticReadUsage", function () {
                return un;
            }),
            n.d(t, "StereoCamera", function () {
                return Eh;
            }),
            n.d(t, "StreamCopyUsage", function () {
                return mn;
            }),
            n.d(t, "StreamDrawUsage", function () {
                return ln;
            }),
            n.d(t, "StreamReadUsage", function () {
                return dn;
            }),
            n.d(t, "StringKeyframeTrack", function () {
                return ru;
            }),
            n.d(t, "SubtractEquation", function () {
                return P;
            }),
            n.d(t, "SubtractiveBlending", function () {
                return A;
            }),
            n.d(t, "TOUCH", function () {
                return o;
            }),
            n.d(t, "TangentSpaceNormalMap", function () {
                return Vt;
            }),
            n.d(t, "TetrahedronBufferGeometry", function () {
                return Cc;
            }),
            n.d(t, "TetrahedronGeometry", function () {
                return Lc;
            }),
            n.d(t, "TextBufferGeometry", function () {
                return yl;
            }),
            n.d(t, "TextGeometry", function () {
                return gl;
            }),
            n.d(t, "Texture", function () {
                return Rn;
            }),
            n.d(t, "TextureLoader", function () {
                return xu;
            }),
            n.d(t, "TorusBufferGeometry", function () {
                return Hc;
            }),
            n.d(t, "TorusGeometry", function () {
                return Gc;
            }),
            n.d(t, "TorusKnotBufferGeometry", function () {
                return Fc;
            }),
            n.d(t, "TorusKnotGeometry", function () {
                return zc;
            }),
            n.d(t, "Triangle", function () {
                return qi;
            }),
            n.d(t, "TriangleFanDrawMode", function () {
                return Pt;
            }),
            n.d(t, "TriangleStripDrawMode", function () {
                return Rt;
            }),
            n.d(t, "TrianglesDrawMode", function () {
                return Ct;
            }),
            n.d(t, "TubeBufferGeometry", function () {
                return Bc;
            }),
            n.d(t, "TubeGeometry", function () {
                return Uc;
            }),
            n.d(t, "UVMapping", function () {
                return le;
            }),
            n.d(t, "Uint16Attribute", function () {
                return gp;
            }),
            n.d(t, "Uint16BufferAttribute", function () {
                return lr;
            }),
            n.d(t, "Uint32Attribute", function () {
                return xp;
            }),
            n.d(t, "Uint32BufferAttribute", function () {
                return hr;
            }),
            n.d(t, "Uint8Attribute", function () {
                return fp;
            }),
            n.d(t, "Uint8BufferAttribute", function () {
                return ar;
            }),
            n.d(t, "Uint8ClampedAttribute", function () {
                return mp;
            }),
            n.d(t, "Uint8ClampedBufferAttribute", function () {
                return sr;
            }),
            n.d(t, "Uncharted2ToneMapping", function () {
                return ae;
            }),
            n.d(t, "Uniform", function () {
                return $h;
            }),
            n.d(t, "UniformsLib", function () {
                return mo;
            }),
            n.d(t, "UniformsUtils", function () {
                return $r;
            }),
            n.d(t, "UnsignedByteType", function () {
                return Re;
            }),
            n.d(t, "UnsignedInt248Type", function () {
                return He;
            }),
            n.d(t, "UnsignedIntType", function () {
                return Ne;
            }),
            n.d(t, "UnsignedShort4444Type", function () {
                return ze;
            }),
            n.d(t, "UnsignedShort5551Type", function () {
                return Fe;
            }),
            n.d(t, "UnsignedShort565Type", function () {
                return Ge;
            }),
            n.d(t, "UnsignedShortType", function () {
                return De;
            }),
            n.d(t, "VSMShadowMap", function () {
                return m;
            }),
            n.d(t, "Vector2", function () {
                return _n;
            }),
            n.d(t, "Vector3", function () {
                return Sn;
            }),
            n.d(t, "Vector4", function () {
                return Pn;
            }),
            n.d(t, "VectorKeyframeTrack", function () {
                return ou;
            }),
            n.d(t, "Vertex", function () {
                return hp;
            }),
            n.d(t, "VertexColors", function () {
                return M;
            }),
            n.d(t, "VertexNormalsHelper", function () {
                return vd;
            }),
            n.d(t, "VideoTexture", function () {
                return xc;
            }),
            n.d(t, "WebGLMultisampleRenderTarget", function () {
                return Dn;
            }),
            n.d(t, "WebGLRenderTarget", function () {
                return On;
            }),
            n.d(t, "WebGLRenderTargetCube", function () {
                return co;
            }),
            n.d(t, "WebGLRenderer", function () {
                return ws;
            }),
            n.d(t, "WebGLUtils", function () {
                return hs;
            }),
            n.d(t, "WireframeGeometry", function () {
                return Mc;
            }),
            n.d(t, "WireframeHelper", function () {
                return Lp;
            }),
            n.d(t, "WrapAroundEnding", function () {
                return Lt;
            }),
            n.d(t, "XHRLoader", function () {
                return Cp;
            }),
            n.d(t, "ZeroCurvatureEnding", function () {
                return Tt;
            }),
            n.d(t, "ZeroFactor", function () {
                return N;
            }),
            n.d(t, "ZeroSlopeEnding", function () {
                return At;
            }),
            n.d(t, "ZeroStencilOp", function () {
                return jt;
            }),
            n.d(t, "sRGBEncoding", function () {
                return Dt;
            }),
            void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)),
            void 0 === Number.isInteger &&
                (Number.isInteger = function (e) {
                    return "number" == typeof e && isFinite(e) && Math.floor(e) === e;
                }),
            void 0 === Math.sign &&
                (Math.sign = function (e) {
                    return e < 0 ? -1 : e > 0 ? 1 : +e;
                }),
            "name" in Function.prototype == !1 &&
                Object.defineProperty(Function.prototype, "name", {
                    get: function () {
                        return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
                    },
                }),
            void 0 === Object.assign &&
                (Object.assign = function (e) {
                    if (null == e) throw new TypeError("Cannot convert undefined or null to object");
                    for (var t = Object(e), n = 1; n < arguments.length; n++) {
                        var i = arguments[n];
                        if (null != i) for (var r in i) Object.prototype.hasOwnProperty.call(i, r) && (t[r] = i[r]);
                    }
                    return t;
                });
        var i = "111",
            r = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
            o = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
            a = 0,
            s = 1,
            c = 2,
            l = 3,
            u = 0,
            h = 1,
            d = 0,
            p = 1,
            f = 2,
            m = 3,
            v = 0,
            g = 1,
            y = 2,
            x = 1,
            _ = 2,
            b = 0,
            w = 1,
            M = 2,
            S = 0,
            E = 1,
            T = 2,
            A = 3,
            L = 4,
            C = 5,
            R = 100,
            P = 101,
            O = 102,
            D = 103,
            I = 104,
            N = 200,
            U = 201,
            B = 202,
            z = 203,
            F = 204,
            G = 205,
            H = 206,
            V = 207,
            k = 208,
            j = 209,
            W = 210,
            q = 0,
            X = 1,
            Y = 2,
            J = 3,
            Z = 4,
            K = 5,
            Q = 6,
            $ = 7,
            ee = 0,
            te = 1,
            ne = 2,
            ie = 0,
            re = 1,
            oe = 2,
            ae = 3,
            se = 4,
            ce = 5,
            le = 300,
            ue = 301,
            he = 302,
            de = 303,
            pe = 304,
            fe = 305,
            me = 306,
            ve = 307,
            ge = 1e3,
            ye = 1001,
            xe = 1002,
            _e = 1003,
            be = 1004,
            we = 1004,
            Me = 1005,
            Se = 1005,
            Ee = 1006,
            Te = 1007,
            Ae = 1007,
            Le = 1008,
            Ce = 1008,
            Re = 1009,
            Pe = 1010,
            Oe = 1011,
            De = 1012,
            Ie = 1013,
            Ne = 1014,
            Ue = 1015,
            Be = 1016,
            ze = 1017,
            Fe = 1018,
            Ge = 1019,
            He = 1020,
            Ve = 1021,
            ke = 1022,
            je = 1023,
            We = 1024,
            qe = 1025,
            Xe = je,
            Ye = 1026,
            Je = 1027,
            Ze = 1028,
            Ke = 33776,
            Qe = 33777,
            $e = 33778,
            et = 33779,
            tt = 35840,
            nt = 35841,
            it = 35842,
            rt = 35843,
            ot = 36196,
            at = 37808,
            st = 37809,
            ct = 37810,
            lt = 37811,
            ut = 37812,
            ht = 37813,
            dt = 37814,
            pt = 37815,
            ft = 37816,
            mt = 37817,
            vt = 37818,
            gt = 37819,
            yt = 37820,
            xt = 37821,
            _t = 2200,
            bt = 2201,
            wt = 2202,
            Mt = 2300,
            St = 2301,
            Et = 2302,
            Tt = 2400,
            At = 2401,
            Lt = 2402,
            Ct = 0,
            Rt = 1,
            Pt = 2,
            Ot = 3e3,
            Dt = 3001,
            It = 3007,
            Nt = 3002,
            Ut = 3003,
            Bt = 3004,
            zt = 3005,
            Ft = 3006,
            Gt = 3200,
            Ht = 3201,
            Vt = 0,
            kt = 1,
            jt = 0,
            Wt = 7680,
            qt = 7681,
            Xt = 7682,
            Yt = 7683,
            Jt = 34055,
            Zt = 34056,
            Kt = 5386,
            Qt = 512,
            $t = 513,
            en = 514,
            tn = 515,
            nn = 516,
            rn = 517,
            on = 518,
            an = 519,
            sn = 35044,
            cn = 35048,
            ln = 35040,
            un = 35045,
            hn = 35049,
            dn = 35041,
            pn = 35046,
            fn = 35050,
            mn = 35042;
        function vn() {}
        Object.assign(vn.prototype, {
            addEventListener: function (e, t) {
                void 0 === this._listeners && (this._listeners = {});
                var n = this._listeners;
                void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t);
            },
            hasEventListener: function (e, t) {
                if (void 0 === this._listeners) return !1;
                var n = this._listeners;
                return void 0 !== n[e] && -1 !== n[e].indexOf(t);
            },
            removeEventListener: function (e, t) {
                if (void 0 !== this._listeners) {
                    var n = this._listeners[e];
                    if (void 0 !== n) {
                        var i = n.indexOf(t);
                        -1 !== i && n.splice(i, 1);
                    }
                }
            },
            dispatchEvent: function (e) {
                if (void 0 !== this._listeners) {
                    var t = this._listeners[e.type];
                    if (void 0 !== t) {
                        e.target = this;
                        for (var n = t.slice(0), i = 0, r = n.length; i < r; i++) n[i].call(this, e);
                    }
                }
            },
        });
        for (var gn = [], yn = 0; yn < 256; yn++) gn[yn] = (yn < 16 ? "0" : "") + yn.toString(16);
        var xn = {
            DEG2RAD: Math.PI / 180,
            RAD2DEG: 180 / Math.PI,
            generateUUID: function () {
                var e = (4294967295 * Math.random()) | 0,
                    t = (4294967295 * Math.random()) | 0,
                    n = (4294967295 * Math.random()) | 0,
                    i = (4294967295 * Math.random()) | 0;
                return (
                    gn[255 & e] +
                    gn[(e >> 8) & 255] +
                    gn[(e >> 16) & 255] +
                    gn[(e >> 24) & 255] +
                    "-" +
                    gn[255 & t] +
                    gn[(t >> 8) & 255] +
                    "-" +
                    gn[((t >> 16) & 15) | 64] +
                    gn[(t >> 24) & 255] +
                    "-" +
                    gn[(63 & n) | 128] +
                    gn[(n >> 8) & 255] +
                    "-" +
                    gn[(n >> 16) & 255] +
                    gn[(n >> 24) & 255] +
                    gn[255 & i] +
                    gn[(i >> 8) & 255] +
                    gn[(i >> 16) & 255] +
                    gn[(i >> 24) & 255]
                ).toUpperCase();
            },
            clamp: function (e, t, n) {
                return Math.max(t, Math.min(n, e));
            },
            euclideanModulo: function (e, t) {
                return ((e % t) + t) % t;
            },
            mapLinear: function (e, t, n, i, r) {
                return i + ((e - t) * (r - i)) / (n - t);
            },
            lerp: function (e, t, n) {
                return (1 - n) * e + n * t;
            },
            smoothstep: function (e, t, n) {
                return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e);
            },
            smootherstep: function (e, t, n) {
                return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10);
            },
            randInt: function (e, t) {
                return e + Math.floor(Math.random() * (t - e + 1));
            },
            randFloat: function (e, t) {
                return e + Math.random() * (t - e);
            },
            randFloatSpread: function (e) {
                return e * (0.5 - Math.random());
            },
            degToRad: function (e) {
                return e * xn.DEG2RAD;
            },
            radToDeg: function (e) {
                return e * xn.RAD2DEG;
            },
            isPowerOfTwo: function (e) {
                return 0 == (e & (e - 1)) && 0 !== e;
            },
            ceilPowerOfTwo: function (e) {
                return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2));
            },
            floorPowerOfTwo: function (e) {
                return Math.pow(2, Math.floor(Math.log(e) / Math.LN2));
            },
        };
        function _n(e, t) {
            (this.x = e || 0), (this.y = t || 0);
        }
        function bn(e, t, n, i) {
            (this._x = e || 0), (this._y = t || 0), (this._z = n || 0), (this._w = void 0 !== i ? i : 1);
        }
        Object.defineProperties(_n.prototype, {
            width: {
                get: function () {
                    return this.x;
                },
                set: function (e) {
                    this.x = e;
                },
            },
            height: {
                get: function () {
                    return this.y;
                },
                set: function (e) {
                    this.y = e;
                },
            },
        }),
            Object.assign(_n.prototype, {
                isVector2: !0,
                set: function (e, t) {
                    return (this.x = e), (this.y = t), this;
                },
                setScalar: function (e) {
                    return (this.x = e), (this.y = e), this;
                },
                setX: function (e) {
                    return (this.x = e), this;
                },
                setY: function (e) {
                    return (this.y = e), this;
                },
                setComponent: function (e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        default:
                            throw new Error("index is out of range: " + e);
                    }
                    return this;
                },
                getComponent: function (e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw new Error("index is out of range: " + e);
                    }
                },
                clone: function () {
                    return new this.constructor(this.x, this.y);
                },
                copy: function (e) {
                    return (this.x = e.x), (this.y = e.y), this;
                },
                add: function (e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : ((this.x += e.x), (this.y += e.y), this);
                },
                addScalar: function (e) {
                    return (this.x += e), (this.y += e), this;
                },
                addVectors: function (e, t) {
                    return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
                },
                addScaledVector: function (e, t) {
                    return (this.x += e.x * t), (this.y += e.y * t), this;
                },
                sub: function (e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : ((this.x -= e.x), (this.y -= e.y), this);
                },
                subScalar: function (e) {
                    return (this.x -= e), (this.y -= e), this;
                },
                subVectors: function (e, t) {
                    return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
                },
                multiply: function (e) {
                    return (this.x *= e.x), (this.y *= e.y), this;
                },
                multiplyScalar: function (e) {
                    return (this.x *= e), (this.y *= e), this;
                },
                divide: function (e) {
                    return (this.x /= e.x), (this.y /= e.y), this;
                },
                divideScalar: function (e) {
                    return this.multiplyScalar(1 / e);
                },
                applyMatrix3: function (e) {
                    var t = this.x,
                        n = this.y,
                        i = e.elements;
                    return (this.x = i[0] * t + i[3] * n + i[6]), (this.y = i[1] * t + i[4] * n + i[7]), this;
                },
                min: function (e) {
                    return (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this;
                },
                max: function (e) {
                    return (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this;
                },
                clamp: function (e, t) {
                    return (this.x = Math.max(e.x, Math.min(t.x, this.x))), (this.y = Math.max(e.y, Math.min(t.y, this.y))), this;
                },
                clampScalar: function (e, t) {
                    return (this.x = Math.max(e, Math.min(t, this.x))), (this.y = Math.max(e, Math.min(t, this.y))), this;
                },
                clampLength: function (e, t) {
                    var n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
                },
                floor: function () {
                    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
                },
                ceil: function () {
                    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
                },
                round: function () {
                    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
                },
                roundToZero: function () {
                    return (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)), (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)), this;
                },
                negate: function () {
                    return (this.x = -this.x), (this.y = -this.y), this;
                },
                dot: function (e) {
                    return this.x * e.x + this.y * e.y;
                },
                cross: function (e) {
                    return this.x * e.y - this.y * e.x;
                },
                lengthSq: function () {
                    return this.x * this.x + this.y * this.y;
                },
                length: function () {
                    return Math.sqrt(this.x * this.x + this.y * this.y);
                },
                manhattanLength: function () {
                    return Math.abs(this.x) + Math.abs(this.y);
                },
                normalize: function () {
                    return this.divideScalar(this.length() || 1);
                },
                angle: function () {
                    var e = Math.atan2(this.y, this.x);
                    return e < 0 && (e += 2 * Math.PI), e;
                },
                distanceTo: function (e) {
                    return Math.sqrt(this.distanceToSquared(e));
                },
                distanceToSquared: function (e) {
                    var t = this.x - e.x,
                        n = this.y - e.y;
                    return t * t + n * n;
                },
                manhattanDistanceTo: function (e) {
                    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
                },
                setLength: function (e) {
                    return this.normalize().multiplyScalar(e);
                },
                lerp: function (e, t) {
                    return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this;
                },
                lerpVectors: function (e, t, n) {
                    return this.subVectors(t, e).multiplyScalar(n).add(e);
                },
                equals: function (e) {
                    return e.x === this.x && e.y === this.y;
                },
                fromArray: function (e, t) {
                    return void 0 === t && (t = 0), (this.x = e[t]), (this.y = e[t + 1]), this;
                },
                toArray: function (e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), (e[t] = this.x), (e[t + 1] = this.y), e;
                },
                fromBufferAttribute: function (e, t, n) {
                    return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), (this.x = e.getX(t)), (this.y = e.getY(t)), this;
                },
                rotateAround: function (e, t) {
                    var n = Math.cos(t),
                        i = Math.sin(t),
                        r = this.x - e.x,
                        o = this.y - e.y;
                    return (this.x = r * n - o * i + e.x), (this.y = r * i + o * n + e.y), this;
                },
            }),
            Object.assign(bn, {
                slerp: function (e, t, n, i) {
                    return n.copy(e).slerp(t, i);
                },
                slerpFlat: function (e, t, n, i, r, o, a) {
                    var s = n[i + 0],
                        c = n[i + 1],
                        l = n[i + 2],
                        u = n[i + 3],
                        h = r[o + 0],
                        d = r[o + 1],
                        p = r[o + 2],
                        f = r[o + 3];
                    if (u !== f || s !== h || c !== d || l !== p) {
                        var m = 1 - a,
                            v = s * h + c * d + l * p + u * f,
                            g = v >= 0 ? 1 : -1,
                            y = 1 - v * v;
                        if (y > Number.EPSILON) {
                            var x = Math.sqrt(y),
                                _ = Math.atan2(x, v * g);
                            (m = Math.sin(m * _) / x), (a = Math.sin(a * _) / x);
                        }
                        var b = a * g;
                        if (((s = s * m + h * b), (c = c * m + d * b), (l = l * m + p * b), (u = u * m + f * b), m === 1 - a)) {
                            var w = 1 / Math.sqrt(s * s + c * c + l * l + u * u);
                            (s *= w), (c *= w), (l *= w), (u *= w);
                        }
                    }
                    (e[t] = s), (e[t + 1] = c), (e[t + 2] = l), (e[t + 3] = u);
                },
            }),
            Object.defineProperties(bn.prototype, {
                x: {
                    get: function () {
                        return this._x;
                    },
                    set: function (e) {
                        (this._x = e), this._onChangeCallback();
                    },
                },
                y: {
                    get: function () {
                        return this._y;
                    },
                    set: function (e) {
                        (this._y = e), this._onChangeCallback();
                    },
                },
                z: {
                    get: function () {
                        return this._z;
                    },
                    set: function (e) {
                        (this._z = e), this._onChangeCallback();
                    },
                },
                w: {
                    get: function () {
                        return this._w;
                    },
                    set: function (e) {
                        (this._w = e), this._onChangeCallback();
                    },
                },
            }),
            Object.assign(bn.prototype, {
                isQuaternion: !0,
                set: function (e, t, n, i) {
                    return (this._x = e), (this._y = t), (this._z = n), (this._w = i), this._onChangeCallback(), this;
                },
                clone: function () {
                    return new this.constructor(this._x, this._y, this._z, this._w);
                },
                copy: function (e) {
                    return (this._x = e.x), (this._y = e.y), (this._z = e.z), (this._w = e.w), this._onChangeCallback(), this;
                },
                setFromEuler: function (e, t) {
                    if (!e || !e.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                    var n = e._x,
                        i = e._y,
                        r = e._z,
                        o = e.order,
                        a = Math.cos,
                        s = Math.sin,
                        c = a(n / 2),
                        l = a(i / 2),
                        u = a(r / 2),
                        h = s(n / 2),
                        d = s(i / 2),
                        p = s(r / 2);
                    return (
                        "XYZ" === o
                            ? ((this._x = h * l * u + c * d * p), (this._y = c * d * u - h * l * p), (this._z = c * l * p + h * d * u), (this._w = c * l * u - h * d * p))
                            : "YXZ" === o
                            ? ((this._x = h * l * u + c * d * p), (this._y = c * d * u - h * l * p), (this._z = c * l * p - h * d * u), (this._w = c * l * u + h * d * p))
                            : "ZXY" === o
                            ? ((this._x = h * l * u - c * d * p), (this._y = c * d * u + h * l * p), (this._z = c * l * p + h * d * u), (this._w = c * l * u - h * d * p))
                            : "ZYX" === o
                            ? ((this._x = h * l * u - c * d * p), (this._y = c * d * u + h * l * p), (this._z = c * l * p - h * d * u), (this._w = c * l * u + h * d * p))
                            : "YZX" === o
                            ? ((this._x = h * l * u + c * d * p), (this._y = c * d * u + h * l * p), (this._z = c * l * p - h * d * u), (this._w = c * l * u - h * d * p))
                            : "XZY" === o && ((this._x = h * l * u - c * d * p), (this._y = c * d * u - h * l * p), (this._z = c * l * p + h * d * u), (this._w = c * l * u + h * d * p)),
                        !1 !== t && this._onChangeCallback(),
                        this
                    );
                },
                setFromAxisAngle: function (e, t) {
                    var n = t / 2,
                        i = Math.sin(n);
                    return (this._x = e.x * i), (this._y = e.y * i), (this._z = e.z * i), (this._w = Math.cos(n)), this._onChangeCallback(), this;
                },
                setFromRotationMatrix: function (e) {
                    var t,
                        n = e.elements,
                        i = n[0],
                        r = n[4],
                        o = n[8],
                        a = n[1],
                        s = n[5],
                        c = n[9],
                        l = n[2],
                        u = n[6],
                        h = n[10],
                        d = i + s + h;
                    return (
                        d > 0
                            ? ((t = 0.5 / Math.sqrt(d + 1)), (this._w = 0.25 / t), (this._x = (u - c) * t), (this._y = (o - l) * t), (this._z = (a - r) * t))
                            : i > s && i > h
                            ? ((t = 2 * Math.sqrt(1 + i - s - h)), (this._w = (u - c) / t), (this._x = 0.25 * t), (this._y = (r + a) / t), (this._z = (o + l) / t))
                            : s > h
                            ? ((t = 2 * Math.sqrt(1 + s - i - h)), (this._w = (o - l) / t), (this._x = (r + a) / t), (this._y = 0.25 * t), (this._z = (c + u) / t))
                            : ((t = 2 * Math.sqrt(1 + h - i - s)), (this._w = (a - r) / t), (this._x = (o + l) / t), (this._y = (c + u) / t), (this._z = 0.25 * t)),
                        this._onChangeCallback(),
                        this
                    );
                },
                setFromUnitVectors: function (e, t) {
                    var n = e.dot(t) + 1;
                    return (
                        n < 1e-6
                            ? ((n = 0), Math.abs(e.x) > Math.abs(e.z) ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = n)) : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = n)))
                            : ((this._x = e.y * t.z - e.z * t.y), (this._y = e.z * t.x - e.x * t.z), (this._z = e.x * t.y - e.y * t.x), (this._w = n)),
                        this.normalize()
                    );
                },
                angleTo: function (e) {
                    return 2 * Math.acos(Math.abs(xn.clamp(this.dot(e), -1, 1)));
                },
                rotateTowards: function (e, t) {
                    var n = this.angleTo(e);
                    if (0 === n) return this;
                    var i = Math.min(1, t / n);
                    return this.slerp(e, i), this;
                },
                inverse: function () {
                    return this.conjugate();
                },
                conjugate: function () {
                    return (this._x *= -1), (this._y *= -1), (this._z *= -1), this._onChangeCallback(), this;
                },
                dot: function (e) {
                    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
                },
                lengthSq: function () {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
                },
                length: function () {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
                },
                normalize: function () {
                    var e = this.length();
                    return (
                        0 === e ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1)) : ((e = 1 / e), (this._x = this._x * e), (this._y = this._y * e), (this._z = this._z * e), (this._w = this._w * e)),
                        this._onChangeCallback(),
                        this
                    );
                },
                multiply: function (e, t) {
                    return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e);
                },
                premultiply: function (e) {
                    return this.multiplyQuaternions(e, this);
                },
                multiplyQuaternions: function (e, t) {
                    var n = e._x,
                        i = e._y,
                        r = e._z,
                        o = e._w,
                        a = t._x,
                        s = t._y,
                        c = t._z,
                        l = t._w;
                    return (this._x = n * l + o * a + i * c - r * s), (this._y = i * l + o * s + r * a - n * c), (this._z = r * l + o * c + n * s - i * a), (this._w = o * l - n * a - i * s - r * c), this._onChangeCallback(), this;
                },
                slerp: function (e, t) {
                    if (0 === t) return this;
                    if (1 === t) return this.copy(e);
                    var n = this._x,
                        i = this._y,
                        r = this._z,
                        o = this._w,
                        a = o * e._w + n * e._x + i * e._y + r * e._z;
                    if ((a < 0 ? ((this._w = -e._w), (this._x = -e._x), (this._y = -e._y), (this._z = -e._z), (a = -a)) : this.copy(e), a >= 1)) return (this._w = o), (this._x = n), (this._y = i), (this._z = r), this;
                    var s = 1 - a * a;
                    if (s <= Number.EPSILON) {
                        var c = 1 - t;
                        return (this._w = c * o + t * this._w), (this._x = c * n + t * this._x), (this._y = c * i + t * this._y), (this._z = c * r + t * this._z), this.normalize(), this._onChangeCallback(), this;
                    }
                    var l = Math.sqrt(s),
                        u = Math.atan2(l, a),
                        h = Math.sin((1 - t) * u) / l,
                        d = Math.sin(t * u) / l;
                    return (this._w = o * h + this._w * d), (this._x = n * h + this._x * d), (this._y = i * h + this._y * d), (this._z = r * h + this._z * d), this._onChangeCallback(), this;
                },
                equals: function (e) {
                    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
                },
                fromArray: function (e, t) {
                    return void 0 === t && (t = 0), (this._x = e[t]), (this._y = e[t + 1]), (this._z = e[t + 2]), (this._w = e[t + 3]), this._onChangeCallback(), this;
                },
                toArray: function (e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), (e[t] = this._x), (e[t + 1] = this._y), (e[t + 2] = this._z), (e[t + 3] = this._w), e;
                },
                _onChange: function (e) {
                    return (this._onChangeCallback = e), this;
                },
                _onChangeCallback: function () {},
            });
        var wn = new Sn(),
            Mn = new bn();
        function Sn(e, t, n) {
            (this.x = e || 0), (this.y = t || 0), (this.z = n || 0);
        }
        Object.assign(Sn.prototype, {
            isVector3: !0,
            set: function (e, t, n) {
                return (this.x = e), (this.y = t), (this.z = n), this;
            },
            setScalar: function (e) {
                return (this.x = e), (this.y = e), (this.z = e), this;
            },
            setX: function (e) {
                return (this.x = e), this;
            },
            setY: function (e) {
                return (this.y = e), this;
            },
            setZ: function (e) {
                return (this.z = e), this;
            },
            setComponent: function (e, t) {
                switch (e) {
                    case 0:
                        this.x = t;
                        break;
                    case 1:
                        this.y = t;
                        break;
                    case 2:
                        this.z = t;
                        break;
                    default:
                        throw new Error("index is out of range: " + e);
                }
                return this;
            },
            getComponent: function (e) {
                switch (e) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    default:
                        throw new Error("index is out of range: " + e);
                }
            },
            clone: function () {
                return new this.constructor(this.x, this.y, this.z);
            },
            copy: function (e) {
                return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
            },
            add: function (e, t) {
                return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : ((this.x += e.x), (this.y += e.y), (this.z += e.z), this);
            },
            addScalar: function (e) {
                return (this.x += e), (this.y += e), (this.z += e), this;
            },
            addVectors: function (e, t) {
                return (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this;
            },
            addScaledVector: function (e, t) {
                return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this;
            },
            sub: function (e, t) {
                return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : ((this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this);
            },
            subScalar: function (e) {
                return (this.x -= e), (this.y -= e), (this.z -= e), this;
            },
            subVectors: function (e, t) {
                return (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this;
            },
            multiply: function (e, t) {
                return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : ((this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this);
            },
            multiplyScalar: function (e) {
                return (this.x *= e), (this.y *= e), (this.z *= e), this;
            },
            multiplyVectors: function (e, t) {
                return (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this;
            },
            applyEuler: function (e) {
                return (e && e.isEuler) || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(Mn.setFromEuler(e));
            },
            applyAxisAngle: function (e, t) {
                return this.applyQuaternion(Mn.setFromAxisAngle(e, t));
            },
            applyMatrix3: function (e) {
                var t = this.x,
                    n = this.y,
                    i = this.z,
                    r = e.elements;
                return (this.x = r[0] * t + r[3] * n + r[6] * i), (this.y = r[1] * t + r[4] * n + r[7] * i), (this.z = r[2] * t + r[5] * n + r[8] * i), this;
            },
            applyNormalMatrix: function (e) {
                return this.applyMatrix3(e).normalize();
            },
            applyMatrix4: function (e) {
                var t = this.x,
                    n = this.y,
                    i = this.z,
                    r = e.elements,
                    o = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
                return (this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * o), (this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * o), (this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * o), this;
            },
            applyQuaternion: function (e) {
                var t = this.x,
                    n = this.y,
                    i = this.z,
                    r = e.x,
                    o = e.y,
                    a = e.z,
                    s = e.w,
                    c = s * t + o * i - a * n,
                    l = s * n + a * t - r * i,
                    u = s * i + r * n - o * t,
                    h = -r * t - o * n - a * i;
                return (this.x = c * s + h * -r + l * -a - u * -o), (this.y = l * s + h * -o + u * -r - c * -a), (this.z = u * s + h * -a + c * -o - l * -r), this;
            },
            project: function (e) {
                return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
            },
            unproject: function (e) {
                return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
            },
            transformDirection: function (e) {
                var t = this.x,
                    n = this.y,
                    i = this.z,
                    r = e.elements;
                return (this.x = r[0] * t + r[4] * n + r[8] * i), (this.y = r[1] * t + r[5] * n + r[9] * i), (this.z = r[2] * t + r[6] * n + r[10] * i), this.normalize();
            },
            divide: function (e) {
                return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
            },
            divideScalar: function (e) {
                return this.multiplyScalar(1 / e);
            },
            min: function (e) {
                return (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), (this.z = Math.min(this.z, e.z)), this;
            },
            max: function (e) {
                return (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), (this.z = Math.max(this.z, e.z)), this;
            },
            clamp: function (e, t) {
                return (this.x = Math.max(e.x, Math.min(t.x, this.x))), (this.y = Math.max(e.y, Math.min(t.y, this.y))), (this.z = Math.max(e.z, Math.min(t.z, this.z))), this;
            },
            clampScalar: function (e, t) {
                return (this.x = Math.max(e, Math.min(t, this.x))), (this.y = Math.max(e, Math.min(t, this.y))), (this.z = Math.max(e, Math.min(t, this.z))), this;
            },
            clampLength: function (e, t) {
                var n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
            },
            floor: function () {
                return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), (this.z = Math.floor(this.z)), this;
            },
            ceil: function () {
                return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), (this.z = Math.ceil(this.z)), this;
            },
            round: function () {
                return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), (this.z = Math.round(this.z)), this;
            },
            roundToZero: function () {
                return (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)), (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)), (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)), this;
            },
            negate: function () {
                return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
            },
            dot: function (e) {
                return this.x * e.x + this.y * e.y + this.z * e.z;
            },
            lengthSq: function () {
                return this.x * this.x + this.y * this.y + this.z * this.z;
            },
            length: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            },
            manhattanLength: function () {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
            },
            normalize: function () {
                return this.divideScalar(this.length() || 1);
            },
            setLength: function (e) {
                return this.normalize().multiplyScalar(e);
            },
            lerp: function (e, t) {
                return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), (this.z += (e.z - this.z) * t), this;
            },
            lerpVectors: function (e, t, n) {
                return this.subVectors(t, e).multiplyScalar(n).add(e);
            },
            cross: function (e, t) {
                return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e);
            },
            crossVectors: function (e, t) {
                var n = e.x,
                    i = e.y,
                    r = e.z,
                    o = t.x,
                    a = t.y,
                    s = t.z;
                return (this.x = i * s - r * a), (this.y = r * o - n * s), (this.z = n * a - i * o), this;
            },
            projectOnVector: function (e) {
                var t = e.dot(this) / e.lengthSq();
                return this.copy(e).multiplyScalar(t);
            },
            projectOnPlane: function (e) {
                return wn.copy(this).projectOnVector(e), this.sub(wn);
            },
            reflect: function (e) {
                return this.sub(wn.copy(e).multiplyScalar(2 * this.dot(e)));
            },
            angleTo: function (e) {
                var t = Math.sqrt(this.lengthSq() * e.lengthSq());
                0 === t && console.error("THREE.Vector3: angleTo() can't handle zero length vectors.");
                var n = this.dot(e) / t;
                return Math.acos(xn.clamp(n, -1, 1));
            },
            distanceTo: function (e) {
                return Math.sqrt(this.distanceToSquared(e));
            },
            distanceToSquared: function (e) {
                var t = this.x - e.x,
                    n = this.y - e.y,
                    i = this.z - e.z;
                return t * t + n * n + i * i;
            },
            manhattanDistanceTo: function (e) {
                return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
            },
            setFromSpherical: function (e) {
                return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
            },
            setFromSphericalCoords: function (e, t, n) {
                var i = Math.sin(t) * e;
                return (this.x = i * Math.sin(n)), (this.y = Math.cos(t) * e), (this.z = i * Math.cos(n)), this;
            },
            setFromCylindrical: function (e) {
                return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
            },
            setFromCylindricalCoords: function (e, t, n) {
                return (this.x = e * Math.sin(t)), (this.y = n), (this.z = e * Math.cos(t)), this;
            },
            setFromMatrixPosition: function (e) {
                var t = e.elements;
                return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
            },
            setFromMatrixScale: function (e) {
                var t = this.setFromMatrixColumn(e, 0).length(),
                    n = this.setFromMatrixColumn(e, 1).length(),
                    i = this.setFromMatrixColumn(e, 2).length();
                return (this.x = t), (this.y = n), (this.z = i), this;
            },
            setFromMatrixColumn: function (e, t) {
                return this.fromArray(e.elements, 4 * t);
            },
            equals: function (e) {
                return e.x === this.x && e.y === this.y && e.z === this.z;
            },
            fromArray: function (e, t) {
                return void 0 === t && (t = 0), (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
            },
            toArray: function (e, t) {
                return void 0 === e && (e = []), void 0 === t && (t = 0), (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
            },
            fromBufferAttribute: function (e, t, n) {
                return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this;
            },
        });
        var En,
            Tn = new Sn();
        function An() {
            (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]), arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
        }
        Object.assign(An.prototype, {
            isMatrix3: !0,
            set: function (e, t, n, i, r, o, a, s, c) {
                var l = this.elements;
                return (l[0] = e), (l[1] = i), (l[2] = a), (l[3] = t), (l[4] = r), (l[5] = s), (l[6] = n), (l[7] = o), (l[8] = c), this;
            },
            identity: function () {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
            },
            clone: function () {
                return new this.constructor().fromArray(this.elements);
            },
            copy: function (e) {
                var t = this.elements,
                    n = e.elements;
                return (t[0] = n[0]), (t[1] = n[1]), (t[2] = n[2]), (t[3] = n[3]), (t[4] = n[4]), (t[5] = n[5]), (t[6] = n[6]), (t[7] = n[7]), (t[8] = n[8]), this;
            },
            setFromMatrix4: function (e) {
                var t = e.elements;
                return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this;
            },
            applyToBufferAttribute: function (e) {
                for (var t = 0, n = e.count; t < n; t++) (Tn.x = e.getX(t)), (Tn.y = e.getY(t)), (Tn.z = e.getZ(t)), Tn.applyMatrix3(this), e.setXYZ(t, Tn.x, Tn.y, Tn.z);
                return e;
            },
            multiply: function (e) {
                return this.multiplyMatrices(this, e);
            },
            premultiply: function (e) {
                return this.multiplyMatrices(e, this);
            },
            multiplyMatrices: function (e, t) {
                var n = e.elements,
                    i = t.elements,
                    r = this.elements,
                    o = n[0],
                    a = n[3],
                    s = n[6],
                    c = n[1],
                    l = n[4],
                    u = n[7],
                    h = n[2],
                    d = n[5],
                    p = n[8],
                    f = i[0],
                    m = i[3],
                    v = i[6],
                    g = i[1],
                    y = i[4],
                    x = i[7],
                    _ = i[2],
                    b = i[5],
                    w = i[8];
                return (
                    (r[0] = o * f + a * g + s * _),
                    (r[3] = o * m + a * y + s * b),
                    (r[6] = o * v + a * x + s * w),
                    (r[1] = c * f + l * g + u * _),
                    (r[4] = c * m + l * y + u * b),
                    (r[7] = c * v + l * x + u * w),
                    (r[2] = h * f + d * g + p * _),
                    (r[5] = h * m + d * y + p * b),
                    (r[8] = h * v + d * x + p * w),
                    this
                );
            },
            multiplyScalar: function (e) {
                var t = this.elements;
                return (t[0] *= e), (t[3] *= e), (t[6] *= e), (t[1] *= e), (t[4] *= e), (t[7] *= e), (t[2] *= e), (t[5] *= e), (t[8] *= e), this;
            },
            determinant: function () {
                var e = this.elements,
                    t = e[0],
                    n = e[1],
                    i = e[2],
                    r = e[3],
                    o = e[4],
                    a = e[5],
                    s = e[6],
                    c = e[7],
                    l = e[8];
                return t * o * l - t * a * c - n * r * l + n * a * s + i * r * c - i * o * s;
            },
            getInverse: function (e, t) {
                e && e.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
                var n = e.elements,
                    i = this.elements,
                    r = n[0],
                    o = n[1],
                    a = n[2],
                    s = n[3],
                    c = n[4],
                    l = n[5],
                    u = n[6],
                    h = n[7],
                    d = n[8],
                    p = d * c - l * h,
                    f = l * u - d * s,
                    m = h * s - c * u,
                    v = r * p + o * f + a * m;
                if (0 === v) {
                    var g = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
                    if (!0 === t) throw new Error(g);
                    return console.warn(g), this.identity();
                }
                var y = 1 / v;
                return (
                    (i[0] = p * y),
                    (i[1] = (a * h - d * o) * y),
                    (i[2] = (l * o - a * c) * y),
                    (i[3] = f * y),
                    (i[4] = (d * r - a * u) * y),
                    (i[5] = (a * s - l * r) * y),
                    (i[6] = m * y),
                    (i[7] = (o * u - h * r) * y),
                    (i[8] = (c * r - o * s) * y),
                    this
                );
            },
            transpose: function () {
                var e,
                    t = this.elements;
                return (e = t[1]), (t[1] = t[3]), (t[3] = e), (e = t[2]), (t[2] = t[6]), (t[6] = e), (e = t[5]), (t[5] = t[7]), (t[7] = e), this;
            },
            getNormalMatrix: function (e) {
                return this.setFromMatrix4(e).getInverse(this).transpose();
            },
            transposeIntoArray: function (e) {
                var t = this.elements;
                return (e[0] = t[0]), (e[1] = t[3]), (e[2] = t[6]), (e[3] = t[1]), (e[4] = t[4]), (e[5] = t[7]), (e[6] = t[2]), (e[7] = t[5]), (e[8] = t[8]), this;
            },
            setUvTransform: function (e, t, n, i, r, o, a) {
                var s = Math.cos(r),
                    c = Math.sin(r);
                this.set(n * s, n * c, -n * (s * o + c * a) + o + e, -i * c, i * s, -i * (-c * o + s * a) + a + t, 0, 0, 1);
            },
            scale: function (e, t) {
                var n = this.elements;
                return (n[0] *= e), (n[3] *= e), (n[6] *= e), (n[1] *= t), (n[4] *= t), (n[7] *= t), this;
            },
            rotate: function (e) {
                var t = Math.cos(e),
                    n = Math.sin(e),
                    i = this.elements,
                    r = i[0],
                    o = i[3],
                    a = i[6],
                    s = i[1],
                    c = i[4],
                    l = i[7];
                return (i[0] = t * r + n * s), (i[3] = t * o + n * c), (i[6] = t * a + n * l), (i[1] = -n * r + t * s), (i[4] = -n * o + t * c), (i[7] = -n * a + t * l), this;
            },
            translate: function (e, t) {
                var n = this.elements;
                return (n[0] += e * n[2]), (n[3] += e * n[5]), (n[6] += e * n[8]), (n[1] += t * n[2]), (n[4] += t * n[5]), (n[7] += t * n[8]), this;
            },
            equals: function (e) {
                for (var t = this.elements, n = e.elements, i = 0; i < 9; i++) if (t[i] !== n[i]) return !1;
                return !0;
            },
            fromArray: function (e, t) {
                void 0 === t && (t = 0);
                for (var n = 0; n < 9; n++) this.elements[n] = e[n + t];
                return this;
            },
            toArray: function (e, t) {
                void 0 === e && (e = []), void 0 === t && (t = 0);
                var n = this.elements;
                return (e[t] = n[0]), (e[t + 1] = n[1]), (e[t + 2] = n[2]), (e[t + 3] = n[3]), (e[t + 4] = n[4]), (e[t + 5] = n[5]), (e[t + 6] = n[6]), (e[t + 7] = n[7]), (e[t + 8] = n[8]), e;
            },
        });
        var Ln = {
                getDataURL: function (e) {
                    var t;
                    if ("undefined" == typeof HTMLCanvasElement) return e.src;
                    if (e instanceof HTMLCanvasElement) t = e;
                    else {
                        void 0 === En && (En = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), (En.width = e.width), (En.height = e.height);
                        var n = En.getContext("2d");
                        e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), (t = En);
                    }
                    return t.width > 2048 || t.height > 2048 ? t.toDataURL("image/jpeg", 0.6) : t.toDataURL("image/png");
                },
            },
            Cn = 0;
        function Rn(e, t, n, i, r, o, a, s, c, l) {
            Object.defineProperty(this, "id", { value: Cn++ }),
                (this.uuid = xn.generateUUID()),
                (this.name = ""),
                (this.image = void 0 !== e ? e : Rn.DEFAULT_IMAGE),
                (this.mipmaps = []),
                (this.mapping = void 0 !== t ? t : Rn.DEFAULT_MAPPING),
                (this.wrapS = void 0 !== n ? n : ye),
                (this.wrapT = void 0 !== i ? i : ye),
                (this.magFilter = void 0 !== r ? r : Ee),
                (this.minFilter = void 0 !== o ? o : Le),
                (this.anisotropy = void 0 !== c ? c : 1),
                (this.format = void 0 !== a ? a : je),
                (this.type = void 0 !== s ? s : Re),
                (this.offset = new _n(0, 0)),
                (this.repeat = new _n(1, 1)),
                (this.center = new _n(0, 0)),
                (this.rotation = 0),
                (this.matrixAutoUpdate = !0),
                (this.matrix = new An()),
                (this.generateMipmaps = !0),
                (this.premultiplyAlpha = !1),
                (this.flipY = !0),
                (this.unpackAlignment = 4),
                (this.encoding = void 0 !== l ? l : Ot),
                (this.version = 0),
                (this.onUpdate = null);
        }
        function Pn(e, t, n, i) {
            (this.x = e || 0), (this.y = t || 0), (this.z = n || 0), (this.w = void 0 !== i ? i : 1);
        }
        function On(e, t, n) {
            (this.width = e),
                (this.height = t),
                (this.scissor = new Pn(0, 0, e, t)),
                (this.scissorTest = !1),
                (this.viewport = new Pn(0, 0, e, t)),
                (n = n || {}),
                (this.texture = new Rn(void 0, void 0, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding)),
                (this.texture.image = {}),
                (this.texture.image.width = e),
                (this.texture.image.height = t),
                (this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps),
                (this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : Ee),
                (this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer),
                (this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer),
                (this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null);
        }
        function Dn(e, t, n) {
            On.call(this, e, t, n), (this.samples = 4);
        }
        (Rn.DEFAULT_IMAGE = void 0),
            (Rn.DEFAULT_MAPPING = le),
            (Rn.prototype = Object.assign(Object.create(vn.prototype), {
                constructor: Rn,
                isTexture: !0,
                updateMatrix: function () {
                    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
                },
                clone: function () {
                    return new this.constructor().copy(this);
                },
                copy: function (e) {
                    return (
                        (this.name = e.name),
                        (this.image = e.image),
                        (this.mipmaps = e.mipmaps.slice(0)),
                        (this.mapping = e.mapping),
                        (this.wrapS = e.wrapS),
                        (this.wrapT = e.wrapT),
                        (this.magFilter = e.magFilter),
                        (this.minFilter = e.minFilter),
                        (this.anisotropy = e.anisotropy),
                        (this.format = e.format),
                        (this.type = e.type),
                        this.offset.copy(e.offset),
                        this.repeat.copy(e.repeat),
                        this.center.copy(e.center),
                        (this.rotation = e.rotation),
                        (this.matrixAutoUpdate = e.matrixAutoUpdate),
                        this.matrix.copy(e.matrix),
                        (this.generateMipmaps = e.generateMipmaps),
                        (this.premultiplyAlpha = e.premultiplyAlpha),
                        (this.flipY = e.flipY),
                        (this.unpackAlignment = e.unpackAlignment),
                        (this.encoding = e.encoding),
                        this
                    );
                },
                toJSON: function (e) {
                    var t = void 0 === e || "string" == typeof e;
                    if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
                    var n = {
                        metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" },
                        uuid: this.uuid,
                        name: this.name,
                        mapping: this.mapping,
                        repeat: [this.repeat.x, this.repeat.y],
                        offset: [this.offset.x, this.offset.y],
                        center: [this.center.x, this.center.y],
                        rotation: this.rotation,
                        wrap: [this.wrapS, this.wrapT],
                        format: this.format,
                        type: this.type,
                        encoding: this.encoding,
                        minFilter: this.minFilter,
                        magFilter: this.magFilter,
                        anisotropy: this.anisotropy,
                        flipY: this.flipY,
                        premultiplyAlpha: this.premultiplyAlpha,
                        unpackAlignment: this.unpackAlignment,
                    };
                    if (void 0 !== this.image) {
                        var i = this.image;
                        if ((void 0 === i.uuid && (i.uuid = xn.generateUUID()), !t && void 0 === e.images[i.uuid])) {
                            var r;
                            if (Array.isArray(i)) {
                                r = [];
                                for (var o = 0, a = i.length; o < a; o++) r.push(Ln.getDataURL(i[o]));
                            } else r = Ln.getDataURL(i);
                            e.images[i.uuid] = { uuid: i.uuid, url: r };
                        }
                        n.image = i.uuid;
                    }
                    return t || (e.textures[this.uuid] = n), n;
                },
                dispose: function () {
                    this.dispatchEvent({ type: "dispose" });
                },
                transformUv: function (e) {
                    if (this.mapping !== le) return e;
                    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
                        switch (this.wrapS) {
                            case ge:
                                e.x = e.x - Math.floor(e.x);
                                break;
                            case ye:
                                e.x = e.x < 0 ? 0 : 1;
                                break;
                            case xe:
                                1 === Math.abs(Math.floor(e.x) % 2) ? (e.x = Math.ceil(e.x) - e.x) : (e.x = e.x - Math.floor(e.x));
                        }
                    if (e.y < 0 || e.y > 1)
                        switch (this.wrapT) {
                            case ge:
                                e.y = e.y - Math.floor(e.y);
                                break;
                            case ye:
                                e.y = e.y < 0 ? 0 : 1;
                                break;
                            case xe:
                                1 === Math.abs(Math.floor(e.y) % 2) ? (e.y = Math.ceil(e.y) - e.y) : (e.y = e.y - Math.floor(e.y));
                        }
                    return this.flipY && (e.y = 1 - e.y), e;
                },
            })),
            Object.defineProperty(Rn.prototype, "needsUpdate", {
                set: function (e) {
                    !0 === e && this.version++;
                },
            }),
            Object.defineProperties(Pn.prototype, {
                width: {
                    get: function () {
                        return this.z;
                    },
                    set: function (e) {
                        this.z = e;
                    },
                },
                height: {
                    get: function () {
                        return this.w;
                    },
                    set: function (e) {
                        this.w = e;
                    },
                },
            }),
            Object.assign(Pn.prototype, {
                isVector4: !0,
                set: function (e, t, n, i) {
                    return (this.x = e), (this.y = t), (this.z = n), (this.w = i), this;
                },
                setScalar: function (e) {
                    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
                },
                setX: function (e) {
                    return (this.x = e), this;
                },
                setY: function (e) {
                    return (this.y = e), this;
                },
                setZ: function (e) {
                    return (this.z = e), this;
                },
                setW: function (e) {
                    return (this.w = e), this;
                },
                setComponent: function (e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        case 2:
                            this.z = t;
                            break;
                        case 3:
                            this.w = t;
                            break;
                        default:
                            throw new Error("index is out of range: " + e);
                    }
                    return this;
                },
                getComponent: function (e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw new Error("index is out of range: " + e);
                    }
                },
                clone: function () {
                    return new this.constructor(this.x, this.y, this.z, this.w);
                },
                copy: function (e) {
                    return (this.x = e.x), (this.y = e.y), (this.z = e.z), (this.w = void 0 !== e.w ? e.w : 1), this;
                },
                add: function (e, t) {
                    return void 0 !== t
                        ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t))
                        : ((this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this);
                },
                addScalar: function (e) {
                    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
                },
                addVectors: function (e, t) {
                    return (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), (this.w = e.w + t.w), this;
                },
                addScaledVector: function (e, t) {
                    return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), (this.w += e.w * t), this;
                },
                sub: function (e, t) {
                    return void 0 !== t
                        ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t))
                        : ((this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this);
                },
                subScalar: function (e) {
                    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
                },
                subVectors: function (e, t) {
                    return (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), (this.w = e.w - t.w), this;
                },
                multiplyScalar: function (e) {
                    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
                },
                applyMatrix4: function (e) {
                    var t = this.x,
                        n = this.y,
                        i = this.z,
                        r = this.w,
                        o = e.elements;
                    return (
                        (this.x = o[0] * t + o[4] * n + o[8] * i + o[12] * r),
                        (this.y = o[1] * t + o[5] * n + o[9] * i + o[13] * r),
                        (this.z = o[2] * t + o[6] * n + o[10] * i + o[14] * r),
                        (this.w = o[3] * t + o[7] * n + o[11] * i + o[15] * r),
                        this
                    );
                },
                divideScalar: function (e) {
                    return this.multiplyScalar(1 / e);
                },
                setAxisAngleFromQuaternion: function (e) {
                    this.w = 2 * Math.acos(e.w);
                    var t = Math.sqrt(1 - e.w * e.w);
                    return t < 1e-4 ? ((this.x = 1), (this.y = 0), (this.z = 0)) : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)), this;
                },
                setAxisAngleFromRotationMatrix: function (e) {
                    var t,
                        n,
                        i,
                        r,
                        o = e.elements,
                        a = o[0],
                        s = o[4],
                        c = o[8],
                        l = o[1],
                        u = o[5],
                        h = o[9],
                        d = o[2],
                        p = o[6],
                        f = o[10];
                    if (Math.abs(s - l) < 0.01 && Math.abs(c - d) < 0.01 && Math.abs(h - p) < 0.01) {
                        if (Math.abs(s + l) < 0.1 && Math.abs(c + d) < 0.1 && Math.abs(h + p) < 0.1 && Math.abs(a + u + f - 3) < 0.1) return this.set(1, 0, 0, 0), this;
                        t = Math.PI;
                        var m = (a + 1) / 2,
                            v = (u + 1) / 2,
                            g = (f + 1) / 2,
                            y = (s + l) / 4,
                            x = (c + d) / 4,
                            _ = (h + p) / 4;
                        return (
                            m > v && m > g
                                ? m < 0.01
                                    ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
                                    : ((i = y / (n = Math.sqrt(m))), (r = x / n))
                                : v > g
                                ? v < 0.01
                                    ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
                                    : ((n = y / (i = Math.sqrt(v))), (r = _ / i))
                                : g < 0.01
                                ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
                                : ((n = x / (r = Math.sqrt(g))), (i = _ / r)),
                            this.set(n, i, r, t),
                            this
                        );
                    }
                    var b = Math.sqrt((p - h) * (p - h) + (c - d) * (c - d) + (l - s) * (l - s));
                    return Math.abs(b) < 0.001 && (b = 1), (this.x = (p - h) / b), (this.y = (c - d) / b), (this.z = (l - s) / b), (this.w = Math.acos((a + u + f - 1) / 2)), this;
                },
                min: function (e) {
                    return (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), (this.z = Math.min(this.z, e.z)), (this.w = Math.min(this.w, e.w)), this;
                },
                max: function (e) {
                    return (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), (this.z = Math.max(this.z, e.z)), (this.w = Math.max(this.w, e.w)), this;
                },
                clamp: function (e, t) {
                    return (this.x = Math.max(e.x, Math.min(t.x, this.x))), (this.y = Math.max(e.y, Math.min(t.y, this.y))), (this.z = Math.max(e.z, Math.min(t.z, this.z))), (this.w = Math.max(e.w, Math.min(t.w, this.w))), this;
                },
                clampScalar: function (e, t) {
                    return (this.x = Math.max(e, Math.min(t, this.x))), (this.y = Math.max(e, Math.min(t, this.y))), (this.z = Math.max(e, Math.min(t, this.z))), (this.w = Math.max(e, Math.min(t, this.w))), this;
                },
                clampLength: function (e, t) {
                    var n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
                },
                floor: function () {
                    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), (this.z = Math.floor(this.z)), (this.w = Math.floor(this.w)), this;
                },
                ceil: function () {
                    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), (this.z = Math.ceil(this.z)), (this.w = Math.ceil(this.w)), this;
                },
                round: function () {
                    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), (this.z = Math.round(this.z)), (this.w = Math.round(this.w)), this;
                },
                roundToZero: function () {
                    return (
                        (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
                        (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
                        (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
                        (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
                        this
                    );
                },
                negate: function () {
                    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), (this.w = -this.w), this;
                },
                dot: function (e) {
                    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
                },
                lengthSq: function () {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
                },
                length: function () {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
                },
                manhattanLength: function () {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
                },
                normalize: function () {
                    return this.divideScalar(this.length() || 1);
                },
                setLength: function (e) {
                    return this.normalize().multiplyScalar(e);
                },
                lerp: function (e, t) {
                    return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), (this.z += (e.z - this.z) * t), (this.w += (e.w - this.w) * t), this;
                },
                lerpVectors: function (e, t, n) {
                    return this.subVectors(t, e).multiplyScalar(n).add(e);
                },
                equals: function (e) {
                    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
                },
                fromArray: function (e, t) {
                    return void 0 === t && (t = 0), (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), (this.w = e[t + 3]), this;
                },
                toArray: function (e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), (e[t + 3] = this.w), e;
                },
                fromBufferAttribute: function (e, t, n) {
                    return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), (this.w = e.getW(t)), this;
                },
            }),
            (On.prototype = Object.assign(Object.create(vn.prototype), {
                constructor: On,
                isWebGLRenderTarget: !0,
                setSize: function (e, t) {
                    (this.width === e && this.height === t) || ((this.width = e), (this.height = t), (this.texture.image.width = e), (this.texture.image.height = t), this.dispose()),
                        this.viewport.set(0, 0, e, t),
                        this.scissor.set(0, 0, e, t);
                },
                clone: function () {
                    return new this.constructor().copy(this);
                },
                copy: function (e) {
                    return (
                        (this.width = e.width),
                        (this.height = e.height),
                        this.viewport.copy(e.viewport),
                        (this.texture = e.texture.clone()),
                        (this.depthBuffer = e.depthBuffer),
                        (this.stencilBuffer = e.stencilBuffer),
                        (this.depthTexture = e.depthTexture),
                        this
                    );
                },
                dispose: function () {
                    this.dispatchEvent({ type: "dispose" });
                },
            })),
            (Dn.prototype = Object.assign(Object.create(On.prototype), {
                constructor: Dn,
                isWebGLMultisampleRenderTarget: !0,
                copy: function (e) {
                    return On.prototype.copy.call(this, e), (this.samples = e.samples), this;
                },
            }));
        var In = new Sn(),
            Nn = new Hn(),
            Un = new Sn(0, 0, 0),
            Bn = new Sn(1, 1, 1),
            zn = new Sn(),
            Fn = new Sn(),
            Gn = new Sn();
        function Hn() {
            (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
        }
        Object.assign(Hn.prototype, {
            isMatrix4: !0,
            set: function (e, t, n, i, r, o, a, s, c, l, u, h, d, p, f, m) {
                var v = this.elements;
                return (v[0] = e), (v[4] = t), (v[8] = n), (v[12] = i), (v[1] = r), (v[5] = o), (v[9] = a), (v[13] = s), (v[2] = c), (v[6] = l), (v[10] = u), (v[14] = h), (v[3] = d), (v[7] = p), (v[11] = f), (v[15] = m), this;
            },
            identity: function () {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
            },
            clone: function () {
                return new Hn().fromArray(this.elements);
            },
            copy: function (e) {
                var t = this.elements,
                    n = e.elements;
                return (
                    (t[0] = n[0]),
                    (t[1] = n[1]),
                    (t[2] = n[2]),
                    (t[3] = n[3]),
                    (t[4] = n[4]),
                    (t[5] = n[5]),
                    (t[6] = n[6]),
                    (t[7] = n[7]),
                    (t[8] = n[8]),
                    (t[9] = n[9]),
                    (t[10] = n[10]),
                    (t[11] = n[11]),
                    (t[12] = n[12]),
                    (t[13] = n[13]),
                    (t[14] = n[14]),
                    (t[15] = n[15]),
                    this
                );
            },
            copyPosition: function (e) {
                var t = this.elements,
                    n = e.elements;
                return (t[12] = n[12]), (t[13] = n[13]), (t[14] = n[14]), this;
            },
            extractBasis: function (e, t, n) {
                return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
            },
            makeBasis: function (e, t, n) {
                return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this;
            },
            extractRotation: function (e) {
                var t = this.elements,
                    n = e.elements,
                    i = 1 / In.setFromMatrixColumn(e, 0).length(),
                    r = 1 / In.setFromMatrixColumn(e, 1).length(),
                    o = 1 / In.setFromMatrixColumn(e, 2).length();
                return (
                    (t[0] = n[0] * i),
                    (t[1] = n[1] * i),
                    (t[2] = n[2] * i),
                    (t[3] = 0),
                    (t[4] = n[4] * r),
                    (t[5] = n[5] * r),
                    (t[6] = n[6] * r),
                    (t[7] = 0),
                    (t[8] = n[8] * o),
                    (t[9] = n[9] * o),
                    (t[10] = n[10] * o),
                    (t[11] = 0),
                    (t[12] = 0),
                    (t[13] = 0),
                    (t[14] = 0),
                    (t[15] = 1),
                    this
                );
            },
            makeRotationFromEuler: function (e) {
                (e && e.isEuler) || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                var t = this.elements,
                    n = e.x,
                    i = e.y,
                    r = e.z,
                    o = Math.cos(n),
                    a = Math.sin(n),
                    s = Math.cos(i),
                    c = Math.sin(i),
                    l = Math.cos(r),
                    u = Math.sin(r);
                if ("XYZ" === e.order) {
                    var h = o * l,
                        d = o * u,
                        p = a * l,
                        f = a * u;
                    (t[0] = s * l), (t[4] = -s * u), (t[8] = c), (t[1] = d + p * c), (t[5] = h - f * c), (t[9] = -a * s), (t[2] = f - h * c), (t[6] = p + d * c), (t[10] = o * s);
                } else if ("YXZ" === e.order) {
                    var m = s * l,
                        v = s * u,
                        g = c * l,
                        y = c * u;
                    (t[0] = m + y * a), (t[4] = g * a - v), (t[8] = o * c), (t[1] = o * u), (t[5] = o * l), (t[9] = -a), (t[2] = v * a - g), (t[6] = y + m * a), (t[10] = o * s);
                } else if ("ZXY" === e.order) {
                    (m = s * l), (v = s * u), (g = c * l), (y = c * u);
                    (t[0] = m - y * a), (t[4] = -o * u), (t[8] = g + v * a), (t[1] = v + g * a), (t[5] = o * l), (t[9] = y - m * a), (t[2] = -o * c), (t[6] = a), (t[10] = o * s);
                } else if ("ZYX" === e.order) {
                    (h = o * l), (d = o * u), (p = a * l), (f = a * u);
                    (t[0] = s * l), (t[4] = p * c - d), (t[8] = h * c + f), (t[1] = s * u), (t[5] = f * c + h), (t[9] = d * c - p), (t[2] = -c), (t[6] = a * s), (t[10] = o * s);
                } else if ("YZX" === e.order) {
                    var x = o * s,
                        _ = o * c,
                        b = a * s,
                        w = a * c;
                    (t[0] = s * l), (t[4] = w - x * u), (t[8] = b * u + _), (t[1] = u), (t[5] = o * l), (t[9] = -a * l), (t[2] = -c * l), (t[6] = _ * u + b), (t[10] = x - w * u);
                } else if ("XZY" === e.order) {
                    (x = o * s), (_ = o * c), (b = a * s), (w = a * c);
                    (t[0] = s * l), (t[4] = -u), (t[8] = c * l), (t[1] = x * u + w), (t[5] = o * l), (t[9] = _ * u - b), (t[2] = b * u - _), (t[6] = a * l), (t[10] = w * u + x);
                }
                return (t[3] = 0), (t[7] = 0), (t[11] = 0), (t[12] = 0), (t[13] = 0), (t[14] = 0), (t[15] = 1), this;
            },
            makeRotationFromQuaternion: function (e) {
                return this.compose(Un, e, Bn);
            },
            lookAt: function (e, t, n) {
                var i = this.elements;
                return (
                    Gn.subVectors(e, t),
                    0 === Gn.lengthSq() && (Gn.z = 1),
                    Gn.normalize(),
                    zn.crossVectors(n, Gn),
                    0 === zn.lengthSq() && (1 === Math.abs(n.z) ? (Gn.x += 1e-4) : (Gn.z += 1e-4), Gn.normalize(), zn.crossVectors(n, Gn)),
                    zn.normalize(),
                    Fn.crossVectors(Gn, zn),
                    (i[0] = zn.x),
                    (i[4] = Fn.x),
                    (i[8] = Gn.x),
                    (i[1] = zn.y),
                    (i[5] = Fn.y),
                    (i[9] = Gn.y),
                    (i[2] = zn.z),
                    (i[6] = Fn.z),
                    (i[10] = Gn.z),
                    this
                );
            },
            multiply: function (e, t) {
                return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e);
            },
            premultiply: function (e) {
                return this.multiplyMatrices(e, this);
            },
            multiplyMatrices: function (e, t) {
                var n = e.elements,
                    i = t.elements,
                    r = this.elements,
                    o = n[0],
                    a = n[4],
                    s = n[8],
                    c = n[12],
                    l = n[1],
                    u = n[5],
                    h = n[9],
                    d = n[13],
                    p = n[2],
                    f = n[6],
                    m = n[10],
                    v = n[14],
                    g = n[3],
                    y = n[7],
                    x = n[11],
                    _ = n[15],
                    b = i[0],
                    w = i[4],
                    M = i[8],
                    S = i[12],
                    E = i[1],
                    T = i[5],
                    A = i[9],
                    L = i[13],
                    C = i[2],
                    R = i[6],
                    P = i[10],
                    O = i[14],
                    D = i[3],
                    I = i[7],
                    N = i[11],
                    U = i[15];
                return (
                    (r[0] = o * b + a * E + s * C + c * D),
                    (r[4] = o * w + a * T + s * R + c * I),
                    (r[8] = o * M + a * A + s * P + c * N),
                    (r[12] = o * S + a * L + s * O + c * U),
                    (r[1] = l * b + u * E + h * C + d * D),
                    (r[5] = l * w + u * T + h * R + d * I),
                    (r[9] = l * M + u * A + h * P + d * N),
                    (r[13] = l * S + u * L + h * O + d * U),
                    (r[2] = p * b + f * E + m * C + v * D),
                    (r[6] = p * w + f * T + m * R + v * I),
                    (r[10] = p * M + f * A + m * P + v * N),
                    (r[14] = p * S + f * L + m * O + v * U),
                    (r[3] = g * b + y * E + x * C + _ * D),
                    (r[7] = g * w + y * T + x * R + _ * I),
                    (r[11] = g * M + y * A + x * P + _ * N),
                    (r[15] = g * S + y * L + x * O + _ * U),
                    this
                );
            },
            multiplyScalar: function (e) {
                var t = this.elements;
                return (
                    (t[0] *= e), (t[4] *= e), (t[8] *= e), (t[12] *= e), (t[1] *= e), (t[5] *= e), (t[9] *= e), (t[13] *= e), (t[2] *= e), (t[6] *= e), (t[10] *= e), (t[14] *= e), (t[3] *= e), (t[7] *= e), (t[11] *= e), (t[15] *= e), this
                );
            },
            applyToBufferAttribute: function (e) {
                for (var t = 0, n = e.count; t < n; t++) (In.x = e.getX(t)), (In.y = e.getY(t)), (In.z = e.getZ(t)), In.applyMatrix4(this), e.setXYZ(t, In.x, In.y, In.z);
                return e;
            },
            determinant: function () {
                var e = this.elements,
                    t = e[0],
                    n = e[4],
                    i = e[8],
                    r = e[12],
                    o = e[1],
                    a = e[5],
                    s = e[9],
                    c = e[13],
                    l = e[2],
                    u = e[6],
                    h = e[10],
                    d = e[14];
                return (
                    e[3] * (+r * s * u - i * c * u - r * a * h + n * c * h + i * a * d - n * s * d) +
                    e[7] * (+t * s * d - t * c * h + r * o * h - i * o * d + i * c * l - r * s * l) +
                    e[11] * (+t * c * u - t * a * d - r * o * u + n * o * d + r * a * l - n * c * l) +
                    e[15] * (-i * a * l - t * s * u + t * a * h + i * o * u - n * o * h + n * s * l)
                );
            },
            transpose: function () {
                var e,
                    t = this.elements;
                return (
                    (e = t[1]),
                    (t[1] = t[4]),
                    (t[4] = e),
                    (e = t[2]),
                    (t[2] = t[8]),
                    (t[8] = e),
                    (e = t[6]),
                    (t[6] = t[9]),
                    (t[9] = e),
                    (e = t[3]),
                    (t[3] = t[12]),
                    (t[12] = e),
                    (e = t[7]),
                    (t[7] = t[13]),
                    (t[13] = e),
                    (e = t[11]),
                    (t[11] = t[14]),
                    (t[14] = e),
                    this
                );
            },
            setPosition: function (e, t, n) {
                var i = this.elements;
                return e.isVector3 ? ((i[12] = e.x), (i[13] = e.y), (i[14] = e.z)) : ((i[12] = e), (i[13] = t), (i[14] = n)), this;
            },
            getInverse: function (e, t) {
                var n = this.elements,
                    i = e.elements,
                    r = i[0],
                    o = i[1],
                    a = i[2],
                    s = i[3],
                    c = i[4],
                    l = i[5],
                    u = i[6],
                    h = i[7],
                    d = i[8],
                    p = i[9],
                    f = i[10],
                    m = i[11],
                    v = i[12],
                    g = i[13],
                    y = i[14],
                    x = i[15],
                    _ = p * y * h - g * f * h + g * u * m - l * y * m - p * u * x + l * f * x,
                    b = v * f * h - d * y * h - v * u * m + c * y * m + d * u * x - c * f * x,
                    w = d * g * h - v * p * h + v * l * m - c * g * m - d * l * x + c * p * x,
                    M = v * p * u - d * g * u - v * l * f + c * g * f + d * l * y - c * p * y,
                    S = r * _ + o * b + a * w + s * M;
                if (0 === S) {
                    var E = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
                    if (!0 === t) throw new Error(E);
                    return console.warn(E), this.identity();
                }
                var T = 1 / S;
                return (
                    (n[0] = _ * T),
                    (n[1] = (g * f * s - p * y * s - g * a * m + o * y * m + p * a * x - o * f * x) * T),
                    (n[2] = (l * y * s - g * u * s + g * a * h - o * y * h - l * a * x + o * u * x) * T),
                    (n[3] = (p * u * s - l * f * s - p * a * h + o * f * h + l * a * m - o * u * m) * T),
                    (n[4] = b * T),
                    (n[5] = (d * y * s - v * f * s + v * a * m - r * y * m - d * a * x + r * f * x) * T),
                    (n[6] = (v * u * s - c * y * s - v * a * h + r * y * h + c * a * x - r * u * x) * T),
                    (n[7] = (c * f * s - d * u * s + d * a * h - r * f * h - c * a * m + r * u * m) * T),
                    (n[8] = w * T),
                    (n[9] = (v * p * s - d * g * s - v * o * m + r * g * m + d * o * x - r * p * x) * T),
                    (n[10] = (c * g * s - v * l * s + v * o * h - r * g * h - c * o * x + r * l * x) * T),
                    (n[11] = (d * l * s - c * p * s - d * o * h + r * p * h + c * o * m - r * l * m) * T),
                    (n[12] = M * T),
                    (n[13] = (d * g * a - v * p * a + v * o * f - r * g * f - d * o * y + r * p * y) * T),
                    (n[14] = (v * l * a - c * g * a - v * o * u + r * g * u + c * o * y - r * l * y) * T),
                    (n[15] = (c * p * a - d * l * a + d * o * u - r * p * u - c * o * f + r * l * f) * T),
                    this
                );
            },
            scale: function (e) {
                var t = this.elements,
                    n = e.x,
                    i = e.y,
                    r = e.z;
                return (t[0] *= n), (t[4] *= i), (t[8] *= r), (t[1] *= n), (t[5] *= i), (t[9] *= r), (t[2] *= n), (t[6] *= i), (t[10] *= r), (t[3] *= n), (t[7] *= i), (t[11] *= r), this;
            },
            getMaxScaleOnAxis: function () {
                var e = this.elements,
                    t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                    n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
                    i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                return Math.sqrt(Math.max(t, n, i));
            },
            makeTranslation: function (e, t, n) {
                return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this;
            },
            makeRotationX: function (e) {
                var t = Math.cos(e),
                    n = Math.sin(e);
                return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this;
            },
            makeRotationY: function (e) {
                var t = Math.cos(e),
                    n = Math.sin(e);
                return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this;
            },
            makeRotationZ: function (e) {
                var t = Math.cos(e),
                    n = Math.sin(e);
                return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
            },
            makeRotationAxis: function (e, t) {
                var n = Math.cos(t),
                    i = Math.sin(t),
                    r = 1 - n,
                    o = e.x,
                    a = e.y,
                    s = e.z,
                    c = r * o,
                    l = r * a;
                return this.set(c * o + n, c * a - i * s, c * s + i * a, 0, c * a + i * s, l * a + n, l * s - i * o, 0, c * s - i * a, l * s + i * o, r * s * s + n, 0, 0, 0, 0, 1), this;
            },
            makeScale: function (e, t, n) {
                return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
            },
            makeShear: function (e, t, n) {
                return this.set(1, t, n, 0, e, 1, n, 0, e, t, 1, 0, 0, 0, 0, 1), this;
            },
            compose: function (e, t, n) {
                var i = this.elements,
                    r = t._x,
                    o = t._y,
                    a = t._z,
                    s = t._w,
                    c = r + r,
                    l = o + o,
                    u = a + a,
                    h = r * c,
                    d = r * l,
                    p = r * u,
                    f = o * l,
                    m = o * u,
                    v = a * u,
                    g = s * c,
                    y = s * l,
                    x = s * u,
                    _ = n.x,
                    b = n.y,
                    w = n.z;
                return (
                    (i[0] = (1 - (f + v)) * _),
                    (i[1] = (d + x) * _),
                    (i[2] = (p - y) * _),
                    (i[3] = 0),
                    (i[4] = (d - x) * b),
                    (i[5] = (1 - (h + v)) * b),
                    (i[6] = (m + g) * b),
                    (i[7] = 0),
                    (i[8] = (p + y) * w),
                    (i[9] = (m - g) * w),
                    (i[10] = (1 - (h + f)) * w),
                    (i[11] = 0),
                    (i[12] = e.x),
                    (i[13] = e.y),
                    (i[14] = e.z),
                    (i[15] = 1),
                    this
                );
            },
            decompose: function (e, t, n) {
                var i = this.elements,
                    r = In.set(i[0], i[1], i[2]).length(),
                    o = In.set(i[4], i[5], i[6]).length(),
                    a = In.set(i[8], i[9], i[10]).length();
                this.determinant() < 0 && (r = -r), (e.x = i[12]), (e.y = i[13]), (e.z = i[14]), Nn.copy(this);
                var s = 1 / r,
                    c = 1 / o,
                    l = 1 / a;
                return (
                    (Nn.elements[0] *= s),
                    (Nn.elements[1] *= s),
                    (Nn.elements[2] *= s),
                    (Nn.elements[4] *= c),
                    (Nn.elements[5] *= c),
                    (Nn.elements[6] *= c),
                    (Nn.elements[8] *= l),
                    (Nn.elements[9] *= l),
                    (Nn.elements[10] *= l),
                    t.setFromRotationMatrix(Nn),
                    (n.x = r),
                    (n.y = o),
                    (n.z = a),
                    this
                );
            },
            makePerspective: function (e, t, n, i, r, o) {
                void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                var a = this.elements,
                    s = (2 * r) / (t - e),
                    c = (2 * r) / (n - i),
                    l = (t + e) / (t - e),
                    u = (n + i) / (n - i),
                    h = -(o + r) / (o - r),
                    d = (-2 * o * r) / (o - r);
                return (a[0] = s), (a[4] = 0), (a[8] = l), (a[12] = 0), (a[1] = 0), (a[5] = c), (a[9] = u), (a[13] = 0), (a[2] = 0), (a[6] = 0), (a[10] = h), (a[14] = d), (a[3] = 0), (a[7] = 0), (a[11] = -1), (a[15] = 0), this;
            },
            makeOrthographic: function (e, t, n, i, r, o) {
                var a = this.elements,
                    s = 1 / (t - e),
                    c = 1 / (n - i),
                    l = 1 / (o - r),
                    u = (t + e) * s,
                    h = (n + i) * c,
                    d = (o + r) * l;
                return (
                    (a[0] = 2 * s), (a[4] = 0), (a[8] = 0), (a[12] = -u), (a[1] = 0), (a[5] = 2 * c), (a[9] = 0), (a[13] = -h), (a[2] = 0), (a[6] = 0), (a[10] = -2 * l), (a[14] = -d), (a[3] = 0), (a[7] = 0), (a[11] = 0), (a[15] = 1), this
                );
            },
            equals: function (e) {
                for (var t = this.elements, n = e.elements, i = 0; i < 16; i++) if (t[i] !== n[i]) return !1;
                return !0;
            },
            fromArray: function (e, t) {
                void 0 === t && (t = 0);
                for (var n = 0; n < 16; n++) this.elements[n] = e[n + t];
                return this;
            },
            toArray: function (e, t) {
                void 0 === e && (e = []), void 0 === t && (t = 0);
                var n = this.elements;
                return (
                    (e[t] = n[0]),
                    (e[t + 1] = n[1]),
                    (e[t + 2] = n[2]),
                    (e[t + 3] = n[3]),
                    (e[t + 4] = n[4]),
                    (e[t + 5] = n[5]),
                    (e[t + 6] = n[6]),
                    (e[t + 7] = n[7]),
                    (e[t + 8] = n[8]),
                    (e[t + 9] = n[9]),
                    (e[t + 10] = n[10]),
                    (e[t + 11] = n[11]),
                    (e[t + 12] = n[12]),
                    (e[t + 13] = n[13]),
                    (e[t + 14] = n[14]),
                    (e[t + 15] = n[15]),
                    e
                );
            },
        });
        var Vn = new Hn(),
            kn = new bn();
        function jn(e, t, n, i) {
            (this._x = e || 0), (this._y = t || 0), (this._z = n || 0), (this._order = i || jn.DefaultOrder);
        }
        function Wn() {
            this.mask = 1;
        }
        (jn.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]),
            (jn.DefaultOrder = "XYZ"),
            Object.defineProperties(jn.prototype, {
                x: {
                    get: function () {
                        return this._x;
                    },
                    set: function (e) {
                        (this._x = e), this._onChangeCallback();
                    },
                },
                y: {
                    get: function () {
                        return this._y;
                    },
                    set: function (e) {
                        (this._y = e), this._onChangeCallback();
                    },
                },
                z: {
                    get: function () {
                        return this._z;
                    },
                    set: function (e) {
                        (this._z = e), this._onChangeCallback();
                    },
                },
                order: {
                    get: function () {
                        return this._order;
                    },
                    set: function (e) {
                        (this._order = e), this._onChangeCallback();
                    },
                },
            }),
            Object.assign(jn.prototype, {
                isEuler: !0,
                set: function (e, t, n, i) {
                    return (this._x = e), (this._y = t), (this._z = n), (this._order = i || this._order), this._onChangeCallback(), this;
                },
                clone: function () {
                    return new this.constructor(this._x, this._y, this._z, this._order);
                },
                copy: function (e) {
                    return (this._x = e._x), (this._y = e._y), (this._z = e._z), (this._order = e._order), this._onChangeCallback(), this;
                },
                setFromRotationMatrix: function (e, t, n) {
                    var i = xn.clamp,
                        r = e.elements,
                        o = r[0],
                        a = r[4],
                        s = r[8],
                        c = r[1],
                        l = r[5],
                        u = r[9],
                        h = r[2],
                        d = r[6],
                        p = r[10];
                    return (
                        "XYZ" === (t = t || this._order)
                            ? ((this._y = Math.asin(i(s, -1, 1))), Math.abs(s) < 0.9999999 ? ((this._x = Math.atan2(-u, p)), (this._z = Math.atan2(-a, o))) : ((this._x = Math.atan2(d, l)), (this._z = 0)))
                            : "YXZ" === t
                            ? ((this._x = Math.asin(-i(u, -1, 1))), Math.abs(u) < 0.9999999 ? ((this._y = Math.atan2(s, p)), (this._z = Math.atan2(c, l))) : ((this._y = Math.atan2(-h, o)), (this._z = 0)))
                            : "ZXY" === t
                            ? ((this._x = Math.asin(i(d, -1, 1))), Math.abs(d) < 0.9999999 ? ((this._y = Math.atan2(-h, p)), (this._z = Math.atan2(-a, l))) : ((this._y = 0), (this._z = Math.atan2(c, o))))
                            : "ZYX" === t
                            ? ((this._y = Math.asin(-i(h, -1, 1))), Math.abs(h) < 0.9999999 ? ((this._x = Math.atan2(d, p)), (this._z = Math.atan2(c, o))) : ((this._x = 0), (this._z = Math.atan2(-a, l))))
                            : "YZX" === t
                            ? ((this._z = Math.asin(i(c, -1, 1))), Math.abs(c) < 0.9999999 ? ((this._x = Math.atan2(-u, l)), (this._y = Math.atan2(-h, o))) : ((this._x = 0), (this._y = Math.atan2(s, p))))
                            : "XZY" === t
                            ? ((this._z = Math.asin(-i(a, -1, 1))), Math.abs(a) < 0.9999999 ? ((this._x = Math.atan2(d, l)), (this._y = Math.atan2(s, o))) : ((this._x = Math.atan2(-u, p)), (this._y = 0)))
                            : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + t),
                        (this._order = t),
                        !1 !== n && this._onChangeCallback(),
                        this
                    );
                },
                setFromQuaternion: function (e, t, n) {
                    return Vn.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Vn, t, n);
                },
                setFromVector3: function (e, t) {
                    return this.set(e.x, e.y, e.z, t || this._order);
                },
                reorder: function (e) {
                    return kn.setFromEuler(this), this.setFromQuaternion(kn, e);
                },
                equals: function (e) {
                    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
                },
                fromArray: function (e) {
                    return (this._x = e[0]), (this._y = e[1]), (this._z = e[2]), void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this;
                },
                toArray: function (e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), (e[t] = this._x), (e[t + 1] = this._y), (e[t + 2] = this._z), (e[t + 3] = this._order), e;
                },
                toVector3: function (e) {
                    return e ? e.set(this._x, this._y, this._z) : new Sn(this._x, this._y, this._z);
                },
                _onChange: function (e) {
                    return (this._onChangeCallback = e), this;
                },
                _onChangeCallback: function () {},
            }),
            Object.assign(Wn.prototype, {
                set: function (e) {
                    this.mask = (1 << e) | 0;
                },
                enable: function (e) {
                    this.mask |= (1 << e) | 0;
                },
                enableAll: function () {
                    this.mask = -1;
                },
                toggle: function (e) {
                    this.mask ^= (1 << e) | 0;
                },
                disable: function (e) {
                    this.mask &= ~((1 << e) | 0);
                },
                disableAll: function () {
                    this.mask = 0;
                },
                test: function (e) {
                    return 0 != (this.mask & e.mask);
                },
            });
        var qn = 0,
            Xn = new Sn(),
            Yn = new bn(),
            Jn = new Hn(),
            Zn = new Sn(),
            Kn = new Sn(),
            Qn = new Sn(),
            $n = new bn(),
            ei = new Sn(1, 0, 0),
            ti = new Sn(0, 1, 0),
            ni = new Sn(0, 0, 1),
            ii = { type: "added" },
            ri = { type: "removed" };
        function oi() {
            Object.defineProperty(this, "id", { value: qn++ }), (this.uuid = xn.generateUUID()), (this.name = ""), (this.type = "Object3D"), (this.parent = null), (this.children = []), (this.up = oi.DefaultUp.clone());
            var e = new Sn(),
                t = new jn(),
                n = new bn(),
                i = new Sn(1, 1, 1);
            t._onChange(function () {
                n.setFromEuler(t, !1);
            }),
                n._onChange(function () {
                    t.setFromQuaternion(n, void 0, !1);
                }),
                Object.defineProperties(this, {
                    position: { configurable: !0, enumerable: !0, value: e },
                    rotation: { configurable: !0, enumerable: !0, value: t },
                    quaternion: { configurable: !0, enumerable: !0, value: n },
                    scale: { configurable: !0, enumerable: !0, value: i },
                    modelViewMatrix: { value: new Hn() },
                    normalMatrix: { value: new An() },
                }),
                (this.matrix = new Hn()),
                (this.matrixWorld = new Hn()),
                (this.matrixAutoUpdate = oi.DefaultMatrixAutoUpdate),
                (this.matrixWorldNeedsUpdate = !1),
                (this.layers = new Wn()),
                (this.visible = !0),
                (this.castShadow = !1),
                (this.receiveShadow = !1),
                (this.frustumCulled = !0),
                (this.renderOrder = 0),
                (this.userData = {});
        }
        function ai() {
            oi.call(this),
                (this.type = "Scene"),
                (this.background = null),
                (this.fog = null),
                (this.overrideMaterial = null),
                (this.autoUpdate = !0),
                "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
        }
        (oi.DefaultUp = new Sn(0, 1, 0)),
            (oi.DefaultMatrixAutoUpdate = !0),
            (oi.prototype = Object.assign(Object.create(vn.prototype), {
                constructor: oi,
                isObject3D: !0,
                onBeforeRender: function () {},
                onAfterRender: function () {},
                applyMatrix: function (e) {
                    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
                },
                applyQuaternion: function (e) {
                    return this.quaternion.premultiply(e), this;
                },
                setRotationFromAxisAngle: function (e, t) {
                    this.quaternion.setFromAxisAngle(e, t);
                },
                setRotationFromEuler: function (e) {
                    this.quaternion.setFromEuler(e, !0);
                },
                setRotationFromMatrix: function (e) {
                    this.quaternion.setFromRotationMatrix(e);
                },
                setRotationFromQuaternion: function (e) {
                    this.quaternion.copy(e);
                },
                rotateOnAxis: function (e, t) {
                    return Yn.setFromAxisAngle(e, t), this.quaternion.multiply(Yn), this;
                },
                rotateOnWorldAxis: function (e, t) {
                    return Yn.setFromAxisAngle(e, t), this.quaternion.premultiply(Yn), this;
                },
                rotateX: function (e) {
                    return this.rotateOnAxis(ei, e);
                },
                rotateY: function (e) {
                    return this.rotateOnAxis(ti, e);
                },
                rotateZ: function (e) {
                    return this.rotateOnAxis(ni, e);
                },
                translateOnAxis: function (e, t) {
                    return Xn.copy(e).applyQuaternion(this.quaternion), this.position.add(Xn.multiplyScalar(t)), this;
                },
                translateX: function (e) {
                    return this.translateOnAxis(ei, e);
                },
                translateY: function (e) {
                    return this.translateOnAxis(ti, e);
                },
                translateZ: function (e) {
                    return this.translateOnAxis(ni, e);
                },
                localToWorld: function (e) {
                    return e.applyMatrix4(this.matrixWorld);
                },
                worldToLocal: function (e) {
                    return e.applyMatrix4(Jn.getInverse(this.matrixWorld));
                },
                lookAt: function (e, t, n) {
                    e.isVector3 ? Zn.copy(e) : Zn.set(e, t, n);
                    var i = this.parent;
                    this.updateWorldMatrix(!0, !1),
                        Kn.setFromMatrixPosition(this.matrixWorld),
                        this.isCamera || this.isLight ? Jn.lookAt(Kn, Zn, this.up) : Jn.lookAt(Zn, Kn, this.up),
                        this.quaternion.setFromRotationMatrix(Jn),
                        i && (Jn.extractRotation(i.matrixWorld), Yn.setFromRotationMatrix(Jn), this.quaternion.premultiply(Yn.inverse()));
                },
                add: function (e) {
                    if (arguments.length > 1) {
                        for (var t = 0; t < arguments.length; t++) this.add(arguments[t]);
                        return this;
                    }
                    return e === this
                        ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this)
                        : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), (e.parent = this), this.children.push(e), e.dispatchEvent(ii)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
                          this);
                },
                remove: function (e) {
                    if (arguments.length > 1) {
                        for (var t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                        return this;
                    }
                    var n = this.children.indexOf(e);
                    return -1 !== n && ((e.parent = null), this.children.splice(n, 1), e.dispatchEvent(ri)), this;
                },
                attach: function (e) {
                    return (
                        this.updateWorldMatrix(!0, !1),
                        Jn.getInverse(this.matrixWorld),
                        null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), Jn.multiply(e.parent.matrixWorld)),
                        e.applyMatrix(Jn),
                        e.updateWorldMatrix(!1, !1),
                        this.add(e),
                        this
                    );
                },
                getObjectById: function (e) {
                    return this.getObjectByProperty("id", e);
                },
                getObjectByName: function (e) {
                    return this.getObjectByProperty("name", e);
                },
                getObjectByProperty: function (e, t) {
                    if (this[e] === t) return this;
                    for (var n = 0, i = this.children.length; n < i; n++) {
                        var r = this.children[n].getObjectByProperty(e, t);
                        if (void 0 !== r) return r;
                    }
                },
                getWorldPosition: function (e) {
                    return void 0 === e && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), (e = new Sn())), this.updateMatrixWorld(!0), e.setFromMatrixPosition(this.matrixWorld);
                },
                getWorldQuaternion: function (e) {
                    return void 0 === e && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), (e = new bn())), this.updateMatrixWorld(!0), this.matrixWorld.decompose(Kn, e, Qn), e;
                },
                getWorldScale: function (e) {
                    return void 0 === e && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), (e = new Sn())), this.updateMatrixWorld(!0), this.matrixWorld.decompose(Kn, $n, e), e;
                },
                getWorldDirection: function (e) {
                    void 0 === e && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), (e = new Sn())), this.updateMatrixWorld(!0);
                    var t = this.matrixWorld.elements;
                    return e.set(t[8], t[9], t[10]).normalize();
                },
                raycast: function () {},
                traverse: function (e) {
                    e(this);
                    for (var t = this.children, n = 0, i = t.length; n < i; n++) t[n].traverse(e);
                },
                traverseVisible: function (e) {
                    if (!1 !== this.visible) {
                        e(this);
                        for (var t = this.children, n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e);
                    }
                },
                traverseAncestors: function (e) {
                    var t = this.parent;
                    null !== t && (e(t), t.traverseAncestors(e));
                },
                updateMatrix: function () {
                    this.matrix.compose(this.position, this.quaternion, this.scale), (this.matrixWorldNeedsUpdate = !0);
                },
                updateMatrixWorld: function (e) {
                    this.matrixAutoUpdate && this.updateMatrix(),
                        (this.matrixWorldNeedsUpdate || e) &&
                            (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), (this.matrixWorldNeedsUpdate = !1), (e = !0));
                    for (var t = this.children, n = 0, i = t.length; n < i; n++) t[n].updateMatrixWorld(e);
                },
                updateWorldMatrix: function (e, t) {
                    var n = this.parent;
                    if (
                        (!0 === e && null !== n && n.updateWorldMatrix(!0, !1),
                        this.matrixAutoUpdate && this.updateMatrix(),
                        null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                        !0 === t)
                    )
                        for (var i = this.children, r = 0, o = i.length; r < o; r++) i[r].updateWorldMatrix(!1, !0);
                },
                toJSON: function (e) {
                    var t = void 0 === e || "string" == typeof e,
                        n = {};
                    t && ((e = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {} }), (n.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" }));
                    var i = {};
                    function r(t, n) {
                        return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid;
                    }
                    if (
                        ((i.uuid = this.uuid),
                        (i.type = this.type),
                        "" !== this.name && (i.name = this.name),
                        !0 === this.castShadow && (i.castShadow = !0),
                        !0 === this.receiveShadow && (i.receiveShadow = !0),
                        !1 === this.visible && (i.visible = !1),
                        !1 === this.frustumCulled && (i.frustumCulled = !1),
                        0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
                        "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData),
                        (i.layers = this.layers.mask),
                        (i.matrix = this.matrix.toArray()),
                        !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
                        this.isMesh && this.drawMode !== Ct && (i.drawMode = this.drawMode),
                        this.isInstancedMesh && ((i.type = "InstancedMesh"), (i.count = this.count), (i.instanceMatrix = this.instanceMatrix.toJSON())),
                        this.isMesh || this.isLine || this.isPoints)
                    ) {
                        i.geometry = r(e.geometries, this.geometry);
                        var o = this.geometry.parameters;
                        if (void 0 !== o && void 0 !== o.shapes) {
                            var a = o.shapes;
                            if (Array.isArray(a))
                                for (var s = 0, c = a.length; s < c; s++) {
                                    var l = a[s];
                                    r(e.shapes, l);
                                }
                            else r(e.shapes, a);
                        }
                    }
                    if (void 0 !== this.material)
                        if (Array.isArray(this.material)) {
                            var u = [];
                            for (s = 0, c = this.material.length; s < c; s++) u.push(r(e.materials, this.material[s]));
                            i.material = u;
                        } else i.material = r(e.materials, this.material);
                    if (this.children.length > 0) {
                        i.children = [];
                        for (s = 0; s < this.children.length; s++) i.children.push(this.children[s].toJSON(e).object);
                    }
                    if (t) {
                        var h = m(e.geometries),
                            d = m(e.materials),
                            p = m(e.textures),
                            f = m(e.images);
                        a = m(e.shapes);
                        h.length > 0 && (n.geometries = h), d.length > 0 && (n.materials = d), p.length > 0 && (n.textures = p), f.length > 0 && (n.images = f), a.length > 0 && (n.shapes = a);
                    }
                    return (n.object = i), n;
                    function m(e) {
                        var t = [];
                        for (var n in e) {
                            var i = e[n];
                            delete i.metadata, t.push(i);
                        }
                        return t;
                    }
                },
                clone: function (e) {
                    return new this.constructor().copy(this, e);
                },
                copy: function (e, t) {
                    if (
                        (void 0 === t && (t = !0),
                        (this.name = e.name),
                        this.up.copy(e.up),
                        this.position.copy(e.position),
                        this.quaternion.copy(e.quaternion),
                        this.scale.copy(e.scale),
                        this.matrix.copy(e.matrix),
                        this.matrixWorld.copy(e.matrixWorld),
                        (this.matrixAutoUpdate = e.matrixAutoUpdate),
                        (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
                        (this.layers.mask = e.layers.mask),
                        (this.visible = e.visible),
                        (this.castShadow = e.castShadow),
                        (this.receiveShadow = e.receiveShadow),
                        (this.frustumCulled = e.frustumCulled),
                        (this.renderOrder = e.renderOrder),
                        (this.userData = JSON.parse(JSON.stringify(e.userData))),
                        !0 === t)
                    )
                        for (var n = 0; n < e.children.length; n++) {
                            var i = e.children[n];
                            this.add(i.clone());
                        }
                    return this;
                },
            })),
            (ai.prototype = Object.assign(Object.create(oi.prototype), {
                constructor: ai,
                isScene: !0,
                copy: function (e, t) {
                    return (
                        oi.prototype.copy.call(this, e, t),
                        null !== e.background && (this.background = e.background.clone()),
                        null !== e.fog && (this.fog = e.fog.clone()),
                        null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()),
                        (this.autoUpdate = e.autoUpdate),
                        (this.matrixAutoUpdate = e.matrixAutoUpdate),
                        this
                    );
                },
                toJSON: function (e) {
                    var t = oi.prototype.toJSON.call(this, e);
                    return null !== this.background && (t.object.background = this.background.toJSON(e)), null !== this.fog && (t.object.fog = this.fog.toJSON()), t;
                },
                dispose: function () {
                    this.dispatchEvent({ type: "dispose" });
                },
            }));
        var si = [new Sn(), new Sn(), new Sn(), new Sn(), new Sn(), new Sn(), new Sn(), new Sn()],
            ci = new Sn(),
            li = new _i(),
            ui = new Sn(),
            hi = new Sn(),
            di = new Sn(),
            pi = new Sn(),
            fi = new Sn(),
            mi = new Sn(),
            vi = new Sn(),
            gi = new Sn(),
            yi = new Sn(),
            xi = new Sn();
        function _i(e, t) {
            (this.min = void 0 !== e ? e : new Sn(1 / 0, 1 / 0, 1 / 0)), (this.max = void 0 !== t ? t : new Sn(-1 / 0, -1 / 0, -1 / 0));
        }
        function bi(e, t, n, i, r) {
            var o, a;
            for (o = 0, a = e.length - 3; o <= a; o += 3) {
                xi.fromArray(e, o);
                var s = r.x * Math.abs(xi.x) + r.y * Math.abs(xi.y) + r.z * Math.abs(xi.z),
                    c = t.dot(xi),
                    l = n.dot(xi),
                    u = i.dot(xi);
                if (Math.max(-Math.max(c, l, u), Math.min(c, l, u)) > s) return !1;
            }
            return !0;
        }
        Object.assign(_i.prototype, {
            isBox3: !0,
            set: function (e, t) {
                return this.min.copy(e), this.max.copy(t), this;
            },
            setFromArray: function (e) {
                for (var t = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, c = e.length; s < c; s += 3) {
                    var l = e[s],
                        u = e[s + 1],
                        h = e[s + 2];
                    l < t && (t = l), u < n && (n = u), h < i && (i = h), l > r && (r = l), u > o && (o = u), h > a && (a = h);
                }
                return this.min.set(t, n, i), this.max.set(r, o, a), this;
            },
            setFromBufferAttribute: function (e) {
                for (var t = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, c = e.count; s < c; s++) {
                    var l = e.getX(s),
                        u = e.getY(s),
                        h = e.getZ(s);
                    l < t && (t = l), u < n && (n = u), h < i && (i = h), l > r && (r = l), u > o && (o = u), h > a && (a = h);
                }
                return this.min.set(t, n, i), this.max.set(r, o, a), this;
            },
            setFromPoints: function (e) {
                this.makeEmpty();
                for (var t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
                return this;
            },
            setFromCenterAndSize: function (e, t) {
                var n = ci.copy(t).multiplyScalar(0.5);
                return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
            },
            setFromObject: function (e) {
                return this.makeEmpty(), this.expandByObject(e);
            },
            clone: function () {
                return new this.constructor().copy(this);
            },
            copy: function (e) {
                return this.min.copy(e.min), this.max.copy(e.max), this;
            },
            makeEmpty: function () {
                return (this.min.x = this.min.y = this.min.z = 1 / 0), (this.max.x = this.max.y = this.max.z = -1 / 0), this;
            },
            isEmpty: function () {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
            },
            getCenter: function (e) {
                return void 0 === e && (console.warn("THREE.Box3: .getCenter() target is now required"), (e = new Sn())), this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
            },
            getSize: function (e) {
                return void 0 === e && (console.warn("THREE.Box3: .getSize() target is now required"), (e = new Sn())), this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
            },
            expandByPoint: function (e) {
                return this.min.min(e), this.max.max(e), this;
            },
            expandByVector: function (e) {
                return this.min.sub(e), this.max.add(e), this;
            },
            expandByScalar: function (e) {
                return this.min.addScalar(-e), this.max.addScalar(e), this;
            },
            expandByObject: function (e) {
                e.updateWorldMatrix(!1, !1);
                var t = e.geometry;
                void 0 !== t && (null === t.boundingBox && t.computeBoundingBox(), li.copy(t.boundingBox), li.applyMatrix4(e.matrixWorld), this.expandByPoint(li.min), this.expandByPoint(li.max));
                for (var n = e.children, i = 0, r = n.length; i < r; i++) this.expandByObject(n[i]);
                return this;
            },
            containsPoint: function (e) {
                return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
            },
            containsBox: function (e) {
                return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
            },
            getParameter: function (e, t) {
                return (
                    void 0 === t && (console.warn("THREE.Box3: .getParameter() target is now required"), (t = new Sn())),
                    t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
                );
            },
            intersectsBox: function (e) {
                return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
            },
            intersectsSphere: function (e) {
                return this.clampPoint(e.center, ci), ci.distanceToSquared(e.center) <= e.radius * e.radius;
            },
            intersectsPlane: function (e) {
                var t, n;
                return (
                    e.normal.x > 0 ? ((t = e.normal.x * this.min.x), (n = e.normal.x * this.max.x)) : ((t = e.normal.x * this.max.x), (n = e.normal.x * this.min.x)),
                    e.normal.y > 0 ? ((t += e.normal.y * this.min.y), (n += e.normal.y * this.max.y)) : ((t += e.normal.y * this.max.y), (n += e.normal.y * this.min.y)),
                    e.normal.z > 0 ? ((t += e.normal.z * this.min.z), (n += e.normal.z * this.max.z)) : ((t += e.normal.z * this.max.z), (n += e.normal.z * this.min.z)),
                    t <= -e.constant && n >= -e.constant
                );
            },
            intersectsTriangle: function (e) {
                if (this.isEmpty()) return !1;
                this.getCenter(vi), gi.subVectors(this.max, vi), ui.subVectors(e.a, vi), hi.subVectors(e.b, vi), di.subVectors(e.c, vi), pi.subVectors(hi, ui), fi.subVectors(di, hi), mi.subVectors(ui, di);
                var t = [0, -pi.z, pi.y, 0, -fi.z, fi.y, 0, -mi.z, mi.y, pi.z, 0, -pi.x, fi.z, 0, -fi.x, mi.z, 0, -mi.x, -pi.y, pi.x, 0, -fi.y, fi.x, 0, -mi.y, mi.x, 0];
                return !!bi(t, ui, hi, di, gi) && !!bi((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), ui, hi, di, gi) && (yi.crossVectors(pi, fi), bi((t = [yi.x, yi.y, yi.z]), ui, hi, di, gi));
            },
            clampPoint: function (e, t) {
                return void 0 === t && (console.warn("THREE.Box3: .clampPoint() target is now required"), (t = new Sn())), t.copy(e).clamp(this.min, this.max);
            },
            distanceToPoint: function (e) {
                return ci.copy(e).clamp(this.min, this.max).sub(e).length();
            },
            getBoundingSphere: function (e) {
                return void 0 === e && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(e.center), (e.radius = 0.5 * this.getSize(ci).length()), e;
            },
            intersect: function (e) {
                return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
            },
            union: function (e) {
                return this.min.min(e.min), this.max.max(e.max), this;
            },
            applyMatrix4: function (e) {
                return this.isEmpty()
                    ? this
                    : (si[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
                      si[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
                      si[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
                      si[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
                      si[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
                      si[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
                      si[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
                      si[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
                      this.setFromPoints(si),
                      this);
            },
            translate: function (e) {
                return this.min.add(e), this.max.add(e), this;
            },
            equals: function (e) {
                return e.min.equals(this.min) && e.max.equals(this.max);
            },
        });
        var wi = new _i();
        function Mi(e, t) {
            (this.center = void 0 !== e ? e : new Sn()), (this.radius = void 0 !== t ? t : 0);
        }
        Object.assign(Mi.prototype, {
            set: function (e, t) {
                return this.center.copy(e), (this.radius = t), this;
            },
            setFromPoints: function (e, t) {
                var n = this.center;
                void 0 !== t ? n.copy(t) : wi.setFromPoints(e).getCenter(n);
                for (var i = 0, r = 0, o = e.length; r < o; r++) i = Math.max(i, n.distanceToSquared(e[r]));
                return (this.radius = Math.sqrt(i)), this;
            },
            clone: function () {
                return new this.constructor().copy(this);
            },
            copy: function (e) {
                return this.center.copy(e.center), (this.radius = e.radius), this;
            },
            empty: function () {
                return this.radius <= 0;
            },
            containsPoint: function (e) {
                return e.distanceToSquared(this.center) <= this.radius * this.radius;
            },
            distanceToPoint: function (e) {
                return e.distanceTo(this.center) - this.radius;
            },
            intersectsSphere: function (e) {
                var t = this.radius + e.radius;
                return e.center.distanceToSquared(this.center) <= t * t;
            },
            intersectsBox: function (e) {
                return e.intersectsSphere(this);
            },
            intersectsPlane: function (e) {
                return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
            },
            clampPoint: function (e, t) {
                var n = this.center.distanceToSquared(e);
                return (
                    void 0 === t && (console.warn("THREE.Sphere: .clampPoint() target is now required"), (t = new Sn())),
                    t.copy(e),
                    n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)),
                    t
                );
            },
            getBoundingBox: function (e) {
                return void 0 === e && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), (e = new _i())), e.set(this.center, this.center), e.expandByScalar(this.radius), e;
            },
            applyMatrix4: function (e) {
                return this.center.applyMatrix4(e), (this.radius = this.radius * e.getMaxScaleOnAxis()), this;
            },
            translate: function (e) {
                return this.center.add(e), this;
            },
            equals: function (e) {
                return e.center.equals(this.center) && e.radius === this.radius;
            },
        });
        var Si = new Sn(),
            Ei = new Sn(),
            Ti = new Sn(),
            Ai = new Sn(),
            Li = new Sn(),
            Ci = new Sn(),
            Ri = new Sn();
        function Pi(e, t) {
            (this.origin = void 0 !== e ? e : new Sn()), (this.direction = void 0 !== t ? t : new Sn(0, 0, -1));
        }
        Object.assign(Pi.prototype, {
            set: function (e, t) {
                return this.origin.copy(e), this.direction.copy(t), this;
            },
            clone: function () {
                return new this.constructor().copy(this);
            },
            copy: function (e) {
                return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
            },
            at: function (e, t) {
                return void 0 === t && (console.warn("THREE.Ray: .at() target is now required"), (t = new Sn())), t.copy(this.direction).multiplyScalar(e).add(this.origin);
            },
            lookAt: function (e) {
                return this.direction.copy(e).sub(this.origin).normalize(), this;
            },
            recast: function (e) {
                return this.origin.copy(this.at(e, Si)), this;
            },
            closestPointToPoint: function (e, t) {
                void 0 === t && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), (t = new Sn())), t.subVectors(e, this.origin);
                var n = t.dot(this.direction);
                return n < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(n).add(this.origin);
            },
            distanceToPoint: function (e) {
                return Math.sqrt(this.distanceSqToPoint(e));
            },
            distanceSqToPoint: function (e) {
                var t = Si.subVectors(e, this.origin).dot(this.direction);
                return t < 0 ? this.origin.distanceToSquared(e) : (Si.copy(this.direction).multiplyScalar(t).add(this.origin), Si.distanceToSquared(e));
            },
            distanceSqToSegment: function (e, t, n, i) {
                Ei.copy(e).add(t).multiplyScalar(0.5), Ti.copy(t).sub(e).normalize(), Ai.copy(this.origin).sub(Ei);
                var r,
                    o,
                    a,
                    s,
                    c = 0.5 * e.distanceTo(t),
                    l = -this.direction.dot(Ti),
                    u = Ai.dot(this.direction),
                    h = -Ai.dot(Ti),
                    d = Ai.lengthSq(),
                    p = Math.abs(1 - l * l);
                if (p > 0)
                    if (((o = l * u - h), (s = c * p), (r = l * h - u) >= 0))
                        if (o >= -s)
                            if (o <= s) {
                                var f = 1 / p;
                                a = (r *= f) * (r + l * (o *= f) + 2 * u) + o * (l * r + o + 2 * h) + d;
                            } else (o = c), (a = -(r = Math.max(0, -(l * o + u))) * r + o * (o + 2 * h) + d);
                        else (o = -c), (a = -(r = Math.max(0, -(l * o + u))) * r + o * (o + 2 * h) + d);
                    else
                        o <= -s
                            ? (a = -(r = Math.max(0, -(-l * c + u))) * r + (o = r > 0 ? -c : Math.min(Math.max(-c, -h), c)) * (o + 2 * h) + d)
                            : o <= s
                            ? ((r = 0), (a = (o = Math.min(Math.max(-c, -h), c)) * (o + 2 * h) + d))
                            : (a = -(r = Math.max(0, -(l * c + u))) * r + (o = r > 0 ? c : Math.min(Math.max(-c, -h), c)) * (o + 2 * h) + d);
                else (o = l > 0 ? -c : c), (a = -(r = Math.max(0, -(l * o + u))) * r + o * (o + 2 * h) + d);
                return n && n.copy(this.direction).multiplyScalar(r).add(this.origin), i && i.copy(Ti).multiplyScalar(o).add(Ei), a;
            },
            intersectSphere: function (e, t) {
                Si.subVectors(e.center, this.origin);
                var n = Si.dot(this.direction),
                    i = Si.dot(Si) - n * n,
                    r = e.radius * e.radius;
                if (i > r) return null;
                var o = Math.sqrt(r - i),
                    a = n - o,
                    s = n + o;
                return a < 0 && s < 0 ? null : a < 0 ? this.at(s, t) : this.at(a, t);
            },
            intersectsSphere: function (e) {
                return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
            },
            distanceToPlane: function (e) {
                var t = e.normal.dot(this.direction);
                if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
                var n = -(this.origin.dot(e.normal) + e.constant) / t;
                return n >= 0 ? n : null;
            },
            intersectPlane: function (e, t) {
                var n = this.distanceToPlane(e);
                return null === n ? null : this.at(n, t);
            },
            intersectsPlane: function (e) {
                var t = e.distanceToPoint(this.origin);
                return 0 === t || e.normal.dot(this.direction) * t < 0;
            },
            intersectBox: function (e, t) {
                var n,
                    i,
                    r,
                    o,
                    a,
                    s,
                    c = 1 / this.direction.x,
                    l = 1 / this.direction.y,
                    u = 1 / this.direction.z,
                    h = this.origin;
                return (
                    c >= 0 ? ((n = (e.min.x - h.x) * c), (i = (e.max.x - h.x) * c)) : ((n = (e.max.x - h.x) * c), (i = (e.min.x - h.x) * c)),
                    l >= 0 ? ((r = (e.min.y - h.y) * l), (o = (e.max.y - h.y) * l)) : ((r = (e.max.y - h.y) * l), (o = (e.min.y - h.y) * l)),
                    n > o || r > i
                        ? null
                        : ((r > n || n != n) && (n = r),
                          (o < i || i != i) && (i = o),
                          u >= 0 ? ((a = (e.min.z - h.z) * u), (s = (e.max.z - h.z) * u)) : ((a = (e.max.z - h.z) * u), (s = (e.min.z - h.z) * u)),
                          n > s || a > i ? null : ((a > n || n != n) && (n = a), (s < i || i != i) && (i = s), i < 0 ? null : this.at(n >= 0 ? n : i, t)))
                );
            },
            intersectsBox: function (e) {
                return null !== this.intersectBox(e, Si);
            },
            intersectTriangle: function (e, t, n, i, r) {
                Li.subVectors(t, e), Ci.subVectors(n, e), Ri.crossVectors(Li, Ci);
                var o,
                    a = this.direction.dot(Ri);
                if (a > 0) {
                    if (i) return null;
                    o = 1;
                } else {
                    if (!(a < 0)) return null;
                    (o = -1), (a = -a);
                }
                Ai.subVectors(this.origin, e);
                var s = o * this.direction.dot(Ci.crossVectors(Ai, Ci));
                if (s < 0) return null;
                var c = o * this.direction.dot(Li.cross(Ai));
                if (c < 0) return null;
                if (s + c > a) return null;
                var l = -o * Ai.dot(Ri);
                return l < 0 ? null : this.at(l / a, r);
            },
            applyMatrix4: function (e) {
                return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
            },
            equals: function (e) {
                return e.origin.equals(this.origin) && e.direction.equals(this.direction);
            },
        });
        var Oi = new Sn(),
            Di = new Sn(),
            Ii = new An();
        function Ni(e, t) {
            (this.normal = void 0 !== e ? e : new Sn(1, 0, 0)), (this.constant = void 0 !== t ? t : 0);
        }
        Object.assign(Ni.prototype, {
            isPlane: !0,
            set: function (e, t) {
                return this.normal.copy(e), (this.constant = t), this;
            },
            setComponents: function (e, t, n, i) {
                return this.normal.set(e, t, n), (this.constant = i), this;
            },
            setFromNormalAndCoplanarPoint: function (e, t) {
                return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
            },
            setFromCoplanarPoints: function (e, t, n) {
                var i = Oi.subVectors(n, t).cross(Di.subVectors(e, t)).normalize();
                return this.setFromNormalAndCoplanarPoint(i, e), this;
            },
            clone: function () {
                return new this.constructor().copy(this);
            },
            copy: function (e) {
                return this.normal.copy(e.normal), (this.constant = e.constant), this;
            },
            normalize: function () {
                var e = 1 / this.normal.length();
                return this.normal.multiplyScalar(e), (this.constant *= e), this;
            },
            negate: function () {
                return (this.constant *= -1), this.normal.negate(), this;
            },
            distanceToPoint: function (e) {
                return this.normal.dot(e) + this.constant;
            },
            distanceToSphere: function (e) {
                return this.distanceToPoint(e.center) - e.radius;
            },
            projectPoint: function (e, t) {
                return void 0 === t && (console.warn("THREE.Plane: .projectPoint() target is now required"), (t = new Sn())), t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e);
            },
            intersectLine: function (e, t) {
                void 0 === t && (console.warn("THREE.Plane: .intersectLine() target is now required"), (t = new Sn()));
                var n = e.delta(Oi),
                    i = this.normal.dot(n);
                if (0 === i) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : void 0;
                var r = -(e.start.dot(this.normal) + this.constant) / i;
                return r < 0 || r > 1 ? void 0 : t.copy(n).multiplyScalar(r).add(e.start);
            },
            intersectsLine: function (e) {
                var t = this.distanceToPoint(e.start),
                    n = this.distanceToPoint(e.end);
                return (t < 0 && n > 0) || (n < 0 && t > 0);
            },
            intersectsBox: function (e) {
                return e.intersectsPlane(this);
            },
            intersectsSphere: function (e) {
                return e.intersectsPlane(this);
            },
            coplanarPoint: function (e) {
                return void 0 === e && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), (e = new Sn())), e.copy(this.normal).multiplyScalar(-this.constant);
            },
            applyMatrix4: function (e, t) {
                var n = t || Ii.getNormalMatrix(e),
                    i = this.coplanarPoint(Oi).applyMatrix4(e),
                    r = this.normal.applyMatrix3(n).normalize();
                return (this.constant = -i.dot(r)), this;
            },
            translate: function (e) {
                return (this.constant -= e.dot(this.normal)), this;
            },
            equals: function (e) {
                return e.normal.equals(this.normal) && e.constant === this.constant;
            },
        });
        var Ui = new Sn(),
            Bi = new Sn(),
            zi = new Sn(),
            Fi = new Sn(),
            Gi = new Sn(),
            Hi = new Sn(),
            Vi = new Sn(),
            ki = new Sn(),
            ji = new Sn(),
            Wi = new Sn();
        function qi(e, t, n) {
            (this.a = void 0 !== e ? e : new Sn()), (this.b = void 0 !== t ? t : new Sn()), (this.c = void 0 !== n ? n : new Sn());
        }
        Object.assign(qi, {
            getNormal: function (e, t, n, i) {
                void 0 === i && (console.warn("THREE.Triangle: .getNormal() target is now required"), (i = new Sn())), i.subVectors(n, t), Ui.subVectors(e, t), i.cross(Ui);
                var r = i.lengthSq();
                return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
            },
            getBarycoord: function (e, t, n, i, r) {
                Ui.subVectors(i, t), Bi.subVectors(n, t), zi.subVectors(e, t);
                var o = Ui.dot(Ui),
                    a = Ui.dot(Bi),
                    s = Ui.dot(zi),
                    c = Bi.dot(Bi),
                    l = Bi.dot(zi),
                    u = o * c - a * a;
                if ((void 0 === r && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), (r = new Sn())), 0 === u)) return r.set(-2, -1, -1);
                var h = 1 / u,
                    d = (c * s - a * l) * h,
                    p = (o * l - a * s) * h;
                return r.set(1 - d - p, p, d);
            },
            containsPoint: function (e, t, n, i) {
                return qi.getBarycoord(e, t, n, i, Fi), Fi.x >= 0 && Fi.y >= 0 && Fi.x + Fi.y <= 1;
            },
            getUV: function (e, t, n, i, r, o, a, s) {
                return this.getBarycoord(e, t, n, i, Fi), s.set(0, 0), s.addScaledVector(r, Fi.x), s.addScaledVector(o, Fi.y), s.addScaledVector(a, Fi.z), s;
            },
            isFrontFacing: function (e, t, n, i) {
                return Ui.subVectors(n, t), Bi.subVectors(e, t), Ui.cross(Bi).dot(i) < 0;
            },
        }),
            Object.assign(qi.prototype, {
                set: function (e, t, n) {
                    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
                },
                setFromPointsAndIndices: function (e, t, n, i) {
                    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this;
                },
                clone: function () {
                    return new this.constructor().copy(this);
                },
                copy: function (e) {
                    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
                },
                getArea: function () {
                    return Ui.subVectors(this.c, this.b), Bi.subVectors(this.a, this.b), 0.5 * Ui.cross(Bi).length();
                },
                getMidpoint: function (e) {
                    return (
                        void 0 === e && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), (e = new Sn())),
                        e
                            .addVectors(this.a, this.b)
                            .add(this.c)
                            .multiplyScalar(1 / 3)
                    );
                },
                getNormal: function (e) {
                    return qi.getNormal(this.a, this.b, this.c, e);
                },
                getPlane: function (e) {
                    return void 0 === e && (console.warn("THREE.Triangle: .getPlane() target is now required"), (e = new Ni())), e.setFromCoplanarPoints(this.a, this.b, this.c);
                },
                getBarycoord: function (e, t) {
                    return qi.getBarycoord(e, this.a, this.b, this.c, t);
                },
                getUV: function (e, t, n, i, r) {
                    return qi.getUV(e, this.a, this.b, this.c, t, n, i, r);
                },
                containsPoint: function (e) {
                    return qi.containsPoint(e, this.a, this.b, this.c);
                },
                isFrontFacing: function (e) {
                    return qi.isFrontFacing(this.a, this.b, this.c, e);
                },
                intersectsBox: function (e) {
                    return e.intersectsTriangle(this);
                },
                closestPointToPoint: function (e, t) {
                    void 0 === t && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), (t = new Sn()));
                    var n,
                        i,
                        r = this.a,
                        o = this.b,
                        a = this.c;
                    Gi.subVectors(o, r), Hi.subVectors(a, r), ki.subVectors(e, r);
                    var s = Gi.dot(ki),
                        c = Hi.dot(ki);
                    if (s <= 0 && c <= 0) return t.copy(r);
                    ji.subVectors(e, o);
                    var l = Gi.dot(ji),
                        u = Hi.dot(ji);
                    if (l >= 0 && u <= l) return t.copy(o);
                    var h = s * u - l * c;
                    if (h <= 0 && s >= 0 && l <= 0) return (n = s / (s - l)), t.copy(r).addScaledVector(Gi, n);
                    Wi.subVectors(e, a);
                    var d = Gi.dot(Wi),
                        p = Hi.dot(Wi);
                    if (p >= 0 && d <= p) return t.copy(a);
                    var f = d * c - s * p;
                    if (f <= 0 && c >= 0 && p <= 0) return (i = c / (c - p)), t.copy(r).addScaledVector(Hi, i);
                    var m = l * p - d * u;
                    if (m <= 0 && u - l >= 0 && d - p >= 0) return Vi.subVectors(a, o), (i = (u - l) / (u - l + (d - p))), t.copy(o).addScaledVector(Vi, i);
                    var v = 1 / (m + f + h);
                    return (n = f * v), (i = h * v), t.copy(r).addScaledVector(Gi, n).addScaledVector(Hi, i);
                },
                equals: function (e) {
                    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
                },
            });
        var Xi = {
                aliceblue: 15792383,
                antiquewhite: 16444375,
                aqua: 65535,
                aquamarine: 8388564,
                azure: 15794175,
                beige: 16119260,
                bisque: 16770244,
                black: 0,
                blanchedalmond: 16772045,
                blue: 255,
                blueviolet: 9055202,
                brown: 10824234,
                burlywood: 14596231,
                cadetblue: 6266528,
                chartreuse: 8388352,
                chocolate: 13789470,
                coral: 16744272,
                cornflowerblue: 6591981,
                cornsilk: 16775388,
                crimson: 14423100,
                cyan: 65535,
                darkblue: 139,
                darkcyan: 35723,
                darkgoldenrod: 12092939,
                darkgray: 11119017,
                darkgreen: 25600,
                darkgrey: 11119017,
                darkkhaki: 12433259,
                darkmagenta: 9109643,
                darkolivegreen: 5597999,
                darkorange: 16747520,
                darkorchid: 10040012,
                darkred: 9109504,
                darksalmon: 15308410,
                darkseagreen: 9419919,
                darkslateblue: 4734347,
                darkslategray: 3100495,
                darkslategrey: 3100495,
                darkturquoise: 52945,
                darkviolet: 9699539,
                deeppink: 16716947,
                deepskyblue: 49151,
                dimgray: 6908265,
                dimgrey: 6908265,
                dodgerblue: 2003199,
                firebrick: 11674146,
                floralwhite: 16775920,
                forestgreen: 2263842,
                fuchsia: 16711935,
                gainsboro: 14474460,
                ghostwhite: 16316671,
                gold: 16766720,
                goldenrod: 14329120,
                gray: 8421504,
                green: 32768,
                greenyellow: 11403055,
                grey: 8421504,
                honeydew: 15794160,
                hotpink: 16738740,
                indianred: 13458524,
                indigo: 4915330,
                ivory: 16777200,
                khaki: 15787660,
                lavender: 15132410,
                lavenderblush: 16773365,
                lawngreen: 8190976,
                lemonchiffon: 16775885,
                lightblue: 11393254,
                lightcoral: 15761536,
                lightcyan: 14745599,
                lightgoldenrodyellow: 16448210,
                lightgray: 13882323,
                lightgreen: 9498256,
                lightgrey: 13882323,
                lightpink: 16758465,
                lightsalmon: 16752762,
                lightseagreen: 2142890,
                lightskyblue: 8900346,
                lightslategray: 7833753,
                lightslategrey: 7833753,
                lightsteelblue: 11584734,
                lightyellow: 16777184,
                lime: 65280,
                limegreen: 3329330,
                linen: 16445670,
                magenta: 16711935,
                maroon: 8388608,
                mediumaquamarine: 6737322,
                mediumblue: 205,
                mediumorchid: 12211667,
                mediumpurple: 9662683,
                mediumseagreen: 3978097,
                mediumslateblue: 8087790,
                mediumspringgreen: 64154,
                mediumturquoise: 4772300,
                mediumvioletred: 13047173,
                midnightblue: 1644912,
                mintcream: 16121850,
                mistyrose: 16770273,
                moccasin: 16770229,
                navajowhite: 16768685,
                navy: 128,
                oldlace: 16643558,
                olive: 8421376,
                olivedrab: 7048739,
                orange: 16753920,
                orangered: 16729344,
                orchid: 14315734,
                palegoldenrod: 15657130,
                palegreen: 10025880,
                paleturquoise: 11529966,
                palevioletred: 14381203,
                papayawhip: 16773077,
                peachpuff: 16767673,
                peru: 13468991,
                pink: 16761035,
                plum: 14524637,
                powderblue: 11591910,
                purple: 8388736,
                rebeccapurple: 6697881,
                red: 16711680,
                rosybrown: 12357519,
                royalblue: 4286945,
                saddlebrown: 9127187,
                salmon: 16416882,
                sandybrown: 16032864,
                seagreen: 3050327,
                seashell: 16774638,
                sienna: 10506797,
                silver: 12632256,
                skyblue: 8900331,
                slateblue: 6970061,
                slategray: 7372944,
                slategrey: 7372944,
                snow: 16775930,
                springgreen: 65407,
                steelblue: 4620980,
                tan: 13808780,
                teal: 32896,
                thistle: 14204888,
                tomato: 16737095,
                turquoise: 4251856,
                violet: 15631086,
                wheat: 16113331,
                white: 16777215,
                whitesmoke: 16119285,
                yellow: 16776960,
                yellowgreen: 10145074,
            },
            Yi = { h: 0, s: 0, l: 0 },
            Ji = { h: 0, s: 0, l: 0 };
        function Zi(e, t, n) {
            return void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n);
        }
        function Ki(e, t, n) {
            return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < 0.5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e;
        }
        function Qi(e) {
            return e < 0.04045 ? 0.0773993808 * e : Math.pow(0.9478672986 * e + 0.0521327014, 2.4);
        }
        function $i(e) {
            return e < 0.0031308 ? 12.92 * e : 1.055 * Math.pow(e, 0.41666) - 0.055;
        }
        function er(e, t, n, i, r, o) {
            (this.a = e),
                (this.b = t),
                (this.c = n),
                (this.normal = i && i.isVector3 ? i : new Sn()),
                (this.vertexNormals = Array.isArray(i) ? i : []),
                (this.color = r && r.isColor ? r : new Zi()),
                (this.vertexColors = Array.isArray(r) ? r : []),
                (this.materialIndex = void 0 !== o ? o : 0);
        }
        Object.assign(Zi.prototype, {
            isColor: !0,
            r: 1,
            g: 1,
            b: 1,
            set: function (e) {
                return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this;
            },
            setScalar: function (e) {
                return (this.r = e), (this.g = e), (this.b = e), this;
            },
            setHex: function (e) {
                return (e = Math.floor(e)), (this.r = ((e >> 16) & 255) / 255), (this.g = ((e >> 8) & 255) / 255), (this.b = (255 & e) / 255), this;
            },
            setRGB: function (e, t, n) {
                return (this.r = e), (this.g = t), (this.b = n), this;
            },
            setHSL: function (e, t, n) {
                if (((e = xn.euclideanModulo(e, 1)), (t = xn.clamp(t, 0, 1)), (n = xn.clamp(n, 0, 1)), 0 === t)) this.r = this.g = this.b = n;
                else {
                    var i = n <= 0.5 ? n * (1 + t) : n + t - n * t,
                        r = 2 * n - i;
                    (this.r = Ki(r, i, e + 1 / 3)), (this.g = Ki(r, i, e)), (this.b = Ki(r, i, e - 1 / 3));
                }
                return this;
            },
            setStyle: function (e) {
                function t(t) {
                    void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
                }
                var n;
                if ((n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e))) {
                    var i,
                        r = n[1],
                        o = n[2];
                    switch (r) {
                        case "rgb":
                        case "rgba":
                            if ((i = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)))
                                return (this.r = Math.min(255, parseInt(i[1], 10)) / 255), (this.g = Math.min(255, parseInt(i[2], 10)) / 255), (this.b = Math.min(255, parseInt(i[3], 10)) / 255), t(i[5]), this;
                            if ((i = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)))
                                return (this.r = Math.min(100, parseInt(i[1], 10)) / 100), (this.g = Math.min(100, parseInt(i[2], 10)) / 100), (this.b = Math.min(100, parseInt(i[3], 10)) / 100), t(i[5]), this;
                            break;
                        case "hsl":
                        case "hsla":
                            if ((i = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o))) {
                                var a = parseFloat(i[1]) / 360,
                                    s = parseInt(i[2], 10) / 100,
                                    c = parseInt(i[3], 10) / 100;
                                return t(i[5]), this.setHSL(a, s, c);
                            }
                    }
                } else if ((n = /^\#([A-Fa-f0-9]+)$/.exec(e))) {
                    var l = n[1],
                        u = l.length;
                    if (3 === u) return (this.r = parseInt(l.charAt(0) + l.charAt(0), 16) / 255), (this.g = parseInt(l.charAt(1) + l.charAt(1), 16) / 255), (this.b = parseInt(l.charAt(2) + l.charAt(2), 16) / 255), this;
                    if (6 === u) return (this.r = parseInt(l.charAt(0) + l.charAt(1), 16) / 255), (this.g = parseInt(l.charAt(2) + l.charAt(3), 16) / 255), (this.b = parseInt(l.charAt(4) + l.charAt(5), 16) / 255), this;
                }
                return e && e.length > 0 ? this.setColorName(e) : this;
            },
            setColorName: function (e) {
                var t = Xi[e];
                return void 0 !== t ? this.setHex(t) : console.warn("THREE.Color: Unknown color " + e), this;
            },
            clone: function () {
                return new this.constructor(this.r, this.g, this.b);
            },
            copy: function (e) {
                return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
            },
            copyGammaToLinear: function (e, t) {
                return void 0 === t && (t = 2), (this.r = Math.pow(e.r, t)), (this.g = Math.pow(e.g, t)), (this.b = Math.pow(e.b, t)), this;
            },
            copyLinearToGamma: function (e, t) {
                void 0 === t && (t = 2);
                var n = t > 0 ? 1 / t : 1;
                return (this.r = Math.pow(e.r, n)), (this.g = Math.pow(e.g, n)), (this.b = Math.pow(e.b, n)), this;
            },
            convertGammaToLinear: function (e) {
                return this.copyGammaToLinear(this, e), this;
            },
            convertLinearToGamma: function (e) {
                return this.copyLinearToGamma(this, e), this;
            },
            copySRGBToLinear: function (e) {
                return (this.r = Qi(e.r)), (this.g = Qi(e.g)), (this.b = Qi(e.b)), this;
            },
            copyLinearToSRGB: function (e) {
                return (this.r = $i(e.r)), (this.g = $i(e.g)), (this.b = $i(e.b)), this;
            },
            convertSRGBToLinear: function () {
                return this.copySRGBToLinear(this), this;
            },
            convertLinearToSRGB: function () {
                return this.copyLinearToSRGB(this), this;
            },
            getHex: function () {
                return ((255 * this.r) << 16) ^ ((255 * this.g) << 8) ^ ((255 * this.b) << 0);
            },
            getHexString: function () {
                return ("000000" + this.getHex().toString(16)).slice(-6);
            },
            getHSL: function (e) {
                void 0 === e && (console.warn("THREE.Color: .getHSL() target is now required"), (e = { h: 0, s: 0, l: 0 }));
                var t,
                    n,
                    i = this.r,
                    r = this.g,
                    o = this.b,
                    a = Math.max(i, r, o),
                    s = Math.min(i, r, o),
                    c = (s + a) / 2;
                if (s === a) (t = 0), (n = 0);
                else {
                    var l = a - s;
                    switch (((n = c <= 0.5 ? l / (a + s) : l / (2 - a - s)), a)) {
                        case i:
                            t = (r - o) / l + (r < o ? 6 : 0);
                            break;
                        case r:
                            t = (o - i) / l + 2;
                            break;
                        case o:
                            t = (i - r) / l + 4;
                    }
                    t /= 6;
                }
                return (e.h = t), (e.s = n), (e.l = c), e;
            },
            getStyle: function () {
                return "rgb(" + ((255 * this.r) | 0) + "," + ((255 * this.g) | 0) + "," + ((255 * this.b) | 0) + ")";
            },
            offsetHSL: function (e, t, n) {
                return this.getHSL(Yi), (Yi.h += e), (Yi.s += t), (Yi.l += n), this.setHSL(Yi.h, Yi.s, Yi.l), this;
            },
            add: function (e) {
                return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
            },
            addColors: function (e, t) {
                return (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this;
            },
            addScalar: function (e) {
                return (this.r += e), (this.g += e), (this.b += e), this;
            },
            sub: function (e) {
                return (this.r = Math.max(0, this.r - e.r)), (this.g = Math.max(0, this.g - e.g)), (this.b = Math.max(0, this.b - e.b)), this;
            },
            multiply: function (e) {
                return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
            },
            multiplyScalar: function (e) {
                return (this.r *= e), (this.g *= e), (this.b *= e), this;
            },
            lerp: function (e, t) {
                return (this.r += (e.r - this.r) * t), (this.g += (e.g - this.g) * t), (this.b += (e.b - this.b) * t), this;
            },
            lerpHSL: function (e, t) {
                this.getHSL(Yi), e.getHSL(Ji);
                var n = xn.lerp(Yi.h, Ji.h, t),
                    i = xn.lerp(Yi.s, Ji.s, t),
                    r = xn.lerp(Yi.l, Ji.l, t);
                return this.setHSL(n, i, r), this;
            },
            equals: function (e) {
                return e.r === this.r && e.g === this.g && e.b === this.b;
            },
            fromArray: function (e, t) {
                return void 0 === t && (t = 0), (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
            },
            toArray: function (e, t) {
                return void 0 === e && (e = []), void 0 === t && (t = 0), (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
            },
            toJSON: function () {
                return this.getHex();
            },
        }),
            (Zi.NAMES = Xi),
            Object.assign(er.prototype, {
                clone: function () {
                    return new this.constructor().copy(this);
                },
                copy: function (e) {
                    (this.a = e.a), (this.b = e.b), (this.c = e.c), this.normal.copy(e.normal), this.color.copy(e.color), (this.materialIndex = e.materialIndex);
                    for (var t = 0, n = e.vertexNormals.length; t < n; t++) this.vertexNormals[t] = e.vertexNormals[t].clone();
                    for (t = 0, n = e.vertexColors.length; t < n; t++) this.vertexColors[t] = e.vertexColors[t].clone();
                    return this;
                },
            });
        var tr = 0;
        function nr() {
            Object.defineProperty(this, "id", { value: tr++ }),
                (this.uuid = xn.generateUUID()),
                (this.name = ""),
                (this.type = "Material"),
                (this.fog = !0),
                (this.blending = E),
                (this.side = v),
                (this.flatShading = !1),
                (this.vertexTangents = !1),
                (this.vertexColors = b),
                (this.opacity = 1),
                (this.transparent = !1),
                (this.blendSrc = F),
                (this.blendDst = G),
                (this.blendEquation = R),
                (this.blendSrcAlpha = null),
                (this.blendDstAlpha = null),
                (this.blendEquationAlpha = null),
                (this.depthFunc = J),
                (this.depthTest = !0),
                (this.depthWrite = !0),
                (this.stencilWriteMask = 255),
                (this.stencilFunc = an),
                (this.stencilRef = 0),
                (this.stencilFuncMask = 255),
                (this.stencilFail = Wt),
                (this.stencilZFail = Wt),
                (this.stencilZPass = Wt),
                (this.stencilWrite = !1),
                (this.clippingPlanes = null),
                (this.clipIntersection = !1),
                (this.clipShadows = !1),
                (this.shadowSide = null),
                (this.colorWrite = !0),
                (this.precision = null),
                (this.polygonOffset = !1),
                (this.polygonOffsetFactor = 0),
                (this.polygonOffsetUnits = 0),
                (this.dithering = !1),
                (this.alphaTest = 0),
                (this.premultipliedAlpha = !1),
                (this.visible = !0),
                (this.toneMapped = !0),
                (this.userData = {}),
                (this.version = 0);
        }
        function ir(e) {
            nr.call(this),
                (this.type = "MeshBasicMaterial"),
                (this.color = new Zi(16777215)),
                (this.map = null),
                (this.lightMap = null),
                (this.lightMapIntensity = 1),
                (this.aoMap = null),
                (this.aoMapIntensity = 1),
                (this.specularMap = null),
                (this.alphaMap = null),
                (this.envMap = null),
                (this.combine = ee),
                (this.reflectivity = 1),
                (this.refractionRatio = 0.98),
                (this.wireframe = !1),
                (this.wireframeLinewidth = 1),
                (this.wireframeLinecap = "round"),
                (this.wireframeLinejoin = "round"),
                (this.skinning = !1),
                (this.morphTargets = !1),
                this.setValues(e);
        }
        function rr(e, t, n) {
            if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            (this.name = ""), (this.array = e), (this.itemSize = t), (this.count = void 0 !== e ? e.length / t : 0), (this.normalized = !0 === n), (this.usage = sn), (this.updateRange = { offset: 0, count: -1 }), (this.version = 0);
        }
        function or(e, t, n) {
            rr.call(this, new Int8Array(e), t, n);
        }
        function ar(e, t, n) {
            rr.call(this, new Uint8Array(e), t, n);
        }
        function sr(e, t, n) {
            rr.call(this, new Uint8ClampedArray(e), t, n);
        }
        function cr(e, t, n) {
            rr.call(this, new Int16Array(e), t, n);
        }
        function lr(e, t, n) {
            rr.call(this, new Uint16Array(e), t, n);
        }
        function ur(e, t, n) {
            rr.call(this, new Int32Array(e), t, n);
        }
        function hr(e, t, n) {
            rr.call(this, new Uint32Array(e), t, n);
        }
        function dr(e, t, n) {
            rr.call(this, new Float32Array(e), t, n);
        }
        function pr(e, t, n) {
            rr.call(this, new Float64Array(e), t, n);
        }
        function fr() {
            (this.vertices = []),
                (this.normals = []),
                (this.colors = []),
                (this.uvs = []),
                (this.uvs2 = []),
                (this.groups = []),
                (this.morphTargets = {}),
                (this.skinWeights = []),
                (this.skinIndices = []),
                (this.boundingBox = null),
                (this.boundingSphere = null),
                (this.verticesNeedUpdate = !1),
                (this.normalsNeedUpdate = !1),
                (this.colorsNeedUpdate = !1),
                (this.uvsNeedUpdate = !1),
                (this.groupsNeedUpdate = !1);
        }
        function mr(e) {
            if (0 === e.length) return -1 / 0;
            for (var t = e[0], n = 1, i = e.length; n < i; ++n) e[n] > t && (t = e[n]);
            return t;
        }
        (nr.prototype = Object.assign(Object.create(vn.prototype), {
            constructor: nr,
            isMaterial: !0,
            onBeforeCompile: function () {},
            setValues: function (e) {
                if (void 0 !== e)
                    for (var t in e) {
                        var n = e[t];
                        if (void 0 !== n)
                            if ("shading" !== t) {
                                var i = this[t];
                                void 0 !== i ? (i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : (this[t] = n)) : console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.");
                            } else console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), (this.flatShading = n === x);
                        else console.warn("THREE.Material: '" + t + "' parameter is undefined.");
                    }
            },
            toJSON: function (e) {
                var t = void 0 === e || "string" == typeof e;
                t && (e = { textures: {}, images: {} });
                var n = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } };
                function i(e) {
                    var t = [];
                    for (var n in e) {
                        var i = e[n];
                        delete i.metadata, t.push(i);
                    }
                    return t;
                }
                if (
                    ((n.uuid = this.uuid),
                    (n.type = this.type),
                    "" !== this.name && (n.name = this.name),
                    this.color && this.color.isColor && (n.color = this.color.getHex()),
                    void 0 !== this.roughness && (n.roughness = this.roughness),
                    void 0 !== this.metalness && (n.metalness = this.metalness),
                    this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()),
                    this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
                    this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity),
                    this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
                    void 0 !== this.shininess && (n.shininess = this.shininess),
                    void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
                    void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness),
                    this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid), (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
                    this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
                    this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid),
                    this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid),
                    this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid),
                    this.aoMap && this.aoMap.isTexture && ((n.aoMap = this.aoMap.toJSON(e).uuid), (n.aoMapIntensity = this.aoMapIntensity)),
                    this.bumpMap && this.bumpMap.isTexture && ((n.bumpMap = this.bumpMap.toJSON(e).uuid), (n.bumpScale = this.bumpScale)),
                    this.normalMap && this.normalMap.isTexture && ((n.normalMap = this.normalMap.toJSON(e).uuid), (n.normalMapType = this.normalMapType), (n.normalScale = this.normalScale.toArray())),
                    this.displacementMap && this.displacementMap.isTexture && ((n.displacementMap = this.displacementMap.toJSON(e).uuid), (n.displacementScale = this.displacementScale), (n.displacementBias = this.displacementBias)),
                    this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
                    this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
                    this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
                    this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid),
                    this.envMap &&
                        this.envMap.isTexture &&
                        ((n.envMap = this.envMap.toJSON(e).uuid),
                        (n.reflectivity = this.reflectivity),
                        (n.refractionRatio = this.refractionRatio),
                        void 0 !== this.combine && (n.combine = this.combine),
                        void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)),
                    this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid),
                    void 0 !== this.size && (n.size = this.size),
                    void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation),
                    this.blending !== E && (n.blending = this.blending),
                    !0 === this.flatShading && (n.flatShading = this.flatShading),
                    this.side !== v && (n.side = this.side),
                    this.vertexColors !== b && (n.vertexColors = this.vertexColors),
                    this.opacity < 1 && (n.opacity = this.opacity),
                    !0 === this.transparent && (n.transparent = this.transparent),
                    (n.depthFunc = this.depthFunc),
                    (n.depthTest = this.depthTest),
                    (n.depthWrite = this.depthWrite),
                    (n.stencilWrite = this.stencilWrite),
                    (n.stencilWriteMask = this.stencilWriteMask),
                    (n.stencilFunc = this.stencilFunc),
                    (n.stencilRef = this.stencilRef),
                    (n.stencilFuncMask = this.stencilFuncMask),
                    (n.stencilFail = this.stencilFail),
                    (n.stencilZFail = this.stencilZFail),
                    (n.stencilZPass = this.stencilZPass),
                    this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
                    !0 === this.polygonOffset && (n.polygonOffset = !0),
                    0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor),
                    0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits),
                    this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth),
                    void 0 !== this.dashSize && (n.dashSize = this.dashSize),
                    void 0 !== this.gapSize && (n.gapSize = this.gapSize),
                    void 0 !== this.scale && (n.scale = this.scale),
                    !0 === this.dithering && (n.dithering = !0),
                    this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
                    !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha),
                    !0 === this.wireframe && (n.wireframe = this.wireframe),
                    this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
                    "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap),
                    "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin),
                    !0 === this.morphTargets && (n.morphTargets = !0),
                    !0 === this.morphNormals && (n.morphNormals = !0),
                    !0 === this.skinning && (n.skinning = !0),
                    !1 === this.visible && (n.visible = !1),
                    !1 === this.toneMapped && (n.toneMapped = !1),
                    "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData),
                    t)
                ) {
                    var r = i(e.textures),
                        o = i(e.images);
                    r.length > 0 && (n.textures = r), o.length > 0 && (n.images = o);
                }
                return n;
            },
            clone: function () {
                return new this.constructor().copy(this);
            },
            copy: function (e) {
                (this.name = e.name),
                    (this.fog = e.fog),
                    (this.blending = e.blending),
                    (this.side = e.side),
                    (this.flatShading = e.flatShading),
                    (this.vertexTangents = e.vertexTangents),
                    (this.vertexColors = e.vertexColors),
                    (this.opacity = e.opacity),
                    (this.transparent = e.transparent),
                    (this.blendSrc = e.blendSrc),
                    (this.blendDst = e.blendDst),
                    (this.blendEquation = e.blendEquation),
                    (this.blendSrcAlpha = e.blendSrcAlpha),
                    (this.blendDstAlpha = e.blendDstAlpha),
                    (this.blendEquationAlpha = e.blendEquationAlpha),
                    (this.depthFunc = e.depthFunc),
                    (this.depthTest = e.depthTest),
                    (this.depthWrite = e.depthWrite),
                    (this.stencilWriteMask = e.stencilWriteMask),
                    (this.stencilFunc = e.stencilFunc),
                    (this.stencilRef = e.stencilRef),
                    (this.stencilFuncMask = e.stencilFuncMask),
                    (this.stencilFail = e.stencilFail),
                    (this.stencilZFail = e.stencilZFail),
                    (this.stencilZPass = e.stencilZPass),
                    (this.stencilWrite = e.stencilWrite);
                var t = e.clippingPlanes,
                    n = null;
                if (null !== t) {
                    var i = t.length;
                    n = new Array(i);
                    for (var r = 0; r !== i; ++r) n[r] = t[r].clone();
                }
                return (
                    (this.clippingPlanes = n),
                    (this.clipIntersection = e.clipIntersection),
                    (this.clipShadows = e.clipShadows),
                    (this.shadowSide = e.shadowSide),
                    (this.colorWrite = e.colorWrite),
                    (this.precision = e.precision),
                    (this.polygonOffset = e.polygonOffset),
                    (this.polygonOffsetFactor = e.polygonOffsetFactor),
                    (this.polygonOffsetUnits = e.polygonOffsetUnits),
                    (this.dithering = e.dithering),
                    (this.alphaTest = e.alphaTest),
                    (this.premultipliedAlpha = e.premultipliedAlpha),
                    (this.visible = e.visible),
                    (this.toneMapped = e.toneMapped),
                    (this.userData = JSON.parse(JSON.stringify(e.userData))),
                    this
                );
            },
            dispose: function () {
                this.dispatchEvent({ type: "dispose" });
            },
        })),
            Object.defineProperty(nr.prototype, "needsUpdate", {
                set: function (e) {
                    !0 === e && this.version++;
                },
            }),
            (ir.prototype = Object.create(nr.prototype)),
            (ir.prototype.constructor = ir),
            (ir.prototype.isMeshBasicMaterial = !0),
            (ir.prototype.copy = function (e) {
                return (
                    nr.prototype.copy.call(this, e),
                    this.color.copy(e.color),
                    (this.map = e.map),
                    (this.lightMap = e.lightMap),
                    (this.lightMapIntensity = e.lightMapIntensity),
                    (this.aoMap = e.aoMap),
                    (this.aoMapIntensity = e.aoMapIntensity),
                    (this.specularMap = e.specularMap),
                    (this.alphaMap = e.alphaMap),
                    (this.envMap = e.envMap),
                    (this.combine = e.combine),
                    (this.reflectivity = e.reflectivity),
                    (this.refractionRatio = e.refractionRatio),
                    (this.wireframe = e.wireframe),
                    (this.wireframeLinewidth = e.wireframeLinewidth),
                    (this.wireframeLinecap = e.wireframeLinecap),
                    (this.wireframeLinejoin = e.wireframeLinejoin),
                    (this.skinning = e.skinning),
                    (this.morphTargets = e.morphTargets),
                    this
                );
            }),
            Object.defineProperty(rr.prototype, "needsUpdate", {
                set: function (e) {
                    !0 === e && this.version++;
                },
            }),
            Object.assign(rr.prototype, {
                isBufferAttribute: !0,
                onUploadCallback: function () {},
                setUsage: function (e) {
                    return (this.usage = e), this;
                },
                copy: function (e) {
                    return (this.name = e.name), (this.array = new e.array.constructor(e.array)), (this.itemSize = e.itemSize), (this.count = e.count), (this.normalized = e.normalized), (this.usage = e.usage), this;
                },
                copyAt: function (e, t, n) {
                    (e *= this.itemSize), (n *= t.itemSize);
                    for (var i = 0, r = this.itemSize; i < r; i++) this.array[e + i] = t.array[n + i];
                    return this;
                },
                copyArray: function (e) {
                    return this.array.set(e), this;
                },
                copyColorsArray: function (e) {
                    for (var t = this.array, n = 0, i = 0, r = e.length; i < r; i++) {
                        var o = e[i];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), (o = new Zi())), (t[n++] = o.r), (t[n++] = o.g), (t[n++] = o.b);
                    }
                    return this;
                },
                copyVector2sArray: function (e) {
                    for (var t = this.array, n = 0, i = 0, r = e.length; i < r; i++) {
                        var o = e[i];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), (o = new _n())), (t[n++] = o.x), (t[n++] = o.y);
                    }
                    return this;
                },
                copyVector3sArray: function (e) {
                    for (var t = this.array, n = 0, i = 0, r = e.length; i < r; i++) {
                        var o = e[i];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), (o = new Sn())), (t[n++] = o.x), (t[n++] = o.y), (t[n++] = o.z);
                    }
                    return this;
                },
                copyVector4sArray: function (e) {
                    for (var t = this.array, n = 0, i = 0, r = e.length; i < r; i++) {
                        var o = e[i];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), (o = new Pn())), (t[n++] = o.x), (t[n++] = o.y), (t[n++] = o.z), (t[n++] = o.w);
                    }
                    return this;
                },
                set: function (e, t) {
                    return void 0 === t && (t = 0), this.array.set(e, t), this;
                },
                getX: function (e) {
                    return this.array[e * this.itemSize];
                },
                setX: function (e, t) {
                    return (this.array[e * this.itemSize] = t), this;
                },
                getY: function (e) {
                    return this.array[e * this.itemSize + 1];
                },
                setY: function (e, t) {
                    return (this.array[e * this.itemSize + 1] = t), this;
                },
                getZ: function (e) {
                    return this.array[e * this.itemSize + 2];
                },
                setZ: function (e, t) {
                    return (this.array[e * this.itemSize + 2] = t), this;
                },
                getW: function (e) {
                    return this.array[e * this.itemSize + 3];
                },
                setW: function (e, t) {
                    return (this.array[e * this.itemSize + 3] = t), this;
                },
                setXY: function (e, t, n) {
                    return (e *= this.itemSize), (this.array[e + 0] = t), (this.array[e + 1] = n), this;
                },
                setXYZ: function (e, t, n, i) {
                    return (e *= this.itemSize), (this.array[e + 0] = t), (this.array[e + 1] = n), (this.array[e + 2] = i), this;
                },
                setXYZW: function (e, t, n, i, r) {
                    return (e *= this.itemSize), (this.array[e + 0] = t), (this.array[e + 1] = n), (this.array[e + 2] = i), (this.array[e + 3] = r), this;
                },
                onUpload: function (e) {
                    return (this.onUploadCallback = e), this;
                },
                clone: function () {
                    return new this.constructor(this.array, this.itemSize).copy(this);
                },
                toJSON: function () {
                    return { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized };
                },
            }),
            (or.prototype = Object.create(rr.prototype)),
            (or.prototype.constructor = or),
            (ar.prototype = Object.create(rr.prototype)),
            (ar.prototype.constructor = ar),
            (sr.prototype = Object.create(rr.prototype)),
            (sr.prototype.constructor = sr),
            (cr.prototype = Object.create(rr.prototype)),
            (cr.prototype.constructor = cr),
            (lr.prototype = Object.create(rr.prototype)),
            (lr.prototype.constructor = lr),
            (ur.prototype = Object.create(rr.prototype)),
            (ur.prototype.constructor = ur),
            (hr.prototype = Object.create(rr.prototype)),
            (hr.prototype.constructor = hr),
            (dr.prototype = Object.create(rr.prototype)),
            (dr.prototype.constructor = dr),
            (pr.prototype = Object.create(rr.prototype)),
            (pr.prototype.constructor = pr),
            Object.assign(fr.prototype, {
                computeGroups: function (e) {
                    for (var t, n = [], i = void 0, r = e.faces, o = 0; o < r.length; o++) {
                        var a = r[o];
                        a.materialIndex !== i && ((i = a.materialIndex), void 0 !== t && ((t.count = 3 * o - t.start), n.push(t)), (t = { start: 3 * o, materialIndex: i }));
                    }
                    void 0 !== t && ((t.count = 3 * o - t.start), n.push(t)), (this.groups = n);
                },
                fromGeometry: function (e) {
                    var t,
                        n = e.faces,
                        i = e.vertices,
                        r = e.faceVertexUvs,
                        o = r[0] && r[0].length > 0,
                        a = r[1] && r[1].length > 0,
                        s = e.morphTargets,
                        c = s.length;
                    if (c > 0) {
                        t = [];
                        for (var l = 0; l < c; l++) t[l] = { name: s[l].name, data: [] };
                        this.morphTargets.position = t;
                    }
                    var u,
                        h = e.morphNormals,
                        d = h.length;
                    if (d > 0) {
                        u = [];
                        for (l = 0; l < d; l++) u[l] = { name: h[l].name, data: [] };
                        this.morphTargets.normal = u;
                    }
                    var p = e.skinIndices,
                        f = e.skinWeights,
                        m = p.length === i.length,
                        v = f.length === i.length;
                    i.length > 0 && 0 === n.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
                    for (l = 0; l < n.length; l++) {
                        var g = n[l];
                        this.vertices.push(i[g.a], i[g.b], i[g.c]);
                        var y = g.vertexNormals;
                        if (3 === y.length) this.normals.push(y[0], y[1], y[2]);
                        else {
                            var x = g.normal;
                            this.normals.push(x, x, x);
                        }
                        var _,
                            b = g.vertexColors;
                        if (3 === b.length) this.colors.push(b[0], b[1], b[2]);
                        else {
                            var w = g.color;
                            this.colors.push(w, w, w);
                        }
                        if (!0 === o) void 0 !== (_ = r[0][l]) ? this.uvs.push(_[0], _[1], _[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", l), this.uvs.push(new _n(), new _n(), new _n()));
                        if (!0 === a) void 0 !== (_ = r[1][l]) ? this.uvs2.push(_[0], _[1], _[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", l), this.uvs2.push(new _n(), new _n(), new _n()));
                        for (var M = 0; M < c; M++) {
                            var S = s[M].vertices;
                            t[M].data.push(S[g.a], S[g.b], S[g.c]);
                        }
                        for (M = 0; M < d; M++) {
                            var E = h[M].vertexNormals[l];
                            u[M].data.push(E.a, E.b, E.c);
                        }
                        m && this.skinIndices.push(p[g.a], p[g.b], p[g.c]), v && this.skinWeights.push(f[g.a], f[g.b], f[g.c]);
                    }
                    return (
                        this.computeGroups(e),
                        (this.verticesNeedUpdate = e.verticesNeedUpdate),
                        (this.normalsNeedUpdate = e.normalsNeedUpdate),
                        (this.colorsNeedUpdate = e.colorsNeedUpdate),
                        (this.uvsNeedUpdate = e.uvsNeedUpdate),
                        (this.groupsNeedUpdate = e.groupsNeedUpdate),
                        null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
                        null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()),
                        this
                    );
                },
            });
        var vr = 1,
            gr = new Hn(),
            yr = new oi(),
            xr = new Sn(),
            _r = new _i(),
            br = new _i(),
            wr = new Sn();
        function Mr() {
            Object.defineProperty(this, "id", { value: (vr += 2) }),
                (this.uuid = xn.generateUUID()),
                (this.name = ""),
                (this.type = "BufferGeometry"),
                (this.index = null),
                (this.attributes = {}),
                (this.morphAttributes = {}),
                (this.morphTargetsRelative = !1),
                (this.groups = []),
                (this.boundingBox = null),
                (this.boundingSphere = null),
                (this.drawRange = { start: 0, count: 1 / 0 }),
                (this.userData = {});
        }
        Mr.prototype = Object.assign(Object.create(vn.prototype), {
            constructor: Mr,
            isBufferGeometry: !0,
            getIndex: function () {
                return this.index;
            },
            setIndex: function (e) {
                Array.isArray(e) ? (this.index = new (mr(e) > 65535 ? hr : lr)(e, 1)) : (this.index = e);
            },
            getAttribute: function (e) {
                return this.attributes[e];
            },
            setAttribute: function (e, t) {
                return (this.attributes[e] = t), this;
            },
            deleteAttribute: function (e) {
                return delete this.attributes[e], this;
            },
            addGroup: function (e, t, n) {
                this.groups.push({ start: e, count: t, materialIndex: void 0 !== n ? n : 0 });
            },
            clearGroups: function () {
                this.groups = [];
            },
            setDrawRange: function (e, t) {
                (this.drawRange.start = e), (this.drawRange.count = t);
            },
            applyMatrix: function (e) {
                var t = this.attributes.position;
                void 0 !== t && (e.applyToBufferAttribute(t), (t.needsUpdate = !0));
                var n = this.attributes.normal;
                void 0 !== n && (new An().getNormalMatrix(e).applyToBufferAttribute(n), (n.needsUpdate = !0));
                var i = this.attributes.tangent;
                void 0 !== i && (new An().getNormalMatrix(e).applyToBufferAttribute(i), (i.needsUpdate = !0));
                return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this;
            },
            rotateX: function (e) {
                return gr.makeRotationX(e), this.applyMatrix(gr), this;
            },
            rotateY: function (e) {
                return gr.makeRotationY(e), this.applyMatrix(gr), this;
            },
            rotateZ: function (e) {
                return gr.makeRotationZ(e), this.applyMatrix(gr), this;
            },
            translate: function (e, t, n) {
                return gr.makeTranslation(e, t, n), this.applyMatrix(gr), this;
            },
            scale: function (e, t, n) {
                return gr.makeScale(e, t, n), this.applyMatrix(gr), this;
            },
            lookAt: function (e) {
                return yr.lookAt(e), yr.updateMatrix(), this.applyMatrix(yr.matrix), this;
            },
            center: function () {
                return this.computeBoundingBox(), this.boundingBox.getCenter(xr).negate(), this.translate(xr.x, xr.y, xr.z), this;
            },
            setFromObject: function (e) {
                var t = e.geometry;
                if (e.isPoints || e.isLine) {
                    var n = new dr(3 * t.vertices.length, 3),
                        i = new dr(3 * t.colors.length, 3);
                    if ((this.setAttribute("position", n.copyVector3sArray(t.vertices)), this.setAttribute("color", i.copyColorsArray(t.colors)), t.lineDistances && t.lineDistances.length === t.vertices.length)) {
                        var r = new dr(t.lineDistances.length, 1);
                        this.setAttribute("lineDistance", r.copyArray(t.lineDistances));
                    }
                    null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone());
                } else e.isMesh && t && t.isGeometry && this.fromGeometry(t);
                return this;
            },
            setFromPoints: function (e) {
                for (var t = [], n = 0, i = e.length; n < i; n++) {
                    var r = e[n];
                    t.push(r.x, r.y, r.z || 0);
                }
                return this.setAttribute("position", new dr(t, 3)), this;
            },
            updateFromObject: function (e) {
                var t,
                    n = e.geometry;
                if (e.isMesh) {
                    var i = n.__directGeometry;
                    if ((!0 === n.elementsNeedUpdate && ((i = void 0), (n.elementsNeedUpdate = !1)), void 0 === i)) return this.fromGeometry(n);
                    (i.verticesNeedUpdate = n.verticesNeedUpdate),
                        (i.normalsNeedUpdate = n.normalsNeedUpdate),
                        (i.colorsNeedUpdate = n.colorsNeedUpdate),
                        (i.uvsNeedUpdate = n.uvsNeedUpdate),
                        (i.groupsNeedUpdate = n.groupsNeedUpdate),
                        (n.verticesNeedUpdate = !1),
                        (n.normalsNeedUpdate = !1),
                        (n.colorsNeedUpdate = !1),
                        (n.uvsNeedUpdate = !1),
                        (n.groupsNeedUpdate = !1),
                        (n = i);
                }
                return (
                    !0 === n.verticesNeedUpdate && (void 0 !== (t = this.attributes.position) && (t.copyVector3sArray(n.vertices), (t.needsUpdate = !0)), (n.verticesNeedUpdate = !1)),
                    !0 === n.normalsNeedUpdate && (void 0 !== (t = this.attributes.normal) && (t.copyVector3sArray(n.normals), (t.needsUpdate = !0)), (n.normalsNeedUpdate = !1)),
                    !0 === n.colorsNeedUpdate && (void 0 !== (t = this.attributes.color) && (t.copyColorsArray(n.colors), (t.needsUpdate = !0)), (n.colorsNeedUpdate = !1)),
                    n.uvsNeedUpdate && (void 0 !== (t = this.attributes.uv) && (t.copyVector2sArray(n.uvs), (t.needsUpdate = !0)), (n.uvsNeedUpdate = !1)),
                    n.lineDistancesNeedUpdate && (void 0 !== (t = this.attributes.lineDistance) && (t.copyArray(n.lineDistances), (t.needsUpdate = !0)), (n.lineDistancesNeedUpdate = !1)),
                    n.groupsNeedUpdate && (n.computeGroups(e.geometry), (this.groups = n.groups), (n.groupsNeedUpdate = !1)),
                    this
                );
            },
            fromGeometry: function (e) {
                return (e.__directGeometry = new fr().fromGeometry(e)), this.fromDirectGeometry(e.__directGeometry);
            },
            fromDirectGeometry: function (e) {
                var t = new Float32Array(3 * e.vertices.length);
                if ((this.setAttribute("position", new rr(t, 3).copyVector3sArray(e.vertices)), e.normals.length > 0)) {
                    var n = new Float32Array(3 * e.normals.length);
                    this.setAttribute("normal", new rr(n, 3).copyVector3sArray(e.normals));
                }
                if (e.colors.length > 0) {
                    var i = new Float32Array(3 * e.colors.length);
                    this.setAttribute("color", new rr(i, 3).copyColorsArray(e.colors));
                }
                if (e.uvs.length > 0) {
                    var r = new Float32Array(2 * e.uvs.length);
                    this.setAttribute("uv", new rr(r, 2).copyVector2sArray(e.uvs));
                }
                if (e.uvs2.length > 0) {
                    var o = new Float32Array(2 * e.uvs2.length);
                    this.setAttribute("uv2", new rr(o, 2).copyVector2sArray(e.uvs2));
                }
                for (var a in ((this.groups = e.groups), e.morphTargets)) {
                    for (var s = [], c = e.morphTargets[a], l = 0, u = c.length; l < u; l++) {
                        var h = c[l],
                            d = new dr(3 * h.data.length, 3);
                        (d.name = h.name), s.push(d.copyVector3sArray(h.data));
                    }
                    this.morphAttributes[a] = s;
                }
                if (e.skinIndices.length > 0) {
                    var p = new dr(4 * e.skinIndices.length, 4);
                    this.setAttribute("skinIndex", p.copyVector4sArray(e.skinIndices));
                }
                if (e.skinWeights.length > 0) {
                    var f = new dr(4 * e.skinWeights.length, 4);
                    this.setAttribute("skinWeight", f.copyVector4sArray(e.skinWeights));
                }
                return null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), this;
            },
            computeBoundingBox: function () {
                null === this.boundingBox && (this.boundingBox = new _i());
                var e = this.attributes.position,
                    t = this.morphAttributes.position;
                if (void 0 !== e) {
                    if ((this.boundingBox.setFromBufferAttribute(e), t))
                        for (var n = 0, i = t.length; n < i; n++) {
                            var r = t[n];
                            _r.setFromBufferAttribute(r),
                                this.morphTargetsRelative
                                    ? (wr.addVectors(this.boundingBox.min, _r.min), this.boundingBox.expandByPoint(wr), wr.addVectors(this.boundingBox.max, _r.max), this.boundingBox.expandByPoint(wr))
                                    : (this.boundingBox.expandByPoint(_r.min), this.boundingBox.expandByPoint(_r.max));
                        }
                } else this.boundingBox.makeEmpty();
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) &&
                    console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
            },
            computeBoundingSphere: function () {
                null === this.boundingSphere && (this.boundingSphere = new Mi());
                var e = this.attributes.position,
                    t = this.morphAttributes.position;
                if (e) {
                    var n = this.boundingSphere.center;
                    if ((_r.setFromBufferAttribute(e), t))
                        for (var i = 0, r = t.length; i < r; i++) {
                            var o = t[i];
                            br.setFromBufferAttribute(o),
                                this.morphTargetsRelative ? (wr.addVectors(_r.min, br.min), _r.expandByPoint(wr), wr.addVectors(_r.max, br.max), _r.expandByPoint(wr)) : (_r.expandByPoint(br.min), _r.expandByPoint(br.max));
                        }
                    _r.getCenter(n);
                    var a = 0;
                    for (i = 0, r = e.count; i < r; i++) wr.fromBufferAttribute(e, i), (a = Math.max(a, n.distanceToSquared(wr)));
                    if (t)
                        for (i = 0, r = t.length; i < r; i++) {
                            o = t[i];
                            for (var s = this.morphTargetsRelative, c = 0, l = o.count; c < l; c++) wr.fromBufferAttribute(o, c), s && (xr.fromBufferAttribute(e, c), wr.add(xr)), (a = Math.max(a, n.distanceToSquared(wr)));
                        }
                    (this.boundingSphere.radius = Math.sqrt(a)),
                        isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
                }
            },
            computeFaceNormals: function () {},
            computeVertexNormals: function () {
                var e = this.index,
                    t = this.attributes;
                if (t.position) {
                    var n = t.position.array;
                    if (void 0 === t.normal) this.setAttribute("normal", new rr(new Float32Array(n.length), 3));
                    else for (var i = t.normal.array, r = 0, o = i.length; r < o; r++) i[r] = 0;
                    var a,
                        s,
                        c,
                        l = t.normal.array,
                        u = new Sn(),
                        h = new Sn(),
                        d = new Sn(),
                        p = new Sn(),
                        f = new Sn();
                    if (e) {
                        var m = e.array;
                        for (r = 0, o = e.count; r < o; r += 3)
                            (a = 3 * m[r + 0]),
                                (s = 3 * m[r + 1]),
                                (c = 3 * m[r + 2]),
                                u.fromArray(n, a),
                                h.fromArray(n, s),
                                d.fromArray(n, c),
                                p.subVectors(d, h),
                                f.subVectors(u, h),
                                p.cross(f),
                                (l[a] += p.x),
                                (l[a + 1] += p.y),
                                (l[a + 2] += p.z),
                                (l[s] += p.x),
                                (l[s + 1] += p.y),
                                (l[s + 2] += p.z),
                                (l[c] += p.x),
                                (l[c + 1] += p.y),
                                (l[c + 2] += p.z);
                    } else
                        for (r = 0, o = n.length; r < o; r += 9)
                            u.fromArray(n, r),
                                h.fromArray(n, r + 3),
                                d.fromArray(n, r + 6),
                                p.subVectors(d, h),
                                f.subVectors(u, h),
                                p.cross(f),
                                (l[r] = p.x),
                                (l[r + 1] = p.y),
                                (l[r + 2] = p.z),
                                (l[r + 3] = p.x),
                                (l[r + 4] = p.y),
                                (l[r + 5] = p.z),
                                (l[r + 6] = p.x),
                                (l[r + 7] = p.y),
                                (l[r + 8] = p.z);
                    this.normalizeNormals(), (t.normal.needsUpdate = !0);
                }
            },
            merge: function (e, t) {
                if (e && e.isBufferGeometry) {
                    void 0 === t && ((t = 0), console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                    var n = this.attributes;
                    for (var i in n) if (void 0 !== e.attributes[i]) for (var r = n[i].array, o = e.attributes[i], a = o.array, s = o.itemSize * t, c = Math.min(a.length, r.length - s), l = 0, u = s; l < c; l++, u++) r[u] = a[l];
                    return this;
                }
                console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e);
            },
            normalizeNormals: function () {
                for (var e = this.attributes.normal, t = 0, n = e.count; t < n; t++) (wr.x = e.getX(t)), (wr.y = e.getY(t)), (wr.z = e.getZ(t)), wr.normalize(), e.setXYZ(t, wr.x, wr.y, wr.z);
            },
            toNonIndexed: function () {
                function e(e, t) {
                    for (var n = e.array, i = e.itemSize, r = new n.constructor(t.length * i), o = 0, a = 0, s = 0, c = t.length; s < c; s++) {
                        o = t[s] * i;
                        for (var l = 0; l < i; l++) r[a++] = n[o++];
                    }
                    return new rr(r, i);
                }
                if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
                var t = new Mr(),
                    n = this.index.array,
                    i = this.attributes;
                for (var r in i) {
                    var o = e(i[r], n);
                    t.setAttribute(r, o);
                }
                var a = this.morphAttributes;
                for (r in a) {
                    for (var s = [], c = a[r], l = 0, u = c.length; l < u; l++) {
                        o = e(c[l], n);
                        s.push(o);
                    }
                    t.morphAttributes[r] = s;
                }
                t.morphTargetsRelative = this.morphTargetsRelative;
                for (var h = this.groups, d = ((l = 0), h.length); l < d; l++) {
                    var p = h[l];
                    t.addGroup(p.start, p.count, p.materialIndex);
                }
                return t;
            },
            toJSON: function () {
                var e = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
                if (((e.uuid = this.uuid), (e.type = this.type), "" !== this.name && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), void 0 !== this.parameters)) {
                    var t = this.parameters;
                    for (var n in t) void 0 !== t[n] && (e[n] = t[n]);
                    return e;
                }
                e.data = { attributes: {} };
                var i = this.index;
                null !== i && (e.data.index = { type: i.array.constructor.name, array: Array.prototype.slice.call(i.array) });
                var r = this.attributes;
                for (var n in r) {
                    var o = (d = r[n]).toJSON();
                    "" !== d.name && (o.name = d.name), (e.data.attributes[n] = o);
                }
                var a = {},
                    s = !1;
                for (var n in this.morphAttributes) {
                    for (var c = this.morphAttributes[n], l = [], u = 0, h = c.length; u < h; u++) {
                        var d;
                        o = (d = c[u]).toJSON();
                        "" !== d.name && (o.name = d.name), l.push(o);
                    }
                    l.length > 0 && ((a[n] = l), (s = !0));
                }
                s && ((e.data.morphAttributes = a), (e.data.morphTargetsRelative = this.morphTargetsRelative));
                var p = this.groups;
                p.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(p)));
                var f = this.boundingSphere;
                return null !== f && (e.data.boundingSphere = { center: f.center.toArray(), radius: f.radius }), e;
            },
            clone: function () {
                return new Mr().copy(this);
            },
            copy: function (e) {
                var t, n, i;
                (this.index = null), (this.attributes = {}), (this.morphAttributes = {}), (this.groups = []), (this.boundingBox = null), (this.boundingSphere = null), (this.name = e.name);
                var r = e.index;
                null !== r && this.setIndex(r.clone());
                var o = e.attributes;
                for (t in o) {
                    var a = o[t];
                    this.setAttribute(t, a.clone());
                }
                var s = e.morphAttributes;
                for (t in s) {
                    var c = [],
                        l = s[t];
                    for (n = 0, i = l.length; n < i; n++) c.push(l[n].clone());
                    this.morphAttributes[t] = c;
                }
                this.morphTargetsRelative = e.morphTargetsRelative;
                var u = e.groups;
                for (n = 0, i = u.length; n < i; n++) {
                    var h = u[n];
                    this.addGroup(h.start, h.count, h.materialIndex);
                }
                var d = e.boundingBox;
                null !== d && (this.boundingBox = d.clone());
                var p = e.boundingSphere;
                return null !== p && (this.boundingSphere = p.clone()), (this.drawRange.start = e.drawRange.start), (this.drawRange.count = e.drawRange.count), (this.userData = e.userData), this;
            },
            dispose: function () {
                this.dispatchEvent({ type: "dispose" });
            },
        });
        var Sr = new Hn(),
            Er = new Pi(),
            Tr = new Mi(),
            Ar = new Sn(),
            Lr = new Sn(),
            Cr = new Sn(),
            Rr = new Sn(),
            Pr = new Sn(),
            Or = new Sn(),
            Dr = new Sn(),
            Ir = new Sn(),
            Nr = new Sn(),
            Ur = new _n(),
            Br = new _n(),
            zr = new _n(),
            Fr = new Sn(),
            Gr = new Sn();
        function Hr(e, t) {
            oi.call(this), (this.type = "Mesh"), (this.geometry = void 0 !== e ? e : new Mr()), (this.material = void 0 !== t ? t : new ir({ color: 16777215 * Math.random() })), (this.drawMode = Ct), this.updateMorphTargets();
        }
        function Vr(e, t, n, i, r, o, a, s) {
            if (null === (t.side === g ? i.intersectTriangle(a, o, r, !0, s) : i.intersectTriangle(r, o, a, t.side !== y, s))) return null;
            Gr.copy(s), Gr.applyMatrix4(e.matrixWorld);
            var c = n.ray.origin.distanceTo(Gr);
            return c < n.near || c > n.far ? null : { distance: c, point: Gr.clone(), object: e };
        }
        function kr(e, t, n, i, r, o, a, s, c, l, u, h) {
            Ar.fromBufferAttribute(r, l), Lr.fromBufferAttribute(r, u), Cr.fromBufferAttribute(r, h);
            var d = e.morphTargetInfluences;
            if (t.morphTargets && o && d) {
                Dr.set(0, 0, 0), Ir.set(0, 0, 0), Nr.set(0, 0, 0);
                for (var p = 0, f = o.length; p < f; p++) {
                    var m = d[p],
                        v = o[p];
                    0 !== m &&
                        (Rr.fromBufferAttribute(v, l),
                        Pr.fromBufferAttribute(v, u),
                        Or.fromBufferAttribute(v, h),
                        a ? (Dr.addScaledVector(Rr, m), Ir.addScaledVector(Pr, m), Nr.addScaledVector(Or, m)) : (Dr.addScaledVector(Rr.sub(Ar), m), Ir.addScaledVector(Pr.sub(Lr), m), Nr.addScaledVector(Or.sub(Cr), m)));
                }
                Ar.add(Dr), Lr.add(Ir), Cr.add(Nr);
            }
            var g = Vr(e, t, n, i, Ar, Lr, Cr, Fr);
            if (g) {
                s && (Ur.fromBufferAttribute(s, l), Br.fromBufferAttribute(s, u), zr.fromBufferAttribute(s, h), (g.uv = qi.getUV(Fr, Ar, Lr, Cr, Ur, Br, zr, new _n()))),
                    c && (Ur.fromBufferAttribute(c, l), Br.fromBufferAttribute(c, u), zr.fromBufferAttribute(c, h), (g.uv2 = qi.getUV(Fr, Ar, Lr, Cr, Ur, Br, zr, new _n())));
                var y = new er(l, u, h);
                qi.getNormal(Ar, Lr, Cr, y.normal), (g.face = y);
            }
            return g;
        }
        Hr.prototype = Object.assign(Object.create(oi.prototype), {
            constructor: Hr,
            isMesh: !0,
            setDrawMode: function (e) {
                this.drawMode = e;
            },
            copy: function (e) {
                return (
                    oi.prototype.copy.call(this, e),
                    (this.drawMode = e.drawMode),
                    void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
                    void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
                    this
                );
            },
            updateMorphTargets: function () {
                var e,
                    t,
                    n,
                    i = this.geometry;
                if (i.isBufferGeometry) {
                    var r = i.morphAttributes,
                        o = Object.keys(r);
                    if (o.length > 0) {
                        var a = r[o[0]];
                        if (void 0 !== a)
                            for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, e = 0, t = a.length; e < t; e++) (n = a[e].name || String(e)), this.morphTargetInfluences.push(0), (this.morphTargetDictionary[n] = e);
                    }
                } else {
                    var s = i.morphTargets;
                    void 0 !== s && s.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                }
            },
            raycast: function (e, t) {
                var n,
                    i = this.geometry,
                    r = this.material,
                    o = this.matrixWorld;
                if (
                    void 0 !== r &&
                    (null === i.boundingSphere && i.computeBoundingSphere(),
                    Tr.copy(i.boundingSphere),
                    Tr.applyMatrix4(o),
                    !1 !== e.ray.intersectsSphere(Tr) && (Sr.getInverse(o), Er.copy(e.ray).applyMatrix4(Sr), null === i.boundingBox || !1 !== Er.intersectsBox(i.boundingBox)))
                )
                    if (this.drawMode === Ct) {
                        if (i.isBufferGeometry) {
                            var a,
                                s,
                                c,
                                l,
                                u,
                                h,
                                d,
                                p,
                                f,
                                m = i.index,
                                v = i.attributes.position,
                                g = i.morphAttributes.position,
                                y = i.morphTargetsRelative,
                                x = i.attributes.uv,
                                _ = i.attributes.uv2,
                                b = i.groups,
                                w = i.drawRange;
                            if (null !== m)
                                if (Array.isArray(r))
                                    for (l = 0, h = b.length; l < h; l++)
                                        for (f = r[(p = b[l]).materialIndex], u = Math.max(p.start, w.start), d = Math.min(p.start + p.count, w.start + w.count); u < d; u += 3)
                                            (a = m.getX(u)),
                                                (s = m.getX(u + 1)),
                                                (c = m.getX(u + 2)),
                                                (n = kr(this, f, e, Er, v, g, y, x, _, a, s, c)) && ((n.faceIndex = Math.floor(u / 3)), (n.face.materialIndex = p.materialIndex), t.push(n));
                                else
                                    for (l = Math.max(0, w.start), h = Math.min(m.count, w.start + w.count); l < h; l += 3)
                                        (a = m.getX(l)), (s = m.getX(l + 1)), (c = m.getX(l + 2)), (n = kr(this, r, e, Er, v, g, y, x, _, a, s, c)) && ((n.faceIndex = Math.floor(l / 3)), t.push(n));
                            else if (void 0 !== v)
                                if (Array.isArray(r))
                                    for (l = 0, h = b.length; l < h; l++)
                                        for (f = r[(p = b[l]).materialIndex], u = Math.max(p.start, w.start), d = Math.min(p.start + p.count, w.start + w.count); u < d; u += 3)
                                            (n = kr(this, f, e, Er, v, g, y, x, _, (a = u), (s = u + 1), (c = u + 2))) && ((n.faceIndex = Math.floor(u / 3)), (n.face.materialIndex = p.materialIndex), t.push(n));
                                else
                                    for (l = Math.max(0, w.start), h = Math.min(v.count, w.start + w.count); l < h; l += 3)
                                        (n = kr(this, r, e, Er, v, g, y, x, _, (a = l), (s = l + 1), (c = l + 2))) && ((n.faceIndex = Math.floor(l / 3)), t.push(n));
                        } else if (i.isGeometry) {
                            var M,
                                S,
                                E,
                                T,
                                A = Array.isArray(r),
                                L = i.vertices,
                                C = i.faces,
                                R = i.faceVertexUvs[0];
                            R.length > 0 && (T = R);
                            for (var P = 0, O = C.length; P < O; P++) {
                                var D = C[P],
                                    I = A ? r[D.materialIndex] : r;
                                if (void 0 !== I && ((M = L[D.a]), (S = L[D.b]), (E = L[D.c]), (n = Vr(this, I, e, Er, M, S, E, Fr)))) {
                                    if (T && T[P]) {
                                        var N = T[P];
                                        Ur.copy(N[0]), Br.copy(N[1]), zr.copy(N[2]), (n.uv = qi.getUV(Fr, M, S, E, Ur, Br, zr, new _n()));
                                    }
                                    (n.face = D), (n.faceIndex = P), t.push(n);
                                }
                            }
                        }
                    } else console.warn("THREE.Mesh: TriangleStripDrawMode and TriangleFanDrawMode are not supported by .raycast().");
            },
            clone: function () {
                return new this.constructor(this.geometry, this.material).copy(this);
            },
        });
        var jr = 0,
            Wr = new Hn(),
            qr = new oi(),
            Xr = new Sn();
        function Yr() {
            Object.defineProperty(this, "id", { value: (jr += 2) }),
                (this.uuid = xn.generateUUID()),
                (this.name = ""),
                (this.type = "Geometry"),
                (this.vertices = []),
                (this.colors = []),
                (this.faces = []),
                (this.faceVertexUvs = [[]]),
                (this.morphTargets = []),
                (this.morphNormals = []),
                (this.skinWeights = []),
                (this.skinIndices = []),
                (this.lineDistances = []),
                (this.boundingBox = null),
                (this.boundingSphere = null),
                (this.elementsNeedUpdate = !1),
                (this.verticesNeedUpdate = !1),
                (this.uvsNeedUpdate = !1),
                (this.normalsNeedUpdate = !1),
                (this.colorsNeedUpdate = !1),
                (this.lineDistancesNeedUpdate = !1),
                (this.groupsNeedUpdate = !1);
        }
        Yr.prototype = Object.assign(Object.create(vn.prototype), {
            constructor: Yr,
            isGeometry: !0,
            applyMatrix: function (e) {
                for (var t = new An().getNormalMatrix(e), n = 0, i = this.vertices.length; n < i; n++) {
                    this.vertices[n].applyMatrix4(e);
                }
                for (n = 0, i = this.faces.length; n < i; n++) {
                    var r = this.faces[n];
                    r.normal.applyMatrix3(t).normalize();
                    for (var o = 0, a = r.vertexNormals.length; o < a; o++) r.vertexNormals[o].applyMatrix3(t).normalize();
                }
                return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), (this.verticesNeedUpdate = !0), (this.normalsNeedUpdate = !0), this;
            },
            rotateX: function (e) {
                return Wr.makeRotationX(e), this.applyMatrix(Wr), this;
            },
            rotateY: function (e) {
                return Wr.makeRotationY(e), this.applyMatrix(Wr), this;
            },
            rotateZ: function (e) {
                return Wr.makeRotationZ(e), this.applyMatrix(Wr), this;
            },
            translate: function (e, t, n) {
                return Wr.makeTranslation(e, t, n), this.applyMatrix(Wr), this;
            },
            scale: function (e, t, n) {
                return Wr.makeScale(e, t, n), this.applyMatrix(Wr), this;
            },
            lookAt: function (e) {
                return qr.lookAt(e), qr.updateMatrix(), this.applyMatrix(qr.matrix), this;
            },
            fromBufferGeometry: function (e) {
                var t = this,
                    n = null !== e.index ? e.index.array : void 0,
                    i = e.attributes;
                if (void 0 === i.position) return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this;
                var r = i.position.array,
                    o = void 0 !== i.normal ? i.normal.array : void 0,
                    a = void 0 !== i.color ? i.color.array : void 0,
                    s = void 0 !== i.uv ? i.uv.array : void 0,
                    c = void 0 !== i.uv2 ? i.uv2.array : void 0;
                void 0 !== c && (this.faceVertexUvs[1] = []);
                for (var l = 0; l < r.length; l += 3) t.vertices.push(new Sn().fromArray(r, l)), void 0 !== a && t.colors.push(new Zi().fromArray(a, l));
                function u(e, n, i, r) {
                    var l = void 0 === a ? [] : [t.colors[e].clone(), t.colors[n].clone(), t.colors[i].clone()],
                        u = new er(e, n, i, void 0 === o ? [] : [new Sn().fromArray(o, 3 * e), new Sn().fromArray(o, 3 * n), new Sn().fromArray(o, 3 * i)], l, r);
                    t.faces.push(u),
                        void 0 !== s && t.faceVertexUvs[0].push([new _n().fromArray(s, 2 * e), new _n().fromArray(s, 2 * n), new _n().fromArray(s, 2 * i)]),
                        void 0 !== c && t.faceVertexUvs[1].push([new _n().fromArray(c, 2 * e), new _n().fromArray(c, 2 * n), new _n().fromArray(c, 2 * i)]);
                }
                var h = e.groups;
                if (h.length > 0) for (l = 0; l < h.length; l++) for (var d = h[l], p = d.start, f = p, m = p + d.count; f < m; f += 3) void 0 !== n ? u(n[f], n[f + 1], n[f + 2], d.materialIndex) : u(f, f + 1, f + 2, d.materialIndex);
                else if (void 0 !== n) for (l = 0; l < n.length; l += 3) u(n[l], n[l + 1], n[l + 2]);
                else for (l = 0; l < r.length / 3; l += 3) u(l, l + 1, l + 2);
                return this.computeFaceNormals(), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this;
            },
            center: function () {
                return this.computeBoundingBox(), this.boundingBox.getCenter(Xr).negate(), this.translate(Xr.x, Xr.y, Xr.z), this;
            },
            normalize: function () {
                this.computeBoundingSphere();
                var e = this.boundingSphere.center,
                    t = this.boundingSphere.radius,
                    n = 0 === t ? 1 : 1 / t,
                    i = new Hn();
                return i.set(n, 0, 0, -n * e.x, 0, n, 0, -n * e.y, 0, 0, n, -n * e.z, 0, 0, 0, 1), this.applyMatrix(i), this;
            },
            computeFaceNormals: function () {
                for (var e = new Sn(), t = new Sn(), n = 0, i = this.faces.length; n < i; n++) {
                    var r = this.faces[n],
                        o = this.vertices[r.a],
                        a = this.vertices[r.b],
                        s = this.vertices[r.c];
                    e.subVectors(s, a), t.subVectors(o, a), e.cross(t), e.normalize(), r.normal.copy(e);
                }
            },
            computeVertexNormals: function (e) {
                var t, n, i, r, o, a;
                for (void 0 === e && (e = !0), a = new Array(this.vertices.length), t = 0, n = this.vertices.length; t < n; t++) a[t] = new Sn();
                if (e) {
                    var s,
                        c,
                        l,
                        u = new Sn(),
                        h = new Sn();
                    for (i = 0, r = this.faces.length; i < r; i++)
                        (o = this.faces[i]), (s = this.vertices[o.a]), (c = this.vertices[o.b]), (l = this.vertices[o.c]), u.subVectors(l, c), h.subVectors(s, c), u.cross(h), a[o.a].add(u), a[o.b].add(u), a[o.c].add(u);
                } else for (this.computeFaceNormals(), i = 0, r = this.faces.length; i < r; i++) a[(o = this.faces[i]).a].add(o.normal), a[o.b].add(o.normal), a[o.c].add(o.normal);
                for (t = 0, n = this.vertices.length; t < n; t++) a[t].normalize();
                for (i = 0, r = this.faces.length; i < r; i++) {
                    var d = (o = this.faces[i]).vertexNormals;
                    3 === d.length ? (d[0].copy(a[o.a]), d[1].copy(a[o.b]), d[2].copy(a[o.c])) : ((d[0] = a[o.a].clone()), (d[1] = a[o.b].clone()), (d[2] = a[o.c].clone()));
                }
                this.faces.length > 0 && (this.normalsNeedUpdate = !0);
            },
            computeFlatVertexNormals: function () {
                var e, t, n;
                for (this.computeFaceNormals(), e = 0, t = this.faces.length; e < t; e++) {
                    var i = (n = this.faces[e]).vertexNormals;
                    3 === i.length ? (i[0].copy(n.normal), i[1].copy(n.normal), i[2].copy(n.normal)) : ((i[0] = n.normal.clone()), (i[1] = n.normal.clone()), (i[2] = n.normal.clone()));
                }
                this.faces.length > 0 && (this.normalsNeedUpdate = !0);
            },
            computeMorphNormals: function () {
                var e, t, n, i, r;
                for (n = 0, i = this.faces.length; n < i; n++)
                    for (
                        (r = this.faces[n]).__originalFaceNormal ? r.__originalFaceNormal.copy(r.normal) : (r.__originalFaceNormal = r.normal.clone()),
                            r.__originalVertexNormals || (r.__originalVertexNormals = []),
                            e = 0,
                            t = r.vertexNormals.length;
                        e < t;
                        e++
                    )
                        r.__originalVertexNormals[e] ? r.__originalVertexNormals[e].copy(r.vertexNormals[e]) : (r.__originalVertexNormals[e] = r.vertexNormals[e].clone());
                var o = new Yr();
                for (o.faces = this.faces, e = 0, t = this.morphTargets.length; e < t; e++) {
                    if (!this.morphNormals[e]) {
                        (this.morphNormals[e] = {}), (this.morphNormals[e].faceNormals = []), (this.morphNormals[e].vertexNormals = []);
                        var a = this.morphNormals[e].faceNormals,
                            s = this.morphNormals[e].vertexNormals;
                        for (n = 0, i = this.faces.length; n < i; n++) (c = new Sn()), (l = { a: new Sn(), b: new Sn(), c: new Sn() }), a.push(c), s.push(l);
                    }
                    var c,
                        l,
                        u = this.morphNormals[e];
                    for (o.vertices = this.morphTargets[e].vertices, o.computeFaceNormals(), o.computeVertexNormals(), n = 0, i = this.faces.length; n < i; n++)
                        (r = this.faces[n]), (c = u.faceNormals[n]), (l = u.vertexNormals[n]), c.copy(r.normal), l.a.copy(r.vertexNormals[0]), l.b.copy(r.vertexNormals[1]), l.c.copy(r.vertexNormals[2]);
                }
                for (n = 0, i = this.faces.length; n < i; n++) ((r = this.faces[n]).normal = r.__originalFaceNormal), (r.vertexNormals = r.__originalVertexNormals);
            },
            computeBoundingBox: function () {
                null === this.boundingBox && (this.boundingBox = new _i()), this.boundingBox.setFromPoints(this.vertices);
            },
            computeBoundingSphere: function () {
                null === this.boundingSphere && (this.boundingSphere = new Mi()), this.boundingSphere.setFromPoints(this.vertices);
            },
            merge: function (e, t, n) {
                if (e && e.isGeometry) {
                    var i,
                        r = this.vertices.length,
                        o = this.vertices,
                        a = e.vertices,
                        s = this.faces,
                        c = e.faces,
                        l = this.colors,
                        u = e.colors;
                    void 0 === n && (n = 0), void 0 !== t && (i = new An().getNormalMatrix(t));
                    for (var h = 0, d = a.length; h < d; h++) {
                        var p = a[h].clone();
                        void 0 !== t && p.applyMatrix4(t), o.push(p);
                    }
                    for (h = 0, d = u.length; h < d; h++) l.push(u[h].clone());
                    for (h = 0, d = c.length; h < d; h++) {
                        var f,
                            m,
                            v,
                            g = c[h],
                            y = g.vertexNormals,
                            x = g.vertexColors;
                        (f = new er(g.a + r, g.b + r, g.c + r)).normal.copy(g.normal), void 0 !== i && f.normal.applyMatrix3(i).normalize();
                        for (var _ = 0, b = y.length; _ < b; _++) (m = y[_].clone()), void 0 !== i && m.applyMatrix3(i).normalize(), f.vertexNormals.push(m);
                        f.color.copy(g.color);
                        for (_ = 0, b = x.length; _ < b; _++) (v = x[_]), f.vertexColors.push(v.clone());
                        (f.materialIndex = g.materialIndex + n), s.push(f);
                    }
                    for (h = 0, d = e.faceVertexUvs.length; h < d; h++) {
                        var w = e.faceVertexUvs[h];
                        void 0 === this.faceVertexUvs[h] && (this.faceVertexUvs[h] = []);
                        for (_ = 0, b = w.length; _ < b; _++) {
                            for (var M = w[_], S = [], E = 0, T = M.length; E < T; E++) S.push(M[E].clone());
                            this.faceVertexUvs[h].push(S);
                        }
                    }
                } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", e);
            },
            mergeMesh: function (e) {
                e && e.isMesh ? (e.matrixAutoUpdate && e.updateMatrix(), this.merge(e.geometry, e.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", e);
            },
            mergeVertices: function () {
                var e,
                    t,
                    n,
                    i,
                    r,
                    o,
                    a,
                    s,
                    c = {},
                    l = [],
                    u = [],
                    h = Math.pow(10, 4);
                for (n = 0, i = this.vertices.length; n < i; n++)
                    (e = this.vertices[n]), void 0 === c[(t = Math.round(e.x * h) + "_" + Math.round(e.y * h) + "_" + Math.round(e.z * h))] ? ((c[t] = n), l.push(this.vertices[n]), (u[n] = l.length - 1)) : (u[n] = u[c[t]]);
                var d = [];
                for (n = 0, i = this.faces.length; n < i; n++) {
                    ((r = this.faces[n]).a = u[r.a]), (r.b = u[r.b]), (r.c = u[r.c]), (o = [r.a, r.b, r.c]);
                    for (var p = 0; p < 3; p++)
                        if (o[p] === o[(p + 1) % 3]) {
                            d.push(n);
                            break;
                        }
                }
                for (n = d.length - 1; n >= 0; n--) {
                    var f = d[n];
                    for (this.faces.splice(f, 1), a = 0, s = this.faceVertexUvs.length; a < s; a++) this.faceVertexUvs[a].splice(f, 1);
                }
                var m = this.vertices.length - l.length;
                return (this.vertices = l), m;
            },
            setFromPoints: function (e) {
                this.vertices = [];
                for (var t = 0, n = e.length; t < n; t++) {
                    var i = e[t];
                    this.vertices.push(new Sn(i.x, i.y, i.z || 0));
                }
                return this;
            },
            sortFacesByMaterialIndex: function () {
                for (var e = this.faces, t = e.length, n = 0; n < t; n++) e[n]._id = n;
                e.sort(function (e, t) {
                    return e.materialIndex - t.materialIndex;
                });
                var i,
                    r,
                    o = this.faceVertexUvs[0],
                    a = this.faceVertexUvs[1];
                o && o.length === t && (i = []), a && a.length === t && (r = []);
                for (n = 0; n < t; n++) {
                    var s = e[n]._id;
                    i && i.push(o[s]), r && r.push(a[s]);
                }
                i && (this.faceVertexUvs[0] = i), r && (this.faceVertexUvs[1] = r);
            },
            toJSON: function () {
                var e = { metadata: { version: 4.5, type: "Geometry", generator: "Geometry.toJSON" } };
                if (((e.uuid = this.uuid), (e.type = this.type), "" !== this.name && (e.name = this.name), void 0 !== this.parameters)) {
                    var t = this.parameters;
                    for (var n in t) void 0 !== t[n] && (e[n] = t[n]);
                    return e;
                }
                for (var i = [], r = 0; r < this.vertices.length; r++) {
                    var o = this.vertices[r];
                    i.push(o.x, o.y, o.z);
                }
                var a = [],
                    s = [],
                    c = {},
                    l = [],
                    u = {},
                    h = [],
                    d = {};
                for (r = 0; r < this.faces.length; r++) {
                    var p = this.faces[r],
                        f = void 0 !== this.faceVertexUvs[0][r],
                        m = p.normal.length() > 0,
                        v = p.vertexNormals.length > 0,
                        g = 1 !== p.color.r || 1 !== p.color.g || 1 !== p.color.b,
                        y = p.vertexColors.length > 0,
                        x = 0;
                    if (((x = M(x, 0, 0)), (x = M(x, 1, !0)), (x = M(x, 2, !1)), (x = M(x, 3, f)), (x = M(x, 4, m)), (x = M(x, 5, v)), (x = M(x, 6, g)), (x = M(x, 7, y)), a.push(x), a.push(p.a, p.b, p.c), a.push(p.materialIndex), f)) {
                        var _ = this.faceVertexUvs[0][r];
                        a.push(T(_[0]), T(_[1]), T(_[2]));
                    }
                    if ((m && a.push(S(p.normal)), v)) {
                        var b = p.vertexNormals;
                        a.push(S(b[0]), S(b[1]), S(b[2]));
                    }
                    if ((g && a.push(E(p.color)), y)) {
                        var w = p.vertexColors;
                        a.push(E(w[0]), E(w[1]), E(w[2]));
                    }
                }
                function M(e, t, n) {
                    return n ? e | (1 << t) : e & ~(1 << t);
                }
                function S(e) {
                    var t = e.x.toString() + e.y.toString() + e.z.toString();
                    return void 0 !== c[t] ? c[t] : ((c[t] = s.length / 3), s.push(e.x, e.y, e.z), c[t]);
                }
                function E(e) {
                    var t = e.r.toString() + e.g.toString() + e.b.toString();
                    return void 0 !== u[t] ? u[t] : ((u[t] = l.length), l.push(e.getHex()), u[t]);
                }
                function T(e) {
                    var t = e.x.toString() + e.y.toString();
                    return void 0 !== d[t] ? d[t] : ((d[t] = h.length / 2), h.push(e.x, e.y), d[t]);
                }
                return (e.data = {}), (e.data.vertices = i), (e.data.normals = s), l.length > 0 && (e.data.colors = l), h.length > 0 && (e.data.uvs = [h]), (e.data.faces = a), e;
            },
            clone: function () {
                return new Yr().copy(this);
            },
            copy: function (e) {
                var t, n, i, r, o, a;
                (this.vertices = []),
                    (this.colors = []),
                    (this.faces = []),
                    (this.faceVertexUvs = [[]]),
                    (this.morphTargets = []),
                    (this.morphNormals = []),
                    (this.skinWeights = []),
                    (this.skinIndices = []),
                    (this.lineDistances = []),
                    (this.boundingBox = null),
                    (this.boundingSphere = null),
                    (this.name = e.name);
                var s = e.vertices;
                for (t = 0, n = s.length; t < n; t++) this.vertices.push(s[t].clone());
                var c = e.colors;
                for (t = 0, n = c.length; t < n; t++) this.colors.push(c[t].clone());
                var l = e.faces;
                for (t = 0, n = l.length; t < n; t++) this.faces.push(l[t].clone());
                for (t = 0, n = e.faceVertexUvs.length; t < n; t++) {
                    var u = e.faceVertexUvs[t];
                    for (void 0 === this.faceVertexUvs[t] && (this.faceVertexUvs[t] = []), i = 0, r = u.length; i < r; i++) {
                        var h = u[i],
                            d = [];
                        for (o = 0, a = h.length; o < a; o++) {
                            var p = h[o];
                            d.push(p.clone());
                        }
                        this.faceVertexUvs[t].push(d);
                    }
                }
                var f = e.morphTargets;
                for (t = 0, n = f.length; t < n; t++) {
                    var m = {};
                    if (((m.name = f[t].name), void 0 !== f[t].vertices)) for (m.vertices = [], i = 0, r = f[t].vertices.length; i < r; i++) m.vertices.push(f[t].vertices[i].clone());
                    if (void 0 !== f[t].normals) for (m.normals = [], i = 0, r = f[t].normals.length; i < r; i++) m.normals.push(f[t].normals[i].clone());
                    this.morphTargets.push(m);
                }
                var v = e.morphNormals;
                for (t = 0, n = v.length; t < n; t++) {
                    var g = {};
                    if (void 0 !== v[t].vertexNormals)
                        for (g.vertexNormals = [], i = 0, r = v[t].vertexNormals.length; i < r; i++) {
                            var y = v[t].vertexNormals[i],
                                x = {};
                            (x.a = y.a.clone()), (x.b = y.b.clone()), (x.c = y.c.clone()), g.vertexNormals.push(x);
                        }
                    if (void 0 !== v[t].faceNormals) for (g.faceNormals = [], i = 0, r = v[t].faceNormals.length; i < r; i++) g.faceNormals.push(v[t].faceNormals[i].clone());
                    this.morphNormals.push(g);
                }
                var _ = e.skinWeights;
                for (t = 0, n = _.length; t < n; t++) this.skinWeights.push(_[t].clone());
                var b = e.skinIndices;
                for (t = 0, n = b.length; t < n; t++) this.skinIndices.push(b[t].clone());
                var w = e.lineDistances;
                for (t = 0, n = w.length; t < n; t++) this.lineDistances.push(w[t]);
                var M = e.boundingBox;
                null !== M && (this.boundingBox = M.clone());
                var S = e.boundingSphere;
                return (
                    null !== S && (this.boundingSphere = S.clone()),
                    (this.elementsNeedUpdate = e.elementsNeedUpdate),
                    (this.verticesNeedUpdate = e.verticesNeedUpdate),
                    (this.uvsNeedUpdate = e.uvsNeedUpdate),
                    (this.normalsNeedUpdate = e.normalsNeedUpdate),
                    (this.colorsNeedUpdate = e.colorsNeedUpdate),
                    (this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate),
                    (this.groupsNeedUpdate = e.groupsNeedUpdate),
                    this
                );
            },
            dispose: function () {
                this.dispatchEvent({ type: "dispose" });
            },
        });
        class Jr extends Yr {
            constructor(e, t, n, i, r, o) {
                super(), (this.type = "BoxGeometry"), (this.parameters = { width: e, height: t, depth: n, widthSegments: i, heightSegments: r, depthSegments: o }), this.fromBufferGeometry(new Zr(e, t, n, i, r, o)), this.mergeVertices();
            }
        }
        class Zr extends Mr {
            constructor(e, t, n, i, r, o) {
                super(), (this.type = "BoxBufferGeometry"), (this.parameters = { width: e, height: t, depth: n, widthSegments: i, heightSegments: r, depthSegments: o });
                var a = this;
                (e = e || 1), (t = t || 1), (n = n || 1), (i = Math.floor(i) || 1), (r = Math.floor(r) || 1), (o = Math.floor(o) || 1);
                var s = [],
                    c = [],
                    l = [],
                    u = [],
                    h = 0,
                    d = 0;
                function p(e, t, n, i, r, o, p, f, m, v, g) {
                    var y,
                        x,
                        _ = o / m,
                        b = p / v,
                        w = o / 2,
                        M = p / 2,
                        S = f / 2,
                        E = m + 1,
                        T = v + 1,
                        A = 0,
                        L = 0,
                        C = new Sn();
                    for (x = 0; x < T; x++) {
                        var R = x * b - M;
                        for (y = 0; y < E; y++) {
                            var P = y * _ - w;
                            (C[e] = P * i), (C[t] = R * r), (C[n] = S), c.push(C.x, C.y, C.z), (C[e] = 0), (C[t] = 0), (C[n] = f > 0 ? 1 : -1), l.push(C.x, C.y, C.z), u.push(y / m), u.push(1 - x / v), (A += 1);
                        }
                    }
                    for (x = 0; x < v; x++)
                        for (y = 0; y < m; y++) {
                            var O = h + y + E * x,
                                D = h + y + E * (x + 1),
                                I = h + (y + 1) + E * (x + 1),
                                N = h + (y + 1) + E * x;
                            s.push(O, D, N), s.push(D, I, N), (L += 6);
                        }
                    a.addGroup(d, L, g), (d += L), (h += A);
                }
                p("z", "y", "x", -1, -1, n, t, e, o, r, 0),
                    p("z", "y", "x", 1, -1, n, t, -e, o, r, 1),
                    p("x", "z", "y", 1, 1, e, n, t, i, o, 2),
                    p("x", "z", "y", 1, -1, e, n, -t, i, o, 3),
                    p("x", "y", "z", 1, -1, e, t, n, i, r, 4),
                    p("x", "y", "z", -1, -1, e, t, -n, i, r, 5),
                    this.setIndex(s),
                    this.setAttribute("position", new dr(c, 3)),
                    this.setAttribute("normal", new dr(l, 3)),
                    this.setAttribute("uv", new dr(u, 2));
            }
        }
        function Kr(e) {
            var t = {};
            for (var n in e)
                for (var i in ((t[n] = {}), e[n])) {
                    var r = e[n][i];
                    r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? (t[n][i] = r.clone()) : Array.isArray(r) ? (t[n][i] = r.slice()) : (t[n][i] = r);
                }
            return t;
        }
        function Qr(e) {
            for (var t = {}, n = 0; n < e.length; n++) {
                var i = Kr(e[n]);
                for (var r in i) t[r] = i[r];
            }
            return t;
        }
        var $r = { clone: Kr, merge: Qr },
            eo = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
            to = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
        function no(e) {
            nr.call(this),
                (this.type = "ShaderMaterial"),
                (this.defines = {}),
                (this.uniforms = {}),
                (this.vertexShader = eo),
                (this.fragmentShader = to),
                (this.linewidth = 1),
                (this.wireframe = !1),
                (this.wireframeLinewidth = 1),
                (this.fog = !1),
                (this.lights = !1),
                (this.clipping = !1),
                (this.skinning = !1),
                (this.morphTargets = !1),
                (this.morphNormals = !1),
                (this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }),
                (this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }),
                (this.index0AttributeName = void 0),
                (this.uniformsNeedUpdate = !1),
                void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e));
        }
        function io() {
            oi.call(this), (this.type = "Camera"), (this.matrixWorldInverse = new Hn()), (this.projectionMatrix = new Hn()), (this.projectionMatrixInverse = new Hn());
        }
        function ro(e, t, n, i) {
            io.call(this),
                (this.type = "PerspectiveCamera"),
                (this.fov = void 0 !== e ? e : 50),
                (this.zoom = 1),
                (this.near = void 0 !== n ? n : 0.1),
                (this.far = void 0 !== i ? i : 2e3),
                (this.focus = 10),
                (this.aspect = void 0 !== t ? t : 1),
                (this.view = null),
                (this.filmGauge = 35),
                (this.filmOffset = 0),
                this.updateProjectionMatrix();
        }
        (no.prototype = Object.create(nr.prototype)),
            (no.prototype.constructor = no),
            (no.prototype.isShaderMaterial = !0),
            (no.prototype.copy = function (e) {
                return (
                    nr.prototype.copy.call(this, e),
                    (this.fragmentShader = e.fragmentShader),
                    (this.vertexShader = e.vertexShader),
                    (this.uniforms = Kr(e.uniforms)),
                    (this.defines = Object.assign({}, e.defines)),
                    (this.wireframe = e.wireframe),
                    (this.wireframeLinewidth = e.wireframeLinewidth),
                    (this.lights = e.lights),
                    (this.clipping = e.clipping),
                    (this.skinning = e.skinning),
                    (this.morphTargets = e.morphTargets),
                    (this.morphNormals = e.morphNormals),
                    (this.extensions = e.extensions),
                    this
                );
            }),
            (no.prototype.toJSON = function (e) {
                var t = nr.prototype.toJSON.call(this, e);
                for (var n in ((t.uniforms = {}), this.uniforms)) {
                    var i = this.uniforms[n].value;
                    i && i.isTexture
                        ? (t.uniforms[n] = { type: "t", value: i.toJSON(e).uuid })
                        : i && i.isColor
                        ? (t.uniforms[n] = { type: "c", value: i.getHex() })
                        : i && i.isVector2
                        ? (t.uniforms[n] = { type: "v2", value: i.toArray() })
                        : i && i.isVector3
                        ? (t.uniforms[n] = { type: "v3", value: i.toArray() })
                        : i && i.isVector4
                        ? (t.uniforms[n] = { type: "v4", value: i.toArray() })
                        : i && i.isMatrix3
                        ? (t.uniforms[n] = { type: "m3", value: i.toArray() })
                        : i && i.isMatrix4
                        ? (t.uniforms[n] = { type: "m4", value: i.toArray() })
                        : (t.uniforms[n] = { value: i });
                }
                Object.keys(this.defines).length > 0 && (t.defines = this.defines), (t.vertexShader = this.vertexShader), (t.fragmentShader = this.fragmentShader);
                var r = {};
                for (var o in this.extensions) !0 === this.extensions[o] && (r[o] = !0);
                return Object.keys(r).length > 0 && (t.extensions = r), t;
            }),
            (io.prototype = Object.assign(Object.create(oi.prototype), {
                constructor: io,
                isCamera: !0,
                copy: function (e, t) {
                    return oi.prototype.copy.call(this, e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this;
                },
                getWorldDirection: function (e) {
                    void 0 === e && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), (e = new Sn())), this.updateMatrixWorld(!0);
                    var t = this.matrixWorld.elements;
                    return e.set(-t[8], -t[9], -t[10]).normalize();
                },
                updateMatrixWorld: function (e) {
                    oi.prototype.updateMatrixWorld.call(this, e), this.matrixWorldInverse.getInverse(this.matrixWorld);
                },
                clone: function () {
                    return new this.constructor().copy(this);
                },
            })),
            (ro.prototype = Object.assign(Object.create(io.prototype), {
                constructor: ro,
                isPerspectiveCamera: !0,
                copy: function (e, t) {
                    return (
                        io.prototype.copy.call(this, e, t),
                        (this.fov = e.fov),
                        (this.zoom = e.zoom),
                        (this.near = e.near),
                        (this.far = e.far),
                        (this.focus = e.focus),
                        (this.aspect = e.aspect),
                        (this.view = null === e.view ? null : Object.assign({}, e.view)),
                        (this.filmGauge = e.filmGauge),
                        (this.filmOffset = e.filmOffset),
                        this
                    );
                },
                setFocalLength: function (e) {
                    var t = (0.5 * this.getFilmHeight()) / e;
                    (this.fov = 2 * xn.RAD2DEG * Math.atan(t)), this.updateProjectionMatrix();
                },
                getFocalLength: function () {
                    var e = Math.tan(0.5 * xn.DEG2RAD * this.fov);
                    return (0.5 * this.getFilmHeight()) / e;
                },
                getEffectiveFOV: function () {
                    return 2 * xn.RAD2DEG * Math.atan(Math.tan(0.5 * xn.DEG2RAD * this.fov) / this.zoom);
                },
                getFilmWidth: function () {
                    return this.filmGauge * Math.min(this.aspect, 1);
                },
                getFilmHeight: function () {
                    return this.filmGauge / Math.max(this.aspect, 1);
                },
                setViewOffset: function (e, t, n, i, r, o) {
                    (this.aspect = e / t),
                        null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }),
                        (this.view.enabled = !0),
                        (this.view.fullWidth = e),
                        (this.view.fullHeight = t),
                        (this.view.offsetX = n),
                        (this.view.offsetY = i),
                        (this.view.width = r),
                        (this.view.height = o),
                        this.updateProjectionMatrix();
                },
                clearViewOffset: function () {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
                },
                updateProjectionMatrix: function () {
                    var e = this.near,
                        t = (e * Math.tan(0.5 * xn.DEG2RAD * this.fov)) / this.zoom,
                        n = 2 * t,
                        i = this.aspect * n,
                        r = -0.5 * i,
                        o = this.view;
                    if (null !== this.view && this.view.enabled) {
                        var a = o.fullWidth,
                            s = o.fullHeight;
                        (r += (o.offsetX * i) / a), (t -= (o.offsetY * n) / s), (i *= o.width / a), (n *= o.height / s);
                    }
                    var c = this.filmOffset;
                    0 !== c && (r += (e * c) / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix);
                },
                toJSON: function (e) {
                    var t = oi.prototype.toJSON.call(this, e);
                    return (
                        (t.object.fov = this.fov),
                        (t.object.zoom = this.zoom),
                        (t.object.near = this.near),
                        (t.object.far = this.far),
                        (t.object.focus = this.focus),
                        (t.object.aspect = this.aspect),
                        null !== this.view && (t.object.view = Object.assign({}, this.view)),
                        (t.object.filmGauge = this.filmGauge),
                        (t.object.filmOffset = this.filmOffset),
                        t
                    );
                },
            }));
        var oo = 90,
            ao = 1;
        function so(e, t, n, i) {
            oi.call(this), (this.type = "CubeCamera");
            var r = new ro(oo, ao, e, t);
            r.up.set(0, -1, 0), r.lookAt(new Sn(1, 0, 0)), this.add(r);
            var o = new ro(oo, ao, e, t);
            o.up.set(0, -1, 0), o.lookAt(new Sn(-1, 0, 0)), this.add(o);
            var a = new ro(oo, ao, e, t);
            a.up.set(0, 0, 1), a.lookAt(new Sn(0, 1, 0)), this.add(a);
            var s = new ro(oo, ao, e, t);
            s.up.set(0, 0, -1), s.lookAt(new Sn(0, -1, 0)), this.add(s);
            var c = new ro(oo, ao, e, t);
            c.up.set(0, -1, 0), c.lookAt(new Sn(0, 0, 1)), this.add(c);
            var l = new ro(oo, ao, e, t);
            l.up.set(0, -1, 0),
                l.lookAt(new Sn(0, 0, -1)),
                this.add(l),
                (i = i || { format: ke, magFilter: Ee, minFilter: Ee }),
                (this.renderTarget = new co(n, n, i)),
                (this.renderTarget.texture.name = "CubeCamera"),
                (this.update = function (e, t) {
                    null === this.parent && this.updateMatrixWorld();
                    var n = e.getRenderTarget(),
                        i = this.renderTarget,
                        u = i.texture.generateMipmaps;
                    (i.texture.generateMipmaps = !1),
                        e.setRenderTarget(i, 0),
                        e.render(t, r),
                        e.setRenderTarget(i, 1),
                        e.render(t, o),
                        e.setRenderTarget(i, 2),
                        e.render(t, a),
                        e.setRenderTarget(i, 3),
                        e.render(t, s),
                        e.setRenderTarget(i, 4),
                        e.render(t, c),
                        (i.texture.generateMipmaps = u),
                        e.setRenderTarget(i, 5),
                        e.render(t, l),
                        e.setRenderTarget(n);
                }),
                (this.clear = function (e, t, n, i) {
                    for (var r = e.getRenderTarget(), o = this.renderTarget, a = 0; a < 6; a++) e.setRenderTarget(o, a), e.clear(t, n, i);
                    e.setRenderTarget(r);
                });
        }
        function co(e, t, n) {
            On.call(this, e, t, n);
        }
        function lo(e, t, n, i, r, o, a, s, c, l, u, h) {
            Rn.call(this, null, o, a, s, c, l, i, r, u, h),
                (this.image = { data: e || null, width: t || 1, height: n || 1 }),
                (this.magFilter = void 0 !== c ? c : _e),
                (this.minFilter = void 0 !== l ? l : _e),
                (this.generateMipmaps = !1),
                (this.flipY = !1),
                (this.unpackAlignment = 1),
                (this.needsUpdate = !0);
        }
        (so.prototype = Object.create(oi.prototype)),
            (so.prototype.constructor = so),
            (co.prototype = Object.create(On.prototype)),
            (co.prototype.constructor = co),
            (co.prototype.isWebGLRenderTargetCube = !0),
            (co.prototype.fromEquirectangularTexture = function (e, t) {
                (this.texture.type = t.type), (this.texture.format = t.format), (this.texture.encoding = t.encoding);
                var n = new ai(),
                    i = {
                        uniforms: { tEquirect: { value: null } },
                        vertexShader: [
                            "varying vec3 vWorldDirection;",
                            "vec3 transformDirection( in vec3 dir, in mat4 matrix ) {",
                            "\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );",
                            "}",
                            "void main() {",
                            "\tvWorldDirection = transformDirection( position, modelMatrix );",
                            "\t#include <begin_vertex>",
                            "\t#include <project_vertex>",
                            "}",
                        ].join("\n"),
                        fragmentShader: [
                            "uniform sampler2D tEquirect;",
                            "varying vec3 vWorldDirection;",
                            "#define RECIPROCAL_PI 0.31830988618",
                            "#define RECIPROCAL_PI2 0.15915494",
                            "void main() {",
                            "\tvec3 direction = normalize( vWorldDirection );",
                            "\tvec2 sampleUV;",
                            "\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;",
                            "\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;",
                            "\tgl_FragColor = texture2D( tEquirect, sampleUV );",
                            "}",
                        ].join("\n"),
                    },
                    r = new no({ type: "CubemapFromEquirect", uniforms: Kr(i.uniforms), vertexShader: i.vertexShader, fragmentShader: i.fragmentShader, side: g, blending: S });
                r.uniforms.tEquirect.value = t;
                var o = new Hr(new Zr(5, 5, 5), r);
                n.add(o);
                var a = new so(1, 10, 1);
                return (a.renderTarget = this), (a.renderTarget.texture.name = "CubeCameraTexture"), a.update(e, n), o.geometry.dispose(), o.material.dispose(), this;
            }),
            (lo.prototype = Object.create(Rn.prototype)),
            (lo.prototype.constructor = lo),
            (lo.prototype.isDataTexture = !0);
        var uo = new Mi(),
            ho = new Sn();
        function po(e, t, n, i, r, o) {
            this.planes = [void 0 !== e ? e : new Ni(), void 0 !== t ? t : new Ni(), void 0 !== n ? n : new Ni(), void 0 !== i ? i : new Ni(), void 0 !== r ? r : new Ni(), void 0 !== o ? o : new Ni()];
        }
        Object.assign(po.prototype, {
            set: function (e, t, n, i, r, o) {
                var a = this.planes;
                return a[0].copy(e), a[1].copy(t), a[2].copy(n), a[3].copy(i), a[4].copy(r), a[5].copy(o), this;
            },
            clone: function () {
                return new this.constructor().copy(this);
            },
            copy: function (e) {
                for (var t = this.planes, n = 0; n < 6; n++) t[n].copy(e.planes[n]);
                return this;
            },
            setFromMatrix: function (e) {
                var t = this.planes,
                    n = e.elements,
                    i = n[0],
                    r = n[1],
                    o = n[2],
                    a = n[3],
                    s = n[4],
                    c = n[5],
                    l = n[6],
                    u = n[7],
                    h = n[8],
                    d = n[9],
                    p = n[10],
                    f = n[11],
                    m = n[12],
                    v = n[13],
                    g = n[14],
                    y = n[15];
                return (
                    t[0].setComponents(a - i, u - s, f - h, y - m).normalize(),
                    t[1].setComponents(a + i, u + s, f + h, y + m).normalize(),
                    t[2].setComponents(a + r, u + c, f + d, y + v).normalize(),
                    t[3].setComponents(a - r, u - c, f - d, y - v).normalize(),
                    t[4].setComponents(a - o, u - l, f - p, y - g).normalize(),
                    t[5].setComponents(a + o, u + l, f + p, y + g).normalize(),
                    this
                );
            },
            intersectsObject: function (e) {
                var t = e.geometry;
                return null === t.boundingSphere && t.computeBoundingSphere(), uo.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(uo);
            },
            intersectsSprite: function (e) {
                return uo.center.set(0, 0, 0), (uo.radius = 0.7071067811865476), uo.applyMatrix4(e.matrixWorld), this.intersectsSphere(uo);
            },
            intersectsSphere: function (e) {
                for (var t = this.planes, n = e.center, i = -e.radius, r = 0; r < 6; r++) {
                    if (t[r].distanceToPoint(n) < i) return !1;
                }
                return !0;
            },
            intersectsBox: function (e) {
                for (var t = this.planes, n = 0; n < 6; n++) {
                    var i = t[n];
                    if (((ho.x = i.normal.x > 0 ? e.max.x : e.min.x), (ho.y = i.normal.y > 0 ? e.max.y : e.min.y), (ho.z = i.normal.z > 0 ? e.max.z : e.min.z), i.distanceToPoint(ho) < 0)) return !1;
                }
                return !0;
            },
            containsPoint: function (e) {
                for (var t = this.planes, n = 0; n < 6; n++) if (t[n].distanceToPoint(e) < 0) return !1;
                return !0;
            },
        });
        var fo = {
                alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
                alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
                aomap_fragment:
                    "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
                aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                begin_vertex: "vec3 transformed = vec3( position );",
                beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                bsdfs:
                    "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
                bumpmap_pars_fragment:
                    "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                clipping_planes_fragment:
                    "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
                clipping_planes_pars_fragment:
                    "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif",
                clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif",
                color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
                color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
                color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
                color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
                common:
                    "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}",
                cube_uv_reflection_fragment:
                    "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif",
                defaultnormal_vertex:
                    "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\ttransformedNormal = mat3( instanceMatrix ) * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
                emissivemap_fragment:
                    "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                encodings_pars_fragment:
                    "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
                envmap_fragment:
                    "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t}  else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                envmap_common_pars_fragment:
                    "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
                envmap_pars_fragment:
                    "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                envmap_pars_vertex:
                    "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                envmap_physical_pars_fragment:
                    "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
                envmap_vertex:
                    "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) { \n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
                fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
                fog_fragment:
                    "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                gradientmap_pars_fragment:
                    "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif",
                lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif",
                lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                lights_lambert_vertex:
                    "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif",
                lights_pars_begin:
                    "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
                lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                lights_phong_pars_fragment:
                    "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
                lights_physical_fragment:
                    "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = saturate( clearcoat );\tmaterial.clearcoatRoughness = clamp( clearcoatRoughness, 0.04, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
                lights_physical_pars_fragment:
                    "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                lights_fragment_begin:
                    "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( pointLight.shadow, directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( spotLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( directionalLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                lights_fragment_maps:
                    "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
                lights_fragment_end:
                    "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
                logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
                logdepthbuf_vertex:
                    "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
                map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
                map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                map_particle_fragment:
                    "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                map_particle_pars_fragment:
                    "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                morphnormal_vertex:
                    "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
                morphtarget_pars_vertex:
                    "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
                morphtarget_vertex:
                    "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
                normal_fragment_begin:
                    "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
                normal_fragment_maps:
                    "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
                normalmap_pars_fragment:
                    "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",
                clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
                clearcoat_normal_fragment_maps:
                    "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif",
                clearcoat_normalmap_pars_fragment: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
                packing:
                    "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpack2HalfToRGBA( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
                premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                project_vertex:
                    "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                dithering_pars_fragment:
                    "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                shadowmap_pars_fragment:
                    "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpack2HalfToRGBA( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = ( floor( uv * size - 0.5 ) + 0.5 ) * texelSize;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
                shadowmap_pars_vertex:
                    "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
                shadowmap_vertex:
                    "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif",
                shadowmask_pars_fragment:
                    "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= all( bvec2( directionalLight.shadow, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= all( bvec2( spotLight.shadow, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= all( bvec2( pointLight.shadow, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                skinbase_vertex:
                    "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                skinning_pars_vertex:
                    "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
                skinning_vertex:
                    "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                skinnormal_vertex:
                    "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                tonemapping_pars_fragment:
                    "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
                uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
                uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
                uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
                uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
                worldpos_vertex:
                    "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
                background_frag:
                    "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                cube_frag:
                    "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                cube_vert:
                    "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                depth_frag:
                    "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}",
                depth_vert:
                    "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}",
                distanceRGBA_frag:
                    "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                distanceRGBA_vert:
                    "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                equirect_frag:
                    "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                linedashed_frag:
                    "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                linedashed_vert:
                    "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                meshbasic_frag:
                    "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                meshbasic_vert:
                    "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                meshlambert_frag:
                    "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshlambert_vert:
                    "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshmatcap_frag:
                    "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                meshmatcap_vert:
                    "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                meshphong_frag:
                    "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshphong_vert:
                    "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshphysical_frag:
                    "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshphysical_vert:
                    "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                normal_frag:
                    "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
                normal_vert:
                    "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                points_frag:
                    "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                points_vert:
                    "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                shadow_frag:
                    "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}",
                shadow_vert:
                    "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                sprite_frag:
                    "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                sprite_vert:
                    "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            },
            mo = {
                common: { diffuse: { value: new Zi(15658734) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new An() }, alphaMap: { value: null } },
                specularmap: { specularMap: { value: null } },
                envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, refractionRatio: { value: 0.98 }, maxMipLevel: { value: 0 } },
                aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
                lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } },
                emissivemap: { emissiveMap: { value: null } },
                bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
                normalmap: { normalMap: { value: null }, normalScale: { value: new _n(1, 1) } },
                displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } },
                roughnessmap: { roughnessMap: { value: null } },
                metalnessmap: { metalnessMap: { value: null } },
                gradientmap: { gradientMap: { value: null } },
                fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Zi(16777215) } },
                lights: {
                    ambientLightColor: { value: [] },
                    lightProbe: { value: [] },
                    directionalLights: { value: [], properties: { direction: {}, color: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {} } },
                    directionalShadowMap: { value: [] },
                    directionalShadowMatrix: { value: [] },
                    spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {} } },
                    spotShadowMap: { value: [] },
                    spotShadowMatrix: { value: [] },
                    pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } },
                    pointShadowMap: { value: [] },
                    pointShadowMatrix: { value: [] },
                    hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } },
                    rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } },
                },
                points: { diffuse: { value: new Zi(15658734) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new An() } },
                sprite: { diffuse: { value: new Zi(15658734) }, opacity: { value: 1 }, center: { value: new _n(0.5, 0.5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new An() } },
            },
            vo = {
                basic: { uniforms: Qr([mo.common, mo.specularmap, mo.envmap, mo.aomap, mo.lightmap, mo.fog]), vertexShader: fo.meshbasic_vert, fragmentShader: fo.meshbasic_frag },
                lambert: {
                    uniforms: Qr([mo.common, mo.specularmap, mo.envmap, mo.aomap, mo.lightmap, mo.emissivemap, mo.fog, mo.lights, { emissive: { value: new Zi(0) } }]),
                    vertexShader: fo.meshlambert_vert,
                    fragmentShader: fo.meshlambert_frag,
                },
                phong: {
                    uniforms: Qr([
                        mo.common,
                        mo.specularmap,
                        mo.envmap,
                        mo.aomap,
                        mo.lightmap,
                        mo.emissivemap,
                        mo.bumpmap,
                        mo.normalmap,
                        mo.displacementmap,
                        mo.gradientmap,
                        mo.fog,
                        mo.lights,
                        { emissive: { value: new Zi(0) }, specular: { value: new Zi(1118481) }, shininess: { value: 30 } },
                    ]),
                    vertexShader: fo.meshphong_vert,
                    fragmentShader: fo.meshphong_frag,
                },
                standard: {
                    uniforms: Qr([
                        mo.common,
                        mo.envmap,
                        mo.aomap,
                        mo.lightmap,
                        mo.emissivemap,
                        mo.bumpmap,
                        mo.normalmap,
                        mo.displacementmap,
                        mo.roughnessmap,
                        mo.metalnessmap,
                        mo.fog,
                        mo.lights,
                        { emissive: { value: new Zi(0) }, roughness: { value: 0.5 }, metalness: { value: 0.5 }, envMapIntensity: { value: 1 } },
                    ]),
                    vertexShader: fo.meshphysical_vert,
                    fragmentShader: fo.meshphysical_frag,
                },
                matcap: { uniforms: Qr([mo.common, mo.bumpmap, mo.normalmap, mo.displacementmap, mo.fog, { matcap: { value: null } }]), vertexShader: fo.meshmatcap_vert, fragmentShader: fo.meshmatcap_frag },
                points: { uniforms: Qr([mo.points, mo.fog]), vertexShader: fo.points_vert, fragmentShader: fo.points_frag },
                dashed: { uniforms: Qr([mo.common, mo.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: fo.linedashed_vert, fragmentShader: fo.linedashed_frag },
                depth: { uniforms: Qr([mo.common, mo.displacementmap]), vertexShader: fo.depth_vert, fragmentShader: fo.depth_frag },
                normal: { uniforms: Qr([mo.common, mo.bumpmap, mo.normalmap, mo.displacementmap, { opacity: { value: 1 } }]), vertexShader: fo.normal_vert, fragmentShader: fo.normal_frag },
                sprite: { uniforms: Qr([mo.sprite, mo.fog]), vertexShader: fo.sprite_vert, fragmentShader: fo.sprite_frag },
                background: { uniforms: { uvTransform: { value: new An() }, t2D: { value: null } }, vertexShader: fo.background_vert, fragmentShader: fo.background_frag },
                cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: fo.cube_vert, fragmentShader: fo.cube_frag },
                equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: fo.equirect_vert, fragmentShader: fo.equirect_frag },
                distanceRGBA: {
                    uniforms: Qr([mo.common, mo.displacementmap, { referencePosition: { value: new Sn() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]),
                    vertexShader: fo.distanceRGBA_vert,
                    fragmentShader: fo.distanceRGBA_frag,
                },
                shadow: { uniforms: Qr([mo.lights, mo.fog, { color: { value: new Zi(0) }, opacity: { value: 1 } }]), vertexShader: fo.shadow_vert, fragmentShader: fo.shadow_frag },
            };
        function go() {
            var e = null,
                t = !1,
                n = null;
            function i(r, o) {
                !1 !== t && (n(r, o), e.requestAnimationFrame(i));
            }
            return {
                start: function () {
                    !0 !== t && null !== n && (e.requestAnimationFrame(i), (t = !0));
                },
                stop: function () {
                    t = !1;
                },
                setAnimationLoop: function (e) {
                    n = e;
                },
                setContext: function (t) {
                    e = t;
                },
            };
        }
        function yo(e) {
            var t = new WeakMap();
            return {
                get: function (e) {
                    return e.isInterleavedBufferAttribute && (e = e.data), t.get(e);
                },
                remove: function (n) {
                    n.isInterleavedBufferAttribute && (n = n.data);
                    var i = t.get(n);
                    i && (e.deleteBuffer(i.buffer), t.delete(n));
                },
                update: function (n, i) {
                    n.isInterleavedBufferAttribute && (n = n.data);
                    var r = t.get(n);
                    void 0 === r
                        ? t.set(
                              n,
                              (function (t, n) {
                                  var i = t.array,
                                      r = t.usage,
                                      o = e.createBuffer();
                                  e.bindBuffer(n, o), e.bufferData(n, i, r), t.onUploadCallback();
                                  var a = 5126;
                                  return (
                                      i instanceof Float32Array
                                          ? (a = 5126)
                                          : i instanceof Float64Array
                                          ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.")
                                          : i instanceof Uint16Array
                                          ? (a = 5123)
                                          : i instanceof Int16Array
                                          ? (a = 5122)
                                          : i instanceof Uint32Array
                                          ? (a = 5125)
                                          : i instanceof Int32Array
                                          ? (a = 5124)
                                          : i instanceof Int8Array
                                          ? (a = 5120)
                                          : i instanceof Uint8Array && (a = 5121),
                                      { buffer: o, type: a, bytesPerElement: i.BYTES_PER_ELEMENT, version: t.version }
                                  );
                              })(n, i)
                          )
                        : r.version < n.version &&
                          (!(function (t, n, i) {
                              var r = n.array,
                                  o = n.updateRange;
                              e.bindBuffer(i, t), -1 === o.count ? e.bufferSubData(i, 0, r) : (e.bufferSubData(i, o.offset * r.BYTES_PER_ELEMENT, r.subarray(o.offset, o.offset + o.count)), (o.count = -1));
                          })(r.buffer, n, i),
                          (r.version = n.version));
                },
            };
        }
        function xo(e, t, n, i) {
            Yr.call(this), (this.type = "PlaneGeometry"), (this.parameters = { width: e, height: t, widthSegments: n, heightSegments: i }), this.fromBufferGeometry(new _o(e, t, n, i)), this.mergeVertices();
        }
        function _o(e, t, n, i) {
            Mr.call(this), (this.type = "PlaneBufferGeometry"), (this.parameters = { width: e, height: t, widthSegments: n, heightSegments: i });
            var r,
                o,
                a = (e = e || 1) / 2,
                s = (t = t || 1) / 2,
                c = Math.floor(n) || 1,
                l = Math.floor(i) || 1,
                u = c + 1,
                h = l + 1,
                d = e / c,
                p = t / l,
                f = [],
                m = [],
                v = [],
                g = [];
            for (o = 0; o < h; o++) {
                var y = o * p - s;
                for (r = 0; r < u; r++) {
                    var x = r * d - a;
                    m.push(x, -y, 0), v.push(0, 0, 1), g.push(r / c), g.push(1 - o / l);
                }
            }
            for (o = 0; o < l; o++)
                for (r = 0; r < c; r++) {
                    var _ = r + u * o,
                        b = r + u * (o + 1),
                        w = r + 1 + u * (o + 1),
                        M = r + 1 + u * o;
                    f.push(_, b, M), f.push(b, w, M);
                }
            this.setIndex(f), this.setAttribute("position", new dr(m, 3)), this.setAttribute("normal", new dr(v, 3)), this.setAttribute("uv", new dr(g, 2));
        }
        function bo(e, t, n, i) {
            var r,
                o,
                a = new Zi(0),
                s = 0,
                c = null,
                l = 0;
            function u(e, n) {
                t.buffers.color.setClear(e.r, e.g, e.b, n, i);
            }
            return {
                getClearColor: function () {
                    return a;
                },
                setClearColor: function (e, t) {
                    a.set(e), u(a, (s = void 0 !== t ? t : 1));
                },
                getClearAlpha: function () {
                    return s;
                },
                setClearAlpha: function (e) {
                    u(a, (s = e));
                },
                render: function (t, i, h, d) {
                    var p = i.background,
                        f = e.vr,
                        m = f.getSession && f.getSession();
                    if (
                        (m && "additive" === m.environmentBlendMode && (p = null),
                        null === p ? (u(a, s), (c = null), (l = 0)) : p && p.isColor && (u(p, 1), (d = !0), (c = null), (l = 0)),
                        (e.autoClear || d) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
                        p && (p.isCubeTexture || p.isWebGLRenderTargetCube))
                    ) {
                        void 0 === o &&
                            ((o = new Hr(
                                new Zr(1, 1, 1),
                                new no({ type: "BackgroundCubeMaterial", uniforms: Kr(vo.cube.uniforms), vertexShader: vo.cube.vertexShader, fragmentShader: vo.cube.fragmentShader, side: g, depthTest: !1, depthWrite: !1, fog: !1 })
                            )).geometry.deleteAttribute("normal"),
                            o.geometry.deleteAttribute("uv"),
                            (o.onBeforeRender = function (e, t, n) {
                                this.matrixWorld.copyPosition(n.matrixWorld);
                            }),
                            Object.defineProperty(o.material, "map", {
                                get: function () {
                                    return this.uniforms.tCube.value;
                                },
                            }),
                            n.update(o));
                        var y = p.isWebGLRenderTargetCube ? p.texture : p;
                        (o.material.uniforms.tCube.value = y),
                            (o.material.uniforms.tFlip.value = p.isWebGLRenderTargetCube ? 1 : -1),
                            (c === p && l === y.version) || ((o.material.needsUpdate = !0), (c = p), (l = y.version)),
                            t.unshift(o, o.geometry, o.material, 0, 0, null);
                    } else
                        p &&
                            p.isTexture &&
                            (void 0 === r &&
                                ((r = new Hr(
                                    new _o(2, 2),
                                    new no({
                                        type: "BackgroundMaterial",
                                        uniforms: Kr(vo.background.uniforms),
                                        vertexShader: vo.background.vertexShader,
                                        fragmentShader: vo.background.fragmentShader,
                                        side: v,
                                        depthTest: !1,
                                        depthWrite: !1,
                                        fog: !1,
                                    })
                                )).geometry.deleteAttribute("normal"),
                                Object.defineProperty(r.material, "map", {
                                    get: function () {
                                        return this.uniforms.t2D.value;
                                    },
                                }),
                                n.update(r)),
                            (r.material.uniforms.t2D.value = p),
                            !0 === p.matrixAutoUpdate && p.updateMatrix(),
                            r.material.uniforms.uvTransform.value.copy(p.matrix),
                            (c === p && l === p.version) || ((r.material.needsUpdate = !0), (c = p), (l = p.version)),
                            t.unshift(r, r.geometry, r.material, 0, 0, null));
                },
            };
        }
        function wo(e, t, n, i) {
            var r,
                o = i.isWebGL2;
            (this.setMode = function (e) {
                r = e;
            }),
                (this.render = function (t, i) {
                    e.drawArrays(r, t, i), n.update(i, r);
                }),
                (this.renderInstances = function (i, a, s, c) {
                    if (0 !== c) {
                        var l, u;
                        if (o) (l = e), (u = "drawArraysInstanced");
                        else if (((u = "drawArraysInstancedANGLE"), null === (l = t.get("ANGLE_instanced_arrays"))))
                            return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                        l[u](r, a, s, c), n.update(s, r, c);
                    }
                });
        }
        function Mo(e, t, n) {
            var i;
            function r(t) {
                if ("highp" === t) {
                    if (e.getShaderPrecisionFormat(35633, 36338).precision > 0 && e.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                    t = "mediump";
                }
                return "mediump" === t && e.getShaderPrecisionFormat(35633, 36337).precision > 0 && e.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
            }
            var o = ("undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext) || ("undefined" != typeof WebGL2ComputeRenderingContext && e instanceof WebGL2ComputeRenderingContext),
                a = void 0 !== n.precision ? n.precision : "highp",
                s = r(a);
            s !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", s, "instead."), (a = s));
            var c = !0 === n.logarithmicDepthBuffer,
                l = e.getParameter(34930),
                u = e.getParameter(35660),
                h = e.getParameter(3379),
                d = e.getParameter(34076),
                p = e.getParameter(34921),
                f = e.getParameter(36347),
                m = e.getParameter(36348),
                v = e.getParameter(36349),
                g = u > 0,
                y = o || !!t.get("OES_texture_float");
            return {
                isWebGL2: o,
                getMaxAnisotropy: function () {
                    if (void 0 !== i) return i;
                    var n = t.get("EXT_texture_filter_anisotropic");
                    return (i = null !== n ? e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0);
                },
                getMaxPrecision: r,
                precision: a,
                logarithmicDepthBuffer: c,
                maxTextures: l,
                maxVertexTextures: u,
                maxTextureSize: h,
                maxCubemapSize: d,
                maxAttributes: p,
                maxVertexUniforms: f,
                maxVaryings: m,
                maxFragmentUniforms: v,
                vertexTextures: g,
                floatFragmentTextures: y,
                floatVertexTextures: g && y,
                maxSamples: o ? e.getParameter(36183) : 0,
            };
        }
        function So() {
            var e = this,
                t = null,
                n = 0,
                i = !1,
                r = !1,
                o = new Ni(),
                a = new An(),
                s = { value: null, needsUpdate: !1 };
            function c() {
                s.value !== t && ((s.value = t), (s.needsUpdate = n > 0)), (e.numPlanes = n), (e.numIntersection = 0);
            }
            function l(t, n, i, r) {
                var c = null !== t ? t.length : 0,
                    l = null;
                if (0 !== c) {
                    if (((l = s.value), !0 !== r || null === l)) {
                        var u = i + 4 * c,
                            h = n.matrixWorldInverse;
                        a.getNormalMatrix(h), (null === l || l.length < u) && (l = new Float32Array(u));
                        for (var d = 0, p = i; d !== c; ++d, p += 4) o.copy(t[d]).applyMatrix4(h, a), o.normal.toArray(l, p), (l[p + 3] = o.constant);
                    }
                    (s.value = l), (s.needsUpdate = !0);
                }
                return (e.numPlanes = c), l;
            }
            (this.uniform = s),
                (this.numPlanes = 0),
                (this.numIntersection = 0),
                (this.init = function (e, r, o) {
                    var a = 0 !== e.length || r || 0 !== n || i;
                    return (i = r), (t = l(e, o, 0)), (n = e.length), a;
                }),
                (this.beginShadows = function () {
                    (r = !0), l(null);
                }),
                (this.endShadows = function () {
                    (r = !1), c();
                }),
                (this.setState = function (e, o, a, u, h, d) {
                    if (!i || null === e || 0 === e.length || (r && !a)) r ? l(null) : c();
                    else {
                        var p = r ? 0 : n,
                            f = 4 * p,
                            m = h.clippingState || null;
                        (s.value = m), (m = l(e, u, f, d));
                        for (var v = 0; v !== f; ++v) m[v] = t[v];
                        (h.clippingState = m), (this.numIntersection = o ? this.numPlanes : 0), (this.numPlanes += p);
                    }
                });
        }
        function Eo(e) {
            var t = {};
            return {
                get: function (n) {
                    if (void 0 !== t[n]) return t[n];
                    var i;
                    switch (n) {
                        case "WEBGL_depth_texture":
                            i = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                            break;
                        case "EXT_texture_filter_anisotropic":
                            i = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                            break;
                        case "WEBGL_compressed_texture_s3tc":
                            i = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                            break;
                        case "WEBGL_compressed_texture_pvrtc":
                            i = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                            break;
                        default:
                            i = e.getExtension(n);
                    }
                    return null === i && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), (t[n] = i), i;
                },
            };
        }
        function To(e, t, n) {
            var i = new WeakMap(),
                r = new WeakMap();
            function o(e) {
                var a = e.target,
                    s = i.get(a);
                for (var c in (null !== s.index && t.remove(s.index), s.attributes)) t.remove(s.attributes[c]);
                a.removeEventListener("dispose", o), i.delete(a);
                var l = r.get(s);
                l && (t.remove(l), r.delete(s)), n.memory.geometries--;
            }
            function a(e) {
                var n = [],
                    i = e.index,
                    o = e.attributes.position,
                    a = 0;
                if (null !== i) {
                    var s = i.array;
                    a = i.version;
                    for (var c = 0, l = s.length; c < l; c += 3) {
                        var u = s[c + 0],
                            h = s[c + 1],
                            d = s[c + 2];
                        n.push(u, h, h, d, d, u);
                    }
                } else {
                    s = o.array;
                    a = o.version;
                    for (c = 0, l = s.length / 3 - 1; c < l; c += 3) {
                        (u = c + 0), (h = c + 1), (d = c + 2);
                        n.push(u, h, h, d, d, u);
                    }
                }
                var p = new (mr(n) > 65535 ? hr : lr)(n, 1);
                (p.version = a), t.update(p, 34963);
                var f = r.get(e);
                f && t.remove(f), r.set(e, p);
            }
            return {
                get: function (e, t) {
                    var r = i.get(t);
                    return (
                        r ||
                        (t.addEventListener("dispose", o),
                        t.isBufferGeometry ? (r = t) : t.isGeometry && (void 0 === t._bufferGeometry && (t._bufferGeometry = new Mr().setFromObject(e)), (r = t._bufferGeometry)),
                        i.set(t, r),
                        n.memory.geometries++,
                        r)
                    );
                },
                update: function (e) {
                    var n = e.index,
                        i = e.attributes;
                    for (var r in (null !== n && t.update(n, 34963), i)) t.update(i[r], 34962);
                    var o = e.morphAttributes;
                    for (var r in o) for (var a = o[r], s = 0, c = a.length; s < c; s++) t.update(a[s], 34962);
                },
                getWireframeAttribute: function (e) {
                    var t = r.get(e);
                    if (t) {
                        var n = e.index;
                        null !== n && t.version < n.version && a(e);
                    } else a(e);
                    return r.get(e);
                },
            };
        }
        function Ao(e, t, n, i) {
            var r,
                o,
                a,
                s = i.isWebGL2;
            (this.setMode = function (e) {
                r = e;
            }),
                (this.setIndex = function (e) {
                    (o = e.type), (a = e.bytesPerElement);
                }),
                (this.render = function (t, i) {
                    e.drawElements(r, i, o, t * a), n.update(i, r);
                }),
                (this.renderInstances = function (i, c, l, u) {
                    if (0 !== u) {
                        var h, d;
                        if (s) (h = e), (d = "drawElementsInstanced");
                        else if (((d = "drawElementsInstancedANGLE"), null === (h = t.get("ANGLE_instanced_arrays"))))
                            return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                        h[d](r, l, o, c * a, u), n.update(l, r, u);
                    }
                });
        }
        function Lo(e) {
            var t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
            return {
                memory: { geometries: 0, textures: 0 },
                render: t,
                programs: null,
                autoReset: !0,
                reset: function () {
                    t.frame++, (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
                },
                update: function (e, n, i) {
                    switch (((i = i || 1), t.calls++, n)) {
                        case 4:
                            t.triangles += i * (e / 3);
                            break;
                        case 5:
                        case 6:
                            t.triangles += i * (e - 2);
                            break;
                        case 1:
                            t.lines += i * (e / 2);
                            break;
                        case 3:
                            t.lines += i * (e - 1);
                            break;
                        case 2:
                            t.lines += i * e;
                            break;
                        case 0:
                            t.points += i * e;
                            break;
                        default:
                            console.error("THREE.WebGLInfo: Unknown draw mode:", n);
                    }
                },
            };
        }
        function Co(e, t) {
            return Math.abs(t[1]) - Math.abs(e[1]);
        }
        function Ro(e) {
            var t = {},
                n = new Float32Array(8);
            return {
                update: function (i, r, o, a) {
                    var s = i.morphTargetInfluences,
                        c = s.length,
                        l = t[r.id];
                    if (void 0 === l) {
                        l = [];
                        for (var u = 0; u < c; u++) l[u] = [u, 0];
                        t[r.id] = l;
                    }
                    var h = o.morphTargets && r.morphAttributes.position,
                        d = o.morphNormals && r.morphAttributes.normal;
                    for (u = 0; u < c; u++) {
                        0 !== (f = l[u])[1] && (h && r.deleteAttribute("morphTarget" + u), d && r.deleteAttribute("morphNormal" + u));
                    }
                    for (u = 0; u < c; u++) {
                        ((f = l[u])[0] = u), (f[1] = s[u]);
                    }
                    l.sort(Co);
                    var p = 0;
                    for (u = 0; u < 8; u++) {
                        var f;
                        if ((f = l[u])) {
                            var m = f[0],
                                v = f[1];
                            if (v) {
                                h && r.setAttribute("morphTarget" + u, h[m]), d && r.setAttribute("morphNormal" + u, d[m]), (n[u] = v), (p += v);
                                continue;
                            }
                        }
                        n[u] = 0;
                    }
                    var g = r.morphTargetsRelative ? 1 : 1 - p;
                    a.getUniforms().setValue(e, "morphTargetBaseInfluence", g), a.getUniforms().setValue(e, "morphTargetInfluences", n);
                },
            };
        }
        function Po(e, t, n, i) {
            var r = {};
            return {
                update: function (e) {
                    var o = i.render.frame,
                        a = e.geometry,
                        s = t.get(e, a);
                    return r[s.id] !== o && (a.isGeometry && s.updateFromObject(e), t.update(s), (r[s.id] = o)), e.isInstancedMesh && n.update(e.instanceMatrix, 34962), s;
                },
                dispose: function () {
                    r = {};
                },
            };
        }
        function Oo(e, t, n, i, r, o, a, s, c, l) {
            (e = void 0 !== e ? e : []), (t = void 0 !== t ? t : ue), (a = void 0 !== a ? a : ke), Rn.call(this, e, t, n, i, r, o, a, s, c, l), (this.flipY = !1);
        }
        function Do(e, t, n, i) {
            Rn.call(this, null),
                (this.image = { data: e || null, width: t || 1, height: n || 1, depth: i || 1 }),
                (this.magFilter = _e),
                (this.minFilter = _e),
                (this.wrapR = ye),
                (this.generateMipmaps = !1),
                (this.flipY = !1),
                (this.needsUpdate = !0);
        }
        function Io(e, t, n, i) {
            Rn.call(this, null),
                (this.image = { data: e || null, width: t || 1, height: n || 1, depth: i || 1 }),
                (this.magFilter = _e),
                (this.minFilter = _e),
                (this.wrapR = ye),
                (this.generateMipmaps = !1),
                (this.flipY = !1),
                (this.needsUpdate = !0);
        }
        (vo.physical = {
            uniforms: Qr([
                vo.standard.uniforms,
                { transparency: { value: 0 }, clearcoat: { value: 0 }, clearcoatRoughness: { value: 0 }, sheen: { value: new Zi(0) }, clearcoatNormalScale: { value: new _n(1, 1) }, clearcoatNormalMap: { value: null } },
            ]),
            vertexShader: fo.meshphysical_vert,
            fragmentShader: fo.meshphysical_frag,
        }),
            (xo.prototype = Object.create(Yr.prototype)),
            (xo.prototype.constructor = xo),
            (_o.prototype = Object.create(Mr.prototype)),
            (_o.prototype.constructor = _o),
            (Oo.prototype = Object.create(Rn.prototype)),
            (Oo.prototype.constructor = Oo),
            (Oo.prototype.isCubeTexture = !0),
            Object.defineProperty(Oo.prototype, "images", {
                get: function () {
                    return this.image;
                },
                set: function (e) {
                    this.image = e;
                },
            }),
            (Do.prototype = Object.create(Rn.prototype)),
            (Do.prototype.constructor = Do),
            (Do.prototype.isDataTexture2DArray = !0),
            (Io.prototype = Object.create(Rn.prototype)),
            (Io.prototype.constructor = Io),
            (Io.prototype.isDataTexture3D = !0);
        var No = new Rn(),
            Uo = new Do(),
            Bo = new Io(),
            zo = new Oo(),
            Fo = [],
            Go = [],
            Ho = new Float32Array(16),
            Vo = new Float32Array(9),
            ko = new Float32Array(4);
        function jo(e, t, n) {
            var i = e[0];
            if (i <= 0 || i > 0) return e;
            var r = t * n,
                o = Fo[r];
            if ((void 0 === o && ((o = new Float32Array(r)), (Fo[r] = o)), 0 !== t)) {
                i.toArray(o, 0);
                for (var a = 1, s = 0; a !== t; ++a) (s += n), e[a].toArray(o, s);
            }
            return o;
        }
        function Wo(e, t) {
            if (e.length !== t.length) return !1;
            for (var n = 0, i = e.length; n < i; n++) if (e[n] !== t[n]) return !1;
            return !0;
        }
        function qo(e, t) {
            for (var n = 0, i = t.length; n < i; n++) e[n] = t[n];
        }
        function Xo(e, t) {
            var n = Go[t];
            void 0 === n && ((n = new Int32Array(t)), (Go[t] = n));
            for (var i = 0; i !== t; ++i) n[i] = e.allocateTextureUnit();
            return n;
        }
        function Yo(e, t) {
            var n = this.cache;
            n[0] !== t && (e.uniform1f(this.addr, t), (n[0] = t));
        }
        function Jo(e, t) {
            var n = this.cache;
            if (void 0 !== t.x) (n[0] === t.x && n[1] === t.y) || (e.uniform2f(this.addr, t.x, t.y), (n[0] = t.x), (n[1] = t.y));
            else {
                if (Wo(n, t)) return;
                e.uniform2fv(this.addr, t), qo(n, t);
            }
        }
        function Zo(e, t) {
            var n = this.cache;
            if (void 0 !== t.x) (n[0] === t.x && n[1] === t.y && n[2] === t.z) || (e.uniform3f(this.addr, t.x, t.y, t.z), (n[0] = t.x), (n[1] = t.y), (n[2] = t.z));
            else if (void 0 !== t.r) (n[0] === t.r && n[1] === t.g && n[2] === t.b) || (e.uniform3f(this.addr, t.r, t.g, t.b), (n[0] = t.r), (n[1] = t.g), (n[2] = t.b));
            else {
                if (Wo(n, t)) return;
                e.uniform3fv(this.addr, t), qo(n, t);
            }
        }
        function Ko(e, t) {
            var n = this.cache;
            if (void 0 !== t.x) (n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w) || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), (n[0] = t.x), (n[1] = t.y), (n[2] = t.z), (n[3] = t.w));
            else {
                if (Wo(n, t)) return;
                e.uniform4fv(this.addr, t), qo(n, t);
            }
        }
        function Qo(e, t) {
            var n = this.cache,
                i = t.elements;
            if (void 0 === i) {
                if (Wo(n, t)) return;
                e.uniformMatrix2fv(this.addr, !1, t), qo(n, t);
            } else {
                if (Wo(n, i)) return;
                ko.set(i), e.uniformMatrix2fv(this.addr, !1, ko), qo(n, i);
            }
        }
        function $o(e, t) {
            var n = this.cache,
                i = t.elements;
            if (void 0 === i) {
                if (Wo(n, t)) return;
                e.uniformMatrix3fv(this.addr, !1, t), qo(n, t);
            } else {
                if (Wo(n, i)) return;
                Vo.set(i), e.uniformMatrix3fv(this.addr, !1, Vo), qo(n, i);
            }
        }
        function ea(e, t) {
            var n = this.cache,
                i = t.elements;
            if (void 0 === i) {
                if (Wo(n, t)) return;
                e.uniformMatrix4fv(this.addr, !1, t), qo(n, t);
            } else {
                if (Wo(n, i)) return;
                Ho.set(i), e.uniformMatrix4fv(this.addr, !1, Ho), qo(n, i);
            }
        }
        function ta(e, t, n) {
            var i = this.cache,
                r = n.allocateTextureUnit();
            i[0] !== r && (e.uniform1i(this.addr, r), (i[0] = r)), n.safeSetTexture2D(t || No, r);
        }
        function na(e, t, n) {
            var i = this.cache,
                r = n.allocateTextureUnit();
            i[0] !== r && (e.uniform1i(this.addr, r), (i[0] = r)), n.setTexture2DArray(t || Uo, r);
        }
        function ia(e, t, n) {
            var i = this.cache,
                r = n.allocateTextureUnit();
            i[0] !== r && (e.uniform1i(this.addr, r), (i[0] = r)), n.setTexture3D(t || Bo, r);
        }
        function ra(e, t, n) {
            var i = this.cache,
                r = n.allocateTextureUnit();
            i[0] !== r && (e.uniform1i(this.addr, r), (i[0] = r)), n.safeSetTextureCube(t || zo, r);
        }
        function oa(e, t) {
            var n = this.cache;
            n[0] !== t && (e.uniform1i(this.addr, t), (n[0] = t));
        }
        function aa(e, t) {
            var n = this.cache;
            Wo(n, t) || (e.uniform2iv(this.addr, t), qo(n, t));
        }
        function sa(e, t) {
            var n = this.cache;
            Wo(n, t) || (e.uniform3iv(this.addr, t), qo(n, t));
        }
        function ca(e, t) {
            var n = this.cache;
            Wo(n, t) || (e.uniform4iv(this.addr, t), qo(n, t));
        }
        function la(e, t) {
            e.uniform1fv(this.addr, t);
        }
        function ua(e, t) {
            e.uniform1iv(this.addr, t);
        }
        function ha(e, t) {
            e.uniform2iv(this.addr, t);
        }
        function da(e, t) {
            e.uniform3iv(this.addr, t);
        }
        function pa(e, t) {
            e.uniform4iv(this.addr, t);
        }
        function fa(e, t) {
            var n = jo(t, this.size, 2);
            e.uniform2fv(this.addr, n);
        }
        function ma(e, t) {
            var n = jo(t, this.size, 3);
            e.uniform3fv(this.addr, n);
        }
        function va(e, t) {
            var n = jo(t, this.size, 4);
            e.uniform4fv(this.addr, n);
        }
        function ga(e, t) {
            var n = jo(t, this.size, 4);
            e.uniformMatrix2fv(this.addr, !1, n);
        }
        function ya(e, t) {
            var n = jo(t, this.size, 9);
            e.uniformMatrix3fv(this.addr, !1, n);
        }
        function xa(e, t) {
            var n = jo(t, this.size, 16);
            e.uniformMatrix4fv(this.addr, !1, n);
        }
        function _a(e, t, n) {
            var i = t.length,
                r = Xo(n, i);
            e.uniform1iv(this.addr, r);
            for (var o = 0; o !== i; ++o) n.safeSetTexture2D(t[o] || No, r[o]);
        }
        function ba(e, t, n) {
            var i = t.length,
                r = Xo(n, i);
            e.uniform1iv(this.addr, r);
            for (var o = 0; o !== i; ++o) n.safeSetTextureCube(t[o] || zo, r[o]);
        }
        function wa(e, t, n) {
            (this.id = e),
                (this.addr = n),
                (this.cache = []),
                (this.setValue = (function (e) {
                    switch (e) {
                        case 5126:
                            return Yo;
                        case 35664:
                            return Jo;
                        case 35665:
                            return Zo;
                        case 35666:
                            return Ko;
                        case 35674:
                            return Qo;
                        case 35675:
                            return $o;
                        case 35676:
                            return ea;
                        case 35678:
                        case 36198:
                            return ta;
                        case 35679:
                            return ia;
                        case 35680:
                            return ra;
                        case 36289:
                            return na;
                        case 5124:
                        case 35670:
                            return oa;
                        case 35667:
                        case 35671:
                            return aa;
                        case 35668:
                        case 35672:
                            return sa;
                        case 35669:
                        case 35673:
                            return ca;
                    }
                })(t.type));
        }
        function Ma(e, t, n) {
            (this.id = e),
                (this.addr = n),
                (this.cache = []),
                (this.size = t.size),
                (this.setValue = (function (e) {
                    switch (e) {
                        case 5126:
                            return la;
                        case 35664:
                            return fa;
                        case 35665:
                            return ma;
                        case 35666:
                            return va;
                        case 35674:
                            return ga;
                        case 35675:
                            return ya;
                        case 35676:
                            return xa;
                        case 35678:
                            return _a;
                        case 35680:
                            return ba;
                        case 5124:
                        case 35670:
                            return ua;
                        case 35667:
                        case 35671:
                            return ha;
                        case 35668:
                        case 35672:
                            return da;
                        case 35669:
                        case 35673:
                            return pa;
                    }
                })(t.type));
        }
        function Sa(e) {
            (this.id = e), (this.seq = []), (this.map = {});
        }
        (Ma.prototype.updateCache = function (e) {
            var t = this.cache;
            e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)), qo(t, e);
        }),
            (Sa.prototype.setValue = function (e, t, n) {
                for (var i = this.seq, r = 0, o = i.length; r !== o; ++r) {
                    var a = i[r];
                    a.setValue(e, t[a.id], n);
                }
            });
        var Ea = /([\w\d_]+)(\])?(\[|\.)?/g;
        function Ta(e, t) {
            e.seq.push(t), (e.map[t.id] = t);
        }
        function Aa(e, t, n) {
            var i = e.name,
                r = i.length;
            for (Ea.lastIndex = 0; ; ) {
                var o = Ea.exec(i),
                    a = Ea.lastIndex,
                    s = o[1],
                    c = "]" === o[2],
                    l = o[3];
                if ((c && (s |= 0), void 0 === l || ("[" === l && a + 2 === r))) {
                    Ta(n, void 0 === l ? new wa(s, e, t) : new Ma(s, e, t));
                    break;
                }
                var u = n.map[s];
                void 0 === u && Ta(n, (u = new Sa(s))), (n = u);
            }
        }
        function La(e, t) {
            (this.seq = []), (this.map = {});
            for (var n = e.getProgramParameter(t, 35718), i = 0; i < n; ++i) {
                var r = e.getActiveUniform(t, i);
                Aa(r, e.getUniformLocation(t, r.name), this);
            }
        }
        function Ca(e, t, n) {
            var i = e.createShader(t);
            return e.shaderSource(i, n), e.compileShader(i), i;
        }
        (La.prototype.setValue = function (e, t, n, i) {
            var r = this.map[t];
            void 0 !== r && r.setValue(e, n, i);
        }),
            (La.prototype.setOptional = function (e, t, n) {
                var i = t[n];
                void 0 !== i && this.setValue(e, n, i);
            }),
            (La.upload = function (e, t, n, i) {
                for (var r = 0, o = t.length; r !== o; ++r) {
                    var a = t[r],
                        s = n[a.id];
                    !1 !== s.needsUpdate && a.setValue(e, s.value, i);
                }
            }),
            (La.seqWithValue = function (e, t) {
                for (var n = [], i = 0, r = e.length; i !== r; ++i) {
                    var o = e[i];
                    o.id in t && n.push(o);
                }
                return n;
            });
        var Ra = 0;
        function Pa(e) {
            switch (e) {
                case Ot:
                    return ["Linear", "( value )"];
                case Dt:
                    return ["sRGB", "( value )"];
                case Nt:
                    return ["RGBE", "( value )"];
                case Bt:
                    return ["RGBM", "( value, 7.0 )"];
                case zt:
                    return ["RGBM", "( value, 16.0 )"];
                case Ft:
                    return ["RGBD", "( value, 256.0 )"];
                case It:
                    return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                case Ut:
                    return ["LogLuv", "( value )"];
                default:
                    throw new Error("unsupported encoding: " + e);
            }
        }
        function Oa(e, t, n) {
            var i = e.getShaderParameter(t, 35713),
                r = e.getShaderInfoLog(t).trim();
            return i && "" === r
                ? ""
                : "THREE.WebGLShader: gl.getShaderInfoLog() " +
                      n +
                      "\n" +
                      r +
                      (function (e) {
                          for (var t = e.split("\n"), n = 0; n < t.length; n++) t[n] = n + 1 + ": " + t[n];
                          return t.join("\n");
                      })(e.getShaderSource(t));
        }
        function Da(e, t) {
            var n = Pa(t);
            return "vec4 " + e + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }";
        }
        function Ia(e, t) {
            var n;
            switch (t) {
                case re:
                    n = "Linear";
                    break;
                case oe:
                    n = "Reinhard";
                    break;
                case ae:
                    n = "Uncharted2";
                    break;
                case se:
                    n = "OptimizedCineon";
                    break;
                case ce:
                    n = "ACESFilmic";
                    break;
                default:
                    throw new Error("unsupported toneMapping: " + t);
            }
            return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }";
        }
        function Na(e) {
            return "" !== e;
        }
        function Ua(e, t) {
            return e
                .replace(/NUM_DIR_LIGHTS/g, t.numDirLights)
                .replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights)
                .replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights)
                .replace(/NUM_POINT_LIGHTS/g, t.numPointLights)
                .replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
                .replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows)
                .replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows)
                .replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
        }
        function Ba(e, t) {
            return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection);
        }
        var za = /^[ \t]*#include +<([\w\d./]+)>/gm;
        function Fa(e) {
            return e.replace(za, Ga);
        }
        function Ga(e, t) {
            var n = fo[t];
            if (void 0 === n) throw new Error("Can not resolve #include <" + t + ">");
            return Fa(n);
        }
        var Ha = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
        function Va(e) {
            return e.replace(Ha, ka);
        }
        function ka(e, t, n, i) {
            for (var r = "", o = parseInt(t); o < parseInt(n); o++) r += i.replace(/\[ i \]/g, "[ " + o + " ]").replace(/UNROLLED_LOOP_INDEX/g, o);
            return r;
        }
        function ja(e) {
            var t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;";
            return "highp" === e.precision ? (t += "\n#define HIGH_PRECISION") : "mediump" === e.precision ? (t += "\n#define MEDIUM_PRECISION") : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t;
        }
        function Wa(e, t, n, i, r, o) {
            var a,
                s,
                c,
                l,
                u,
                h = e.getContext(),
                d = i.defines,
                v = r.vertexShader,
                g = r.fragmentShader,
                y = (function (e) {
                    var t = "SHADOWMAP_TYPE_BASIC";
                    return e.shadowMapType === p ? (t = "SHADOWMAP_TYPE_PCF") : e.shadowMapType === f ? (t = "SHADOWMAP_TYPE_PCF_SOFT") : e.shadowMapType === m && (t = "SHADOWMAP_TYPE_VSM"), t;
                })(o),
                x = (function (e) {
                    var t = "ENVMAP_TYPE_CUBE";
                    if (e.envMap)
                        switch (e.envMapMode) {
                            case ue:
                            case he:
                                t = "ENVMAP_TYPE_CUBE";
                                break;
                            case me:
                            case ve:
                                t = "ENVMAP_TYPE_CUBE_UV";
                                break;
                            case de:
                            case pe:
                                t = "ENVMAP_TYPE_EQUIREC";
                                break;
                            case fe:
                                t = "ENVMAP_TYPE_SPHERE";
                        }
                    return t;
                })(o),
                _ = (function (e) {
                    var t = "ENVMAP_MODE_REFLECTION";
                    if (e.envMap)
                        switch (e.envMapMode) {
                            case he:
                            case pe:
                                t = "ENVMAP_MODE_REFRACTION";
                        }
                    return t;
                })(o),
                b = (function (e) {
                    var t = "ENVMAP_BLENDING_MULTIPLY";
                    if (e.envMap)
                        switch (e.combine) {
                            case ee:
                                t = "ENVMAP_BLENDING_MULTIPLY";
                                break;
                            case te:
                                t = "ENVMAP_BLENDING_MIX";
                                break;
                            case ne:
                                t = "ENVMAP_BLENDING_ADD";
                        }
                    return t;
                })(o),
                w = e.gammaFactor > 0 ? e.gammaFactor : 1,
                M = o.isWebGL2
                    ? ""
                    : (function (e, t, n) {
                          return [
                              (e = e || {}).derivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "",
                              (e.fragDepth || t.logarithmicDepthBuffer) && n.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "",
                              e.drawBuffers && n.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "",
                              (e.shaderTextureLOD || t.envMap) && n.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : "",
                          ]
                              .filter(Na)
                              .join("\n");
                      })(i.extensions, o, t),
                S = (function (e) {
                    var t = [];
                    for (var n in e) {
                        var i = e[n];
                        !1 !== i && t.push("#define " + n + " " + i);
                    }
                    return t.join("\n");
                })(d),
                E = h.createProgram(),
                T = o.numMultiviewViews;
            if (
                (i.isRawShaderMaterial
                    ? ((a = [S].filter(Na).join("\n")).length > 0 && (a += "\n"), (s = [M, S].filter(Na).join("\n")).length > 0 && (s += "\n"))
                    : ((a = [
                          ja(o),
                          "#define SHADER_NAME " + r.name,
                          S,
                          o.instancing ? "#define USE_INSTANCING" : "",
                          o.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
                          "#define GAMMA_FACTOR " + w,
                          "#define MAX_BONES " + o.maxBones,
                          o.useFog && o.fog ? "#define USE_FOG" : "",
                          o.useFog && o.fogExp2 ? "#define FOG_EXP2" : "",
                          o.map ? "#define USE_MAP" : "",
                          o.envMap ? "#define USE_ENVMAP" : "",
                          o.envMap ? "#define " + _ : "",
                          o.lightMap ? "#define USE_LIGHTMAP" : "",
                          o.aoMap ? "#define USE_AOMAP" : "",
                          o.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
                          o.bumpMap ? "#define USE_BUMPMAP" : "",
                          o.normalMap ? "#define USE_NORMALMAP" : "",
                          o.normalMap && o.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
                          o.normalMap && o.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
                          o.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
                          o.displacementMap && o.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
                          o.specularMap ? "#define USE_SPECULARMAP" : "",
                          o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
                          o.metalnessMap ? "#define USE_METALNESSMAP" : "",
                          o.alphaMap ? "#define USE_ALPHAMAP" : "",
                          o.vertexTangents ? "#define USE_TANGENT" : "",
                          o.vertexColors ? "#define USE_COLOR" : "",
                          o.vertexUvs ? "#define USE_UV" : "",
                          o.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
                          o.flatShading ? "#define FLAT_SHADED" : "",
                          o.skinning ? "#define USE_SKINNING" : "",
                          o.useVertexTexture ? "#define BONE_TEXTURE" : "",
                          o.morphTargets ? "#define USE_MORPHTARGETS" : "",
                          o.morphNormals && !1 === o.flatShading ? "#define USE_MORPHNORMALS" : "",
                          o.doubleSided ? "#define DOUBLE_SIDED" : "",
                          o.flipSided ? "#define FLIP_SIDED" : "",
                          o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                          o.shadowMapEnabled ? "#define " + y : "",
                          o.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
                          o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
                          o.logarithmicDepthBuffer && (o.isWebGL2 || t.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "",
                          "uniform mat4 modelMatrix;",
                          "uniform mat4 modelViewMatrix;",
                          "uniform mat4 projectionMatrix;",
                          "uniform mat4 viewMatrix;",
                          "uniform mat3 normalMatrix;",
                          "uniform vec3 cameraPosition;",
                          "uniform bool isOrthographic;",
                          "#ifdef USE_INSTANCING",
                          " attribute mat4 instanceMatrix;",
                          "#endif",
                          "attribute vec3 position;",
                          "attribute vec3 normal;",
                          "attribute vec2 uv;",
                          "#ifdef USE_TANGENT",
                          "\tattribute vec4 tangent;",
                          "#endif",
                          "#ifdef USE_COLOR",
                          "\tattribute vec3 color;",
                          "#endif",
                          "#ifdef USE_MORPHTARGETS",
                          "\tattribute vec3 morphTarget0;",
                          "\tattribute vec3 morphTarget1;",
                          "\tattribute vec3 morphTarget2;",
                          "\tattribute vec3 morphTarget3;",
                          "\t#ifdef USE_MORPHNORMALS",
                          "\t\tattribute vec3 morphNormal0;",
                          "\t\tattribute vec3 morphNormal1;",
                          "\t\tattribute vec3 morphNormal2;",
                          "\t\tattribute vec3 morphNormal3;",
                          "\t#else",
                          "\t\tattribute vec3 morphTarget4;",
                          "\t\tattribute vec3 morphTarget5;",
                          "\t\tattribute vec3 morphTarget6;",
                          "\t\tattribute vec3 morphTarget7;",
                          "\t#endif",
                          "#endif",
                          "#ifdef USE_SKINNING",
                          "\tattribute vec4 skinIndex;",
                          "\tattribute vec4 skinWeight;",
                          "#endif",
                          "\n",
                      ]
                          .filter(Na)
                          .join("\n")),
                      (s = [
                          M,
                          ja(o),
                          "#define SHADER_NAME " + r.name,
                          S,
                          o.alphaTest ? "#define ALPHATEST " + o.alphaTest + (o.alphaTest % 1 ? "" : ".0") : "",
                          "#define GAMMA_FACTOR " + w,
                          o.useFog && o.fog ? "#define USE_FOG" : "",
                          o.useFog && o.fogExp2 ? "#define FOG_EXP2" : "",
                          o.map ? "#define USE_MAP" : "",
                          o.matcap ? "#define USE_MATCAP" : "",
                          o.envMap ? "#define USE_ENVMAP" : "",
                          o.envMap ? "#define " + x : "",
                          o.envMap ? "#define " + _ : "",
                          o.envMap ? "#define " + b : "",
                          o.lightMap ? "#define USE_LIGHTMAP" : "",
                          o.aoMap ? "#define USE_AOMAP" : "",
                          o.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
                          o.bumpMap ? "#define USE_BUMPMAP" : "",
                          o.normalMap ? "#define USE_NORMALMAP" : "",
                          o.normalMap && o.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
                          o.normalMap && o.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
                          o.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
                          o.specularMap ? "#define USE_SPECULARMAP" : "",
                          o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
                          o.metalnessMap ? "#define USE_METALNESSMAP" : "",
                          o.alphaMap ? "#define USE_ALPHAMAP" : "",
                          o.sheen ? "#define USE_SHEEN" : "",
                          o.vertexTangents ? "#define USE_TANGENT" : "",
                          o.vertexColors ? "#define USE_COLOR" : "",
                          o.vertexUvs ? "#define USE_UV" : "",
                          o.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
                          o.gradientMap ? "#define USE_GRADIENTMAP" : "",
                          o.flatShading ? "#define FLAT_SHADED" : "",
                          o.doubleSided ? "#define DOUBLE_SIDED" : "",
                          o.flipSided ? "#define FLIP_SIDED" : "",
                          o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                          o.shadowMapEnabled ? "#define " + y : "",
                          o.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
                          o.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
                          o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
                          o.logarithmicDepthBuffer && (o.isWebGL2 || t.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "",
                          ((i.extensions && i.extensions.shaderTextureLOD) || o.envMap) && (o.isWebGL2 || t.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "",
                          "uniform mat4 viewMatrix;",
                          "uniform vec3 cameraPosition;",
                          "uniform bool isOrthographic;",
                          o.toneMapping !== ie ? "#define TONE_MAPPING" : "",
                          o.toneMapping !== ie ? fo.tonemapping_pars_fragment : "",
                          o.toneMapping !== ie ? Ia("toneMapping", o.toneMapping) : "",
                          o.dithering ? "#define DITHERING" : "",
                          o.outputEncoding || o.mapEncoding || o.matcapEncoding || o.envMapEncoding || o.emissiveMapEncoding ? fo.encodings_pars_fragment : "",
                          o.mapEncoding ? Da("mapTexelToLinear", o.mapEncoding) : "",
                          o.matcapEncoding ? Da("matcapTexelToLinear", o.matcapEncoding) : "",
                          o.envMapEncoding ? Da("envMapTexelToLinear", o.envMapEncoding) : "",
                          o.emissiveMapEncoding ? Da("emissiveMapTexelToLinear", o.emissiveMapEncoding) : "",
                          o.outputEncoding ? ((c = "linearToOutputTexel"), (l = o.outputEncoding), (u = Pa(l)), "vec4 " + c + "( vec4 value ) { return LinearTo" + u[0] + u[1] + "; }") : "",
                          o.depthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "",
                          "\n",
                      ]
                          .filter(Na)
                          .join("\n"))),
                (v = Ba((v = Ua((v = Fa(v)), o)), o)),
                (g = Ba((g = Ua((g = Fa(g)), o)), o)),
                (v = Va(v)),
                (g = Va(g)),
                o.isWebGL2 && !i.isRawShaderMaterial)
            ) {
                var A = !1,
                    L = /^\s*#version\s+300\s+es\s*\n/;
                i.isShaderMaterial && null !== v.match(L) && null !== g.match(L) && ((A = !0), (v = v.replace(L, "")), (g = g.replace(L, ""))),
                    (a = ["#version 300 es\n", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + a),
                    (s =
                        [
                            "#version 300 es\n",
                            "#define varying in",
                            A ? "" : "out highp vec4 pc_fragColor;",
                            A ? "" : "#define gl_FragColor pc_fragColor",
                            "#define gl_FragDepthEXT gl_FragDepth",
                            "#define texture2D texture",
                            "#define textureCube texture",
                            "#define texture2DProj textureProj",
                            "#define texture2DLodEXT textureLod",
                            "#define texture2DProjLodEXT textureProjLod",
                            "#define textureCubeLodEXT textureLod",
                            "#define texture2DGradEXT textureGrad",
                            "#define texture2DProjGradEXT textureProjGrad",
                            "#define textureCubeGradEXT textureGrad",
                        ].join("\n") +
                        "\n" +
                        s),
                    T > 0 &&
                        ((a = (a = a.replace("#version 300 es\n", ["#version 300 es\n", "#extension GL_OVR_multiview2 : require", "layout(num_views = " + T + ") in;", "#define VIEW_ID gl_ViewID_OVR"].join("\n"))).replace(
                            ["uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;"].join("\n"),
                            [
                                "uniform mat4 modelViewMatrices[" + T + "];",
                                "uniform mat4 projectionMatrices[" + T + "];",
                                "uniform mat4 viewMatrices[" + T + "];",
                                "uniform mat3 normalMatrices[" + T + "];",
                                "#define modelViewMatrix modelViewMatrices[VIEW_ID]",
                                "#define projectionMatrix projectionMatrices[VIEW_ID]",
                                "#define viewMatrix viewMatrices[VIEW_ID]",
                                "#define normalMatrix normalMatrices[VIEW_ID]",
                            ].join("\n")
                        )),
                        (s = (s = s.replace("#version 300 es\n", ["#version 300 es\n", "#extension GL_OVR_multiview2 : require", "#define VIEW_ID gl_ViewID_OVR"].join("\n"))).replace(
                            "uniform mat4 viewMatrix;",
                            ["uniform mat4 viewMatrices[" + T + "];", "#define viewMatrix viewMatrices[VIEW_ID]"].join("\n")
                        )));
            }
            var C,
                R,
                P = s + g,
                O = Ca(h, 35633, a + v),
                D = Ca(h, 35632, P);
            if (
                (h.attachShader(E, O),
                h.attachShader(E, D),
                void 0 !== i.index0AttributeName ? h.bindAttribLocation(E, 0, i.index0AttributeName) : !0 === o.morphTargets && h.bindAttribLocation(E, 0, "position"),
                h.linkProgram(E),
                e.debug.checkShaderErrors)
            ) {
                var I = h.getProgramInfoLog(E).trim(),
                    N = h.getShaderInfoLog(O).trim(),
                    U = h.getShaderInfoLog(D).trim(),
                    B = !0,
                    z = !0;
                if (!1 === h.getProgramParameter(E, 35714)) {
                    B = !1;
                    var F = Oa(h, O, "vertex"),
                        G = Oa(h, D, "fragment");
                    console.error("THREE.WebGLProgram: shader error: ", h.getError(), "35715", h.getProgramParameter(E, 35715), "gl.getProgramInfoLog", I, F, G);
                } else "" !== I ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", I) : ("" !== N && "" !== U) || (z = !1);
                z && (this.diagnostics = { runnable: B, material: i, programLog: I, vertexShader: { log: N, prefix: a }, fragmentShader: { log: U, prefix: s } });
            }
            return (
                h.deleteShader(O),
                h.deleteShader(D),
                (this.getUniforms = function () {
                    return void 0 === C && (C = new La(h, E)), C;
                }),
                (this.getAttributes = function () {
                    return (
                        void 0 === R &&
                            (R = (function (e, t) {
                                for (var n = {}, i = e.getProgramParameter(t, 35721), r = 0; r < i; r++) {
                                    var o = e.getActiveAttrib(t, r).name;
                                    n[o] = e.getAttribLocation(t, o);
                                }
                                return n;
                            })(h, E)),
                        R
                    );
                }),
                (this.destroy = function () {
                    h.deleteProgram(E), (this.program = void 0);
                }),
                (this.name = r.name),
                (this.id = Ra++),
                (this.cacheKey = n),
                (this.usedTimes = 1),
                (this.program = E),
                (this.vertexShader = O),
                (this.fragmentShader = D),
                (this.numMultiviewViews = T),
                this
            );
        }
        function qa(e, t, n) {
            var i = [],
                r = n.isWebGL2,
                o = n.logarithmicDepthBuffer,
                a = n.floatVertexTextures,
                s = n.precision,
                c = n.maxVertexUniforms,
                l = n.vertexTextures,
                u = {
                    MeshDepthMaterial: "depth",
                    MeshDistanceMaterial: "distanceRGBA",
                    MeshNormalMaterial: "normal",
                    MeshBasicMaterial: "basic",
                    MeshLambertMaterial: "lambert",
                    MeshPhongMaterial: "phong",
                    MeshToonMaterial: "phong",
                    MeshStandardMaterial: "physical",
                    MeshPhysicalMaterial: "physical",
                    MeshMatcapMaterial: "matcap",
                    LineBasicMaterial: "basic",
                    LineDashedMaterial: "dashed",
                    PointsMaterial: "points",
                    ShadowMaterial: "shadow",
                    SpriteMaterial: "sprite",
                },
                h = [
                    "precision",
                    "isWebGL2",
                    "supportsVertexTextures",
                    "outputEncoding",
                    "instancing",
                    "numMultiviewViews",
                    "map",
                    "mapEncoding",
                    "matcap",
                    "matcapEncoding",
                    "envMap",
                    "envMapMode",
                    "envMapEncoding",
                    "envMapCubeUV",
                    "lightMap",
                    "aoMap",
                    "emissiveMap",
                    "emissiveMapEncoding",
                    "bumpMap",
                    "normalMap",
                    "objectSpaceNormalMap",
                    "tangentSpaceNormalMap",
                    "clearcoatNormalMap",
                    "displacementMap",
                    "specularMap",
                    "roughnessMap",
                    "metalnessMap",
                    "gradientMap",
                    "alphaMap",
                    "combine",
                    "vertexColors",
                    "vertexTangents",
                    "vertexUvs",
                    "uvsVertexOnly",
                    "fog",
                    "useFog",
                    "fogExp2",
                    "flatShading",
                    "sizeAttenuation",
                    "logarithmicDepthBuffer",
                    "skinning",
                    "maxBones",
                    "useVertexTexture",
                    "morphTargets",
                    "morphNormals",
                    "maxMorphTargets",
                    "maxMorphNormals",
                    "premultipliedAlpha",
                    "numDirLights",
                    "numPointLights",
                    "numSpotLights",
                    "numHemiLights",
                    "numRectAreaLights",
                    "numDirLightShadows",
                    "numPointLightShadows",
                    "numSpotLightShadows",
                    "shadowMapEnabled",
                    "shadowMapType",
                    "toneMapping",
                    "physicallyCorrectLights",
                    "alphaTest",
                    "doubleSided",
                    "flipSided",
                    "numClippingPlanes",
                    "numClipIntersection",
                    "depthPacking",
                    "dithering",
                    "sheen",
                ];
            function d(e, t) {
                var n;
                return (
                    e
                        ? e.isTexture
                            ? (n = e.encoding)
                            : e.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), (n = e.texture.encoding))
                        : (n = Ot),
                    n === Ot && t && (n = It),
                    n
                );
            }
            (this.getParameters = function (t, i, h, p, f, m, v) {
                var x = u[t.type],
                    _ = v.isSkinnedMesh
                        ? (function (e) {
                              var t = e.skeleton.bones;
                              if (a) return 1024;
                              var n = c,
                                  i = Math.floor((n - 20) / 4),
                                  r = Math.min(i, t.length);
                              return r < t.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + t.length + " bones. This GPU supports " + r + "."), 0) : r;
                          })(v)
                        : 0;
                null !== t.precision && (s = n.getMaxPrecision(t.precision)) !== t.precision && console.warn("THREE.WebGLProgram.getParameters:", t.precision, "not supported, using", s, "instead.");
                var b = e.getRenderTarget(),
                    w = b && b.isWebGLMultiviewRenderTarget ? b.numViews : 0;
                return {
                    isWebGL2: r,
                    shaderID: x,
                    precision: s,
                    instancing: !0 === v.isInstancedMesh,
                    supportsVertexTextures: l,
                    numMultiviewViews: w,
                    outputEncoding: d(b ? b.texture : null, e.gammaOutput),
                    map: !!t.map,
                    mapEncoding: d(t.map, e.gammaInput),
                    matcap: !!t.matcap,
                    matcapEncoding: d(t.matcap, e.gammaInput),
                    envMap: !!t.envMap,
                    envMapMode: t.envMap && t.envMap.mapping,
                    envMapEncoding: d(t.envMap, e.gammaInput),
                    envMapCubeUV: !!t.envMap && (t.envMap.mapping === me || t.envMap.mapping === ve),
                    lightMap: !!t.lightMap,
                    aoMap: !!t.aoMap,
                    emissiveMap: !!t.emissiveMap,
                    emissiveMapEncoding: d(t.emissiveMap, e.gammaInput),
                    bumpMap: !!t.bumpMap,
                    normalMap: !!t.normalMap,
                    objectSpaceNormalMap: t.normalMapType === kt,
                    tangentSpaceNormalMap: t.normalMapType === Vt,
                    clearcoatNormalMap: !!t.clearcoatNormalMap,
                    displacementMap: !!t.displacementMap,
                    roughnessMap: !!t.roughnessMap,
                    metalnessMap: !!t.metalnessMap,
                    specularMap: !!t.specularMap,
                    alphaMap: !!t.alphaMap,
                    gradientMap: !!t.gradientMap,
                    sheen: !!t.sheen,
                    combine: t.combine,
                    vertexTangents: t.normalMap && t.vertexTangents,
                    vertexColors: t.vertexColors,
                    vertexUvs: !!(t.map || t.bumpMap || t.normalMap || t.specularMap || t.alphaMap || t.emissiveMap || t.roughnessMap || t.metalnessMap || t.clearcoatNormalMap || t.displacementMap),
                    uvsVertexOnly: !(t.map || t.bumpMap || t.normalMap || t.specularMap || t.alphaMap || t.emissiveMap || t.roughnessMap || t.metalnessMap || t.clearcoatNormalMap || !t.displacementMap),
                    fog: !!p,
                    useFog: t.fog,
                    fogExp2: p && p.isFogExp2,
                    flatShading: t.flatShading,
                    sizeAttenuation: t.sizeAttenuation,
                    logarithmicDepthBuffer: o,
                    skinning: t.skinning && _ > 0,
                    maxBones: _,
                    useVertexTexture: a,
                    morphTargets: t.morphTargets,
                    morphNormals: t.morphNormals,
                    maxMorphTargets: e.maxMorphTargets,
                    maxMorphNormals: e.maxMorphNormals,
                    numDirLights: i.directional.length,
                    numPointLights: i.point.length,
                    numSpotLights: i.spot.length,
                    numRectAreaLights: i.rectArea.length,
                    numHemiLights: i.hemi.length,
                    numDirLightShadows: i.directionalShadowMap.length,
                    numPointLightShadows: i.pointShadowMap.length,
                    numSpotLightShadows: i.spotShadowMap.length,
                    numClippingPlanes: f,
                    numClipIntersection: m,
                    dithering: t.dithering,
                    shadowMapEnabled: e.shadowMap.enabled && h.length > 0,
                    shadowMapType: e.shadowMap.type,
                    toneMapping: t.toneMapped ? e.toneMapping : ie,
                    physicallyCorrectLights: e.physicallyCorrectLights,
                    premultipliedAlpha: t.premultipliedAlpha,
                    alphaTest: t.alphaTest,
                    doubleSided: t.side === y,
                    flipSided: t.side === g,
                    depthPacking: void 0 !== t.depthPacking && t.depthPacking,
                };
            }),
                (this.getProgramCacheKey = function (t, n) {
                    var i = [];
                    if ((n.shaderID ? i.push(n.shaderID) : (i.push(t.fragmentShader), i.push(t.vertexShader)), void 0 !== t.defines)) for (var r in t.defines) i.push(r), i.push(t.defines[r]);
                    for (var o = 0; o < h.length; o++) i.push(n[h[o]]);
                    return i.push(t.onBeforeCompile.toString()), i.push(e.gammaOutput), i.push(e.gammaFactor), i.join();
                }),
                (this.acquireProgram = function (n, r, o, a) {
                    for (var s, c = 0, l = i.length; c < l; c++) {
                        var u = i[c];
                        if (u.cacheKey === a) {
                            ++(s = u).usedTimes;
                            break;
                        }
                    }
                    return void 0 === s && ((s = new Wa(e, t, a, n, r, o)), i.push(s)), s;
                }),
                (this.releaseProgram = function (e) {
                    if (0 == --e.usedTimes) {
                        var t = i.indexOf(e);
                        (i[t] = i[i.length - 1]), i.pop(), e.destroy();
                    }
                }),
                (this.programs = i);
        }
        function Xa() {
            var e = new WeakMap();
            return {
                get: function (t) {
                    var n = e.get(t);
                    return void 0 === n && ((n = {}), e.set(t, n)), n;
                },
                remove: function (t) {
                    e.delete(t);
                },
                update: function (t, n, i) {
                    e.get(t)[n] = i;
                },
                dispose: function () {
                    e = new WeakMap();
                },
            };
        }
        function Ya(e, t) {
            return e.groupOrder !== t.groupOrder
                ? e.groupOrder - t.groupOrder
                : e.renderOrder !== t.renderOrder
                ? e.renderOrder - t.renderOrder
                : e.program !== t.program
                ? e.program.id - t.program.id
                : e.material.id !== t.material.id
                ? e.material.id - t.material.id
                : e.z !== t.z
                ? e.z - t.z
                : e.id - t.id;
        }
        function Ja(e, t) {
            return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id;
        }
        function Za() {
            var e = [],
                t = 0,
                n = [],
                i = [],
                r = { id: -1 };
            function o(n, i, o, a, s, c) {
                var l = e[t];
                return (
                    void 0 === l
                        ? ((l = { id: n.id, object: n, geometry: i, material: o, program: o.program || r, groupOrder: a, renderOrder: n.renderOrder, z: s, group: c }), (e[t] = l))
                        : ((l.id = n.id), (l.object = n), (l.geometry = i), (l.material = o), (l.program = o.program || r), (l.groupOrder = a), (l.renderOrder = n.renderOrder), (l.z = s), (l.group = c)),
                    t++,
                    l
                );
            }
            return {
                opaque: n,
                transparent: i,
                init: function () {
                    (t = 0), (n.length = 0), (i.length = 0);
                },
                push: function (e, t, r, a, s, c) {
                    var l = o(e, t, r, a, s, c);
                    (!0 === r.transparent ? i : n).push(l);
                },
                unshift: function (e, t, r, a, s, c) {
                    var l = o(e, t, r, a, s, c);
                    (!0 === r.transparent ? i : n).unshift(l);
                },
                sort: function () {
                    n.length > 1 && n.sort(Ya), i.length > 1 && i.sort(Ja);
                },
            };
        }
        function Ka() {
            var e = new WeakMap();
            function t(n) {
                var i = n.target;
                i.removeEventListener("dispose", t), e.delete(i);
            }
            return {
                get: function (n, i) {
                    var r,
                        o = e.get(n);
                    return void 0 === o ? ((r = new Za()), e.set(n, new WeakMap()), e.get(n).set(i, r), n.addEventListener("dispose", t)) : void 0 === (r = o.get(i)) && ((r = new Za()), o.set(i, r)), r;
                },
                dispose: function () {
                    e = new WeakMap();
                },
            };
        }
        function Qa() {
            var e = {};
            return {
                get: function (t) {
                    if (void 0 !== e[t.id]) return e[t.id];
                    var n;
                    switch (t.type) {
                        case "DirectionalLight":
                            n = { direction: new Sn(), color: new Zi(), shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new _n() };
                            break;
                        case "SpotLight":
                            n = { position: new Sn(), direction: new Sn(), color: new Zi(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0, shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new _n() };
                            break;
                        case "PointLight":
                            n = { position: new Sn(), color: new Zi(), distance: 0, decay: 0, shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new _n(), shadowCameraNear: 1, shadowCameraFar: 1e3 };
                            break;
                        case "HemisphereLight":
                            n = { direction: new Sn(), skyColor: new Zi(), groundColor: new Zi() };
                            break;
                        case "RectAreaLight":
                            n = { color: new Zi(), position: new Sn(), halfWidth: new Sn(), halfHeight: new Sn() };
                    }
                    return (e[t.id] = n), n;
                },
            };
        }
        var $a = 0;
        function es(e, t) {
            return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0);
        }
        function ts() {
            for (
                var e = new Qa(),
                    t = {
                        version: 0,
                        hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 },
                        ambient: [0, 0, 0],
                        probe: [],
                        directional: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotShadowMap: [],
                        spotShadowMatrix: [],
                        rectArea: [],
                        point: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: [],
                        numDirectionalShadows: -1,
                        numPointShadows: -1,
                        numSpotShadows: -1,
                    },
                    n = 0;
                n < 9;
                n++
            )
                t.probe.push(new Sn());
            var i = new Sn(),
                r = new Hn(),
                o = new Hn();
            return {
                setup: function (n, a, s) {
                    for (var c = 0, l = 0, u = 0, h = 0; h < 9; h++) t.probe[h].set(0, 0, 0);
                    var d = 0,
                        p = 0,
                        f = 0,
                        m = 0,
                        v = 0,
                        g = 0,
                        y = 0,
                        x = 0,
                        _ = s.matrixWorldInverse;
                    n.sort(es), (h = 0);
                    for (var b = n.length; h < b; h++) {
                        var w = n[h],
                            M = w.color,
                            S = w.intensity,
                            E = w.distance,
                            T = w.shadow && w.shadow.map ? w.shadow.map.texture : null;
                        if (w.isAmbientLight) (c += M.r * S), (l += M.g * S), (u += M.b * S);
                        else if (w.isLightProbe) for (var A = 0; A < 9; A++) t.probe[A].addScaledVector(w.sh.coefficients[A], S);
                        else if (w.isDirectionalLight) {
                            if (
                                ((C = e.get(w)).color.copy(w.color).multiplyScalar(w.intensity),
                                C.direction.setFromMatrixPosition(w.matrixWorld),
                                i.setFromMatrixPosition(w.target.matrixWorld),
                                C.direction.sub(i),
                                C.direction.transformDirection(_),
                                (C.shadow = w.castShadow),
                                w.castShadow)
                            ) {
                                var L = w.shadow;
                                (C.shadowBias = L.bias), (C.shadowRadius = L.radius), (C.shadowMapSize = L.mapSize), (t.directionalShadowMap[d] = T), (t.directionalShadowMatrix[d] = w.shadow.matrix), g++;
                            }
                            (t.directional[d] = C), d++;
                        } else if (w.isSpotLight) {
                            if (
                                ((C = e.get(w)).position.setFromMatrixPosition(w.matrixWorld),
                                C.position.applyMatrix4(_),
                                C.color.copy(M).multiplyScalar(S),
                                (C.distance = E),
                                C.direction.setFromMatrixPosition(w.matrixWorld),
                                i.setFromMatrixPosition(w.target.matrixWorld),
                                C.direction.sub(i),
                                C.direction.transformDirection(_),
                                (C.coneCos = Math.cos(w.angle)),
                                (C.penumbraCos = Math.cos(w.angle * (1 - w.penumbra))),
                                (C.decay = w.decay),
                                (C.shadow = w.castShadow),
                                w.castShadow)
                            ) {
                                L = w.shadow;
                                (C.shadowBias = L.bias), (C.shadowRadius = L.radius), (C.shadowMapSize = L.mapSize), (t.spotShadowMap[f] = T), (t.spotShadowMatrix[f] = w.shadow.matrix), x++;
                            }
                            (t.spot[f] = C), f++;
                        } else if (w.isRectAreaLight) {
                            (C = e.get(w)).color.copy(M).multiplyScalar(S),
                                C.position.setFromMatrixPosition(w.matrixWorld),
                                C.position.applyMatrix4(_),
                                o.identity(),
                                r.copy(w.matrixWorld),
                                r.premultiply(_),
                                o.extractRotation(r),
                                C.halfWidth.set(0.5 * w.width, 0, 0),
                                C.halfHeight.set(0, 0.5 * w.height, 0),
                                C.halfWidth.applyMatrix4(o),
                                C.halfHeight.applyMatrix4(o),
                                (t.rectArea[m] = C),
                                m++;
                        } else if (w.isPointLight) {
                            if (
                                ((C = e.get(w)).position.setFromMatrixPosition(w.matrixWorld),
                                C.position.applyMatrix4(_),
                                C.color.copy(w.color).multiplyScalar(w.intensity),
                                (C.distance = w.distance),
                                (C.decay = w.decay),
                                (C.shadow = w.castShadow),
                                w.castShadow)
                            ) {
                                L = w.shadow;
                                (C.shadowBias = L.bias),
                                    (C.shadowRadius = L.radius),
                                    (C.shadowMapSize = L.mapSize),
                                    (C.shadowCameraNear = L.camera.near),
                                    (C.shadowCameraFar = L.camera.far),
                                    (t.pointShadowMap[p] = T),
                                    (t.pointShadowMatrix[p] = w.shadow.matrix),
                                    y++;
                            }
                            (t.point[p] = C), p++;
                        } else if (w.isHemisphereLight) {
                            var C;
                            (C = e.get(w)).direction.setFromMatrixPosition(w.matrixWorld),
                                C.direction.transformDirection(_),
                                C.direction.normalize(),
                                C.skyColor.copy(w.color).multiplyScalar(S),
                                C.groundColor.copy(w.groundColor).multiplyScalar(S),
                                (t.hemi[v] = C),
                                v++;
                        }
                    }
                    (t.ambient[0] = c), (t.ambient[1] = l), (t.ambient[2] = u);
                    var R = t.hash;
                    (R.directionalLength === d && R.pointLength === p && R.spotLength === f && R.rectAreaLength === m && R.hemiLength === v && R.numDirectionalShadows === g && R.numPointShadows === y && R.numSpotShadows === x) ||
                        ((t.directional.length = d),
                        (t.spot.length = f),
                        (t.rectArea.length = m),
                        (t.point.length = p),
                        (t.hemi.length = v),
                        (t.directionalShadowMap.length = g),
                        (t.pointShadowMap.length = y),
                        (t.spotShadowMap.length = x),
                        (t.directionalShadowMatrix.length = g),
                        (t.pointShadowMatrix.length = y),
                        (t.spotShadowMatrix.length = x),
                        (R.directionalLength = d),
                        (R.pointLength = p),
                        (R.spotLength = f),
                        (R.rectAreaLength = m),
                        (R.hemiLength = v),
                        (R.numDirectionalShadows = g),
                        (R.numPointShadows = y),
                        (R.numSpotShadows = x),
                        (t.version = $a++));
                },
                state: t,
            };
        }
        function ns() {
            var e = new ts(),
                t = [],
                n = [];
            return {
                init: function () {
                    (t.length = 0), (n.length = 0);
                },
                state: { lightsArray: t, shadowsArray: n, lights: e },
                setupLights: function (i) {
                    e.setup(t, n, i);
                },
                pushLight: function (e) {
                    t.push(e);
                },
                pushShadow: function (e) {
                    n.push(e);
                },
            };
        }
        function is() {
            var e = new WeakMap();
            function t(n) {
                var i = n.target;
                i.removeEventListener("dispose", t), e.delete(i);
            }
            return {
                get: function (n, i) {
                    var r;
                    return !1 === e.has(n) ? ((r = new ns()), e.set(n, new WeakMap()), e.get(n).set(i, r), n.addEventListener("dispose", t)) : !1 === e.get(n).has(i) ? ((r = new ns()), e.get(n).set(i, r)) : (r = e.get(n).get(i)), r;
                },
                dispose: function () {
                    e = new WeakMap();
                },
            };
        }
        function rs(e) {
            nr.call(this),
                (this.type = "MeshDepthMaterial"),
                (this.depthPacking = Gt),
                (this.skinning = !1),
                (this.morphTargets = !1),
                (this.map = null),
                (this.alphaMap = null),
                (this.displacementMap = null),
                (this.displacementScale = 1),
                (this.displacementBias = 0),
                (this.wireframe = !1),
                (this.wireframeLinewidth = 1),
                (this.fog = !1),
                this.setValues(e);
        }
        function os(e) {
            nr.call(this),
                (this.type = "MeshDistanceMaterial"),
                (this.referencePosition = new Sn()),
                (this.nearDistance = 1),
                (this.farDistance = 1e3),
                (this.skinning = !1),
                (this.morphTargets = !1),
                (this.map = null),
                (this.alphaMap = null),
                (this.displacementMap = null),
                (this.displacementScale = 1),
                (this.displacementBias = 0),
                (this.fog = !1),
                this.setValues(e);
        }
        (rs.prototype = Object.create(nr.prototype)),
            (rs.prototype.constructor = rs),
            (rs.prototype.isMeshDepthMaterial = !0),
            (rs.prototype.copy = function (e) {
                return (
                    nr.prototype.copy.call(this, e),
                    (this.depthPacking = e.depthPacking),
                    (this.skinning = e.skinning),
                    (this.morphTargets = e.morphTargets),
                    (this.map = e.map),
                    (this.alphaMap = e.alphaMap),
                    (this.displacementMap = e.displacementMap),
                    (this.displacementScale = e.displacementScale),
                    (this.displacementBias = e.displacementBias),
                    (this.wireframe = e.wireframe),
                    (this.wireframeLinewidth = e.wireframeLinewidth),
                    this
                );
            }),
            (os.prototype = Object.create(nr.prototype)),
            (os.prototype.constructor = os),
            (os.prototype.isMeshDistanceMaterial = !0),
            (os.prototype.copy = function (e) {
                return (
                    nr.prototype.copy.call(this, e),
                    this.referencePosition.copy(e.referencePosition),
                    (this.nearDistance = e.nearDistance),
                    (this.farDistance = e.farDistance),
                    (this.skinning = e.skinning),
                    (this.morphTargets = e.morphTargets),
                    (this.map = e.map),
                    (this.alphaMap = e.alphaMap),
                    (this.displacementMap = e.displacementMap),
                    (this.displacementScale = e.displacementScale),
                    (this.displacementBias = e.displacementBias),
                    this
                );
            });
        var as =
                "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpack2HalfToRGBA ( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
            ss = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";
        function cs(e, t, n) {
            var i = new po(),
                r = new _n(),
                o = new _n(),
                a = new Pn(),
                s = [],
                c = [],
                l = {},
                u = { 0: g, 1: v, 2: y },
                h = new no({ defines: { SAMPLE_RATE: 0.25, HALF_SAMPLE_RATE: 1 / 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new _n() }, radius: { value: 4 } }, vertexShader: ss, fragmentShader: as }),
                d = h.clone();
            d.defines.HORIZONAL_PASS = 1;
            var f = new Mr();
            f.setAttribute("position", new rr(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
            var x = new Hr(f, h),
                _ = this;
            function b(n, i) {
                var r = t.update(x);
                (h.uniforms.shadow_pass.value = n.map.texture),
                    (h.uniforms.resolution.value = n.mapSize),
                    (h.uniforms.radius.value = n.radius),
                    e.setRenderTarget(n.mapPass),
                    e.clear(),
                    e.renderBufferDirect(i, null, r, h, x, null),
                    (d.uniforms.shadow_pass.value = n.mapPass.texture),
                    (d.uniforms.resolution.value = n.mapSize),
                    (d.uniforms.radius.value = n.radius),
                    e.setRenderTarget(n.map),
                    e.clear(),
                    e.renderBufferDirect(i, null, r, d, x, null);
            }
            function w(e, t, n) {
                var i = (e << 0) | (t << 1) | (n << 2),
                    r = s[i];
                return void 0 === r && ((r = new rs({ depthPacking: Ht, morphTargets: e, skinning: t })), (s[i] = r)), r;
            }
            function M(e, t, n) {
                var i = (e << 0) | (t << 1) | (n << 2),
                    r = c[i];
                return void 0 === r && ((r = new os({ morphTargets: e, skinning: t })), (c[i] = r)), r;
            }
            function E(t, n, i, r, o, a) {
                var s = t.geometry,
                    c = null,
                    h = w,
                    d = t.customDepthMaterial;
                if ((!0 === i.isPointLight && ((h = M), (d = t.customDistanceMaterial)), void 0 === d)) {
                    var p = !1;
                    !0 === n.morphTargets &&
                        (!0 === s.isBufferGeometry ? (p = s.morphAttributes && s.morphAttributes.position && s.morphAttributes.position.length > 0) : !0 === s.isGeometry && (p = s.morphTargets && s.morphTargets.length > 0));
                    var f = !1;
                    !0 === t.isSkinnedMesh && (!0 === n.skinning ? (f = !0) : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", t)), (c = h(p, f, !0 === t.isInstancedMesh));
                } else c = d;
                if (e.localClippingEnabled && !0 === n.clipShadows && 0 !== n.clippingPlanes.length) {
                    var v = c.uuid,
                        g = n.uuid,
                        y = l[v];
                    void 0 === y && ((y = {}), (l[v] = y));
                    var x = y[g];
                    void 0 === x && ((x = c.clone()), (y[g] = x)), (c = x);
                }
                return (
                    (c.visible = n.visible),
                    (c.wireframe = n.wireframe),
                    (c.side = a === m ? (null !== n.shadowSide ? n.shadowSide : n.side) : null !== n.shadowSide ? n.shadowSide : u[n.side]),
                    (c.clipShadows = n.clipShadows),
                    (c.clippingPlanes = n.clippingPlanes),
                    (c.clipIntersection = n.clipIntersection),
                    (c.wireframeLinewidth = n.wireframeLinewidth),
                    (c.linewidth = n.linewidth),
                    !0 === i.isPointLight && !0 === c.isMeshDistanceMaterial && (c.referencePosition.setFromMatrixPosition(i.matrixWorld), (c.nearDistance = r), (c.farDistance = o)),
                    c
                );
            }
            function T(n, r, o, a, s) {
                if (!1 !== n.visible) {
                    if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || (n.receiveShadow && s === m)) && (!n.frustumCulled || i.intersectsObject(n))) {
                        n.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, n.matrixWorld);
                        var c = t.update(n),
                            l = n.material;
                        if (Array.isArray(l))
                            for (var u = c.groups, h = 0, d = u.length; h < d; h++) {
                                var p = u[h],
                                    f = l[p.materialIndex];
                                if (f && f.visible) {
                                    var v = E(n, f, a, o.near, o.far, s);
                                    e.renderBufferDirect(o, null, c, v, n, p);
                                }
                            }
                        else if (l.visible) {
                            v = E(n, l, a, o.near, o.far, s);
                            e.renderBufferDirect(o, null, c, v, n, null);
                        }
                    }
                    for (var g = n.children, y = 0, x = g.length; y < x; y++) T(g[y], r, o, a, s);
                }
            }
            (this.enabled = !1),
                (this.autoUpdate = !0),
                (this.needsUpdate = !1),
                (this.type = p),
                (this.render = function (t, s, c) {
                    if (!1 !== _.enabled && (!1 !== _.autoUpdate || !1 !== _.needsUpdate) && 0 !== t.length) {
                        var l = e.getRenderTarget(),
                            u = e.getActiveCubeFace(),
                            h = e.getActiveMipmapLevel(),
                            d = e.state;
                        d.setBlending(S), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);
                        for (var p = 0, f = t.length; p < f; p++) {
                            var v = t[p],
                                g = v.shadow;
                            if (void 0 !== g) {
                                r.copy(g.mapSize);
                                var y = g.getFrameExtents();
                                if (
                                    (r.multiply(y),
                                    o.copy(g.mapSize),
                                    (r.x > n || r.y > n) &&
                                        (console.warn("THREE.WebGLShadowMap:", v, "has shadow exceeding max texture size, reducing"),
                                        r.x > n && ((o.x = Math.floor(n / y.x)), (r.x = o.x * y.x), (g.mapSize.x = o.x)),
                                        r.y > n && ((o.y = Math.floor(n / y.y)), (r.y = o.y * y.y), (g.mapSize.y = o.y))),
                                    null === g.map && !g.isPointLightShadow && this.type === m)
                                ) {
                                    var x = { minFilter: Ee, magFilter: Ee, format: je };
                                    (g.map = new On(r.x, r.y, x)), (g.map.texture.name = v.name + ".shadowMap"), (g.mapPass = new On(r.x, r.y, x)), g.camera.updateProjectionMatrix();
                                }
                                if (null === g.map) {
                                    x = { minFilter: _e, magFilter: _e, format: je };
                                    (g.map = new On(r.x, r.y, x)), (g.map.texture.name = v.name + ".shadowMap"), g.camera.updateProjectionMatrix();
                                }
                                e.setRenderTarget(g.map), e.clear();
                                for (var w = g.getViewportCount(), M = 0; M < w; M++) {
                                    var E = g.getViewport(M);
                                    a.set(o.x * E.x, o.y * E.y, o.x * E.z, o.y * E.w), d.viewport(a), g.updateMatrices(v, M), (i = g.getFrustum()), T(s, c, g.camera, v, this.type);
                                }
                                g.isPointLightShadow || this.type !== m || b(g, c);
                            } else console.warn("THREE.WebGLShadowMap:", v, "has no shadow.");
                        }
                        (_.needsUpdate = !1), e.setRenderTarget(l, u, h);
                    }
                });
        }
        function ls(e, t, n) {
            var i = n.isWebGL2;
            var r = new (function () {
                    var t = !1,
                        n = new Pn(),
                        i = null,
                        r = new Pn(0, 0, 0, 0);
                    return {
                        setMask: function (n) {
                            i === n || t || (e.colorMask(n, n, n, n), (i = n));
                        },
                        setLocked: function (e) {
                            t = e;
                        },
                        setClear: function (t, i, o, a, s) {
                            !0 === s && ((t *= a), (i *= a), (o *= a)), n.set(t, i, o, a), !1 === r.equals(n) && (e.clearColor(t, i, o, a), r.copy(n));
                        },
                        reset: function () {
                            (t = !1), (i = null), r.set(-1, 0, 0, 0);
                        },
                    };
                })(),
                o = new (function () {
                    var t = !1,
                        n = null,
                        i = null,
                        r = null;
                    return {
                        setTest: function (e) {
                            e ? xe(2929) : _e(2929);
                        },
                        setMask: function (i) {
                            n === i || t || (e.depthMask(i), (n = i));
                        },
                        setFunc: function (t) {
                            if (i !== t) {
                                if (t)
                                    switch (t) {
                                        case q:
                                            e.depthFunc(512);
                                            break;
                                        case X:
                                            e.depthFunc(519);
                                            break;
                                        case Y:
                                            e.depthFunc(513);
                                            break;
                                        case J:
                                            e.depthFunc(515);
                                            break;
                                        case Z:
                                            e.depthFunc(514);
                                            break;
                                        case K:
                                            e.depthFunc(518);
                                            break;
                                        case Q:
                                            e.depthFunc(516);
                                            break;
                                        case $:
                                            e.depthFunc(517);
                                            break;
                                        default:
                                            e.depthFunc(515);
                                    }
                                else e.depthFunc(515);
                                i = t;
                            }
                        },
                        setLocked: function (e) {
                            t = e;
                        },
                        setClear: function (t) {
                            r !== t && (e.clearDepth(t), (r = t));
                        },
                        reset: function () {
                            (t = !1), (n = null), (i = null), (r = null);
                        },
                    };
                })(),
                l = new (function () {
                    var t = !1,
                        n = null,
                        i = null,
                        r = null,
                        o = null,
                        a = null,
                        s = null,
                        c = null,
                        l = null;
                    return {
                        setTest: function (e) {
                            t || (e ? xe(2960) : _e(2960));
                        },
                        setMask: function (i) {
                            n === i || t || (e.stencilMask(i), (n = i));
                        },
                        setFunc: function (t, n, a) {
                            (i === t && r === n && o === a) || (e.stencilFunc(t, n, a), (i = t), (r = n), (o = a));
                        },
                        setOp: function (t, n, i) {
                            (a === t && s === n && c === i) || (e.stencilOp(t, n, i), (a = t), (s = n), (c = i));
                        },
                        setLocked: function (e) {
                            t = e;
                        },
                        setClear: function (t) {
                            l !== t && (e.clearStencil(t), (l = t));
                        },
                        reset: function () {
                            (t = !1), (n = null), (i = null), (r = null), (o = null), (a = null), (s = null), (c = null), (l = null);
                        },
                    };
                })(),
                u = e.getParameter(34921),
                h = new Uint8Array(u),
                d = new Uint8Array(u),
                p = new Uint8Array(u),
                f = {},
                m = null,
                v = null,
                x = null,
                _ = null,
                b = null,
                w = null,
                M = null,
                ee = null,
                te = null,
                ne = !1,
                ie = null,
                re = null,
                oe = null,
                ae = null,
                se = null,
                ce = e.getParameter(35661),
                le = !1,
                ue = 0,
                he = e.getParameter(7938);
            -1 !== he.indexOf("WebGL") ? ((ue = parseFloat(/^WebGL\ ([0-9])/.exec(he)[1])), (le = ue >= 1)) : -1 !== he.indexOf("OpenGL ES") && ((ue = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(he)[1])), (le = ue >= 2));
            var de = null,
                pe = {},
                fe = new Pn(),
                me = new Pn();
            function ve(t, n, i) {
                var r = new Uint8Array(4),
                    o = e.createTexture();
                e.bindTexture(t, o), e.texParameteri(t, 10241, 9728), e.texParameteri(t, 10240, 9728);
                for (var a = 0; a < i; a++) e.texImage2D(n + a, 0, 6408, 1, 1, 0, 6408, 5121, r);
                return o;
            }
            var ge = {};
            function ye(n, r) {
                ((h[n] = 1), 0 === d[n] && (e.enableVertexAttribArray(n), (d[n] = 1)), p[n] !== r) && ((i ? e : t.get("ANGLE_instanced_arrays"))[i ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), (p[n] = r));
            }
            function xe(t) {
                !0 !== f[t] && (e.enable(t), (f[t] = !0));
            }
            function _e(t) {
                !1 !== f[t] && (e.disable(t), (f[t] = !1));
            }
            (ge[3553] = ve(3553, 3553, 1)), (ge[34067] = ve(34067, 34069, 6)), r.setClear(0, 0, 0, 1), o.setClear(1), l.setClear(0), xe(2929), o.setFunc(J), Ee(!1), Te(s), xe(2884), Se(S);
            var be = { [R]: 32774, [P]: 32778, [O]: 32779 };
            if (i) (be[D] = 32775), (be[I] = 32776);
            else {
                var we = t.get("EXT_blend_minmax");
                null !== we && ((be[D] = we.MIN_EXT), (be[I] = we.MAX_EXT));
            }
            var Me = { [N]: 0, [U]: 1, [B]: 768, [F]: 770, [W]: 776, [k]: 774, [H]: 772, [z]: 769, [G]: 771, [j]: 775, [V]: 773 };
            function Se(t, n, i, r, o, a, s, c) {
                if (t !== S) {
                    if ((v || (xe(3042), (v = !0)), t === C))
                        (o = o || n),
                            (a = a || i),
                            (s = s || r),
                            (n === _ && o === M) || (e.blendEquationSeparate(be[n], be[o]), (_ = n), (M = o)),
                            (i === b && r === w && a === ee && s === te) || (e.blendFuncSeparate(Me[i], Me[r], Me[a], Me[s]), (b = i), (w = r), (ee = a), (te = s)),
                            (x = t),
                            (ne = null);
                    else if (t !== x || c !== ne) {
                        if (((_ === R && M === R) || (e.blendEquation(32774), (_ = R), (M = R)), c))
                            switch (t) {
                                case E:
                                    e.blendFuncSeparate(1, 771, 1, 771);
                                    break;
                                case T:
                                    e.blendFunc(1, 1);
                                    break;
                                case A:
                                    e.blendFuncSeparate(0, 0, 769, 771);
                                    break;
                                case L:
                                    e.blendFuncSeparate(0, 768, 0, 770);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", t);
                            }
                        else
                            switch (t) {
                                case E:
                                    e.blendFuncSeparate(770, 771, 1, 771);
                                    break;
                                case T:
                                    e.blendFunc(770, 1);
                                    break;
                                case A:
                                    e.blendFunc(0, 769);
                                    break;
                                case L:
                                    e.blendFunc(0, 768);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", t);
                            }
                        (b = null), (w = null), (ee = null), (te = null), (x = t), (ne = c);
                    }
                } else v && (_e(3042), (v = !1));
            }
            function Ee(t) {
                ie !== t && (t ? e.frontFace(2304) : e.frontFace(2305), (ie = t));
            }
            function Te(t) {
                t !== a ? (xe(2884), t !== re && (t === s ? e.cullFace(1029) : t === c ? e.cullFace(1028) : e.cullFace(1032))) : _e(2884), (re = t);
            }
            function Ae(t, n, i) {
                t ? (xe(32823), (ae === n && se === i) || (e.polygonOffset(n, i), (ae = n), (se = i))) : _e(32823);
            }
            function Le(t) {
                void 0 === t && (t = 33984 + ce - 1), de !== t && (e.activeTexture(t), (de = t));
            }
            return {
                buffers: { color: r, depth: o, stencil: l },
                initAttributes: function () {
                    for (var e = 0, t = h.length; e < t; e++) h[e] = 0;
                },
                enableAttribute: function (e) {
                    ye(e, 0);
                },
                enableAttributeAndDivisor: ye,
                disableUnusedAttributes: function () {
                    for (var t = 0, n = d.length; t !== n; ++t) d[t] !== h[t] && (e.disableVertexAttribArray(t), (d[t] = 0));
                },
                enable: xe,
                disable: _e,
                useProgram: function (t) {
                    return m !== t && (e.useProgram(t), (m = t), !0);
                },
                setBlending: Se,
                setMaterial: function (e, t) {
                    e.side === y ? _e(2884) : xe(2884);
                    var n = e.side === g;
                    t && (n = !n),
                        Ee(n),
                        e.blending === E && !1 === e.transparent ? Se(S) : Se(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha),
                        o.setFunc(e.depthFunc),
                        o.setTest(e.depthTest),
                        o.setMask(e.depthWrite),
                        r.setMask(e.colorWrite);
                    var i = e.stencilWrite;
                    l.setTest(i),
                        i && (l.setMask(e.stencilWriteMask), l.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), l.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)),
                        Ae(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits);
                },
                setFlipSided: Ee,
                setCullFace: Te,
                setLineWidth: function (t) {
                    t !== oe && (le && e.lineWidth(t), (oe = t));
                },
                setPolygonOffset: Ae,
                setScissorTest: function (e) {
                    e ? xe(3089) : _e(3089);
                },
                activeTexture: Le,
                bindTexture: function (t, n) {
                    null === de && Le();
                    var i = pe[de];
                    void 0 === i && ((i = { type: void 0, texture: void 0 }), (pe[de] = i)), (i.type === t && i.texture === n) || (e.bindTexture(t, n || ge[t]), (i.type = t), (i.texture = n));
                },
                unbindTexture: function () {
                    var t = pe[de];
                    void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null), (t.type = void 0), (t.texture = void 0));
                },
                compressedTexImage2D: function () {
                    try {
                        e.compressedTexImage2D.apply(e, arguments);
                    } catch (e) {
                        console.error("THREE.WebGLState:", e);
                    }
                },
                texImage2D: function () {
                    try {
                        e.texImage2D.apply(e, arguments);
                    } catch (e) {
                        console.error("THREE.WebGLState:", e);
                    }
                },
                texImage3D: function () {
                    try {
                        e.texImage3D.apply(e, arguments);
                    } catch (e) {
                        console.error("THREE.WebGLState:", e);
                    }
                },
                scissor: function (t) {
                    !1 === fe.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), fe.copy(t));
                },
                viewport: function (t) {
                    !1 === me.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), me.copy(t));
                },
                reset: function () {
                    for (var t = 0; t < d.length; t++) 1 === d[t] && (e.disableVertexAttribArray(t), (d[t] = 0));
                    (f = {}), (de = null), (pe = {}), (m = null), (x = null), (ie = null), (re = null), r.reset(), o.reset(), l.reset();
                },
            };
        }
        function us(e, t, n, i, r, o, a) {
            var s,
                c = r.isWebGL2,
                l = r.maxTextures,
                u = r.maxCubemapSize,
                h = r.maxTextureSize,
                d = r.maxSamples,
                p = new WeakMap(),
                f = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d");
            function m(e, t) {
                return f ? new OffscreenCanvas(e, t) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
            }
            function v(e, t, n, i) {
                var r = 1;
                if (((e.width > i || e.height > i) && (r = i / Math.max(e.width, e.height)), r < 1 || !0 === t)) {
                    if (
                        ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement) ||
                        ("undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement) ||
                        ("undefined" != typeof ImageBitmap && e instanceof ImageBitmap)
                    ) {
                        var o = t ? xn.floorPowerOfTwo : Math.floor,
                            a = o(r * e.width),
                            c = o(r * e.height);
                        void 0 === s && (s = m(a, c));
                        var l = n ? m(a, c) : s;
                        return (l.width = a), (l.height = c), l.getContext("2d").drawImage(e, 0, 0, a, c), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + a + "x" + c + ")."), l;
                    }
                    return "data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."), e;
                }
                return e;
            }
            function g(e) {
                return xn.isPowerOfTwo(e.width) && xn.isPowerOfTwo(e.height);
            }
            function y(e, t) {
                return e.generateMipmaps && t && e.minFilter !== _e && e.minFilter !== Ee;
            }
            function x(t, n, r, o) {
                e.generateMipmap(t), (i.get(n).__maxMipLevel = Math.log(Math.max(r, o)) * Math.LOG2E);
            }
            function _(e, n) {
                if (!1 === c) return e;
                var i = e;
                return (
                    6403 === e && (5126 === n && (i = 33326), 5131 === n && (i = 33325), 5121 === n && (i = 33321)),
                    6407 === e && (5126 === n && (i = 34837), 5131 === n && (i = 34843), 5121 === n && (i = 32849)),
                    6408 === e && (5126 === n && (i = 34836), 5131 === n && (i = 34842), 5121 === n && (i = 32856)),
                    33325 === i || 33326 === i || 34842 === i || 34836 === i
                        ? t.get("EXT_color_buffer_float")
                        : (34843 !== i && 34837 !== i) || console.warn("THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead."),
                    i
                );
            }
            function b(e) {
                return e === _e || e === be || e === Me ? 9728 : 9729;
            }
            function w(t) {
                var n = t.target;
                n.removeEventListener("dispose", w),
                    (function (t) {
                        var n = i.get(t);
                        if (void 0 === n.__webglInit) return;
                        e.deleteTexture(n.__webglTexture), i.remove(t);
                    })(n),
                    n.isVideoTexture && p.delete(n),
                    a.memory.textures--;
            }
            function M(t) {
                var n = t.target;
                n.removeEventListener("dispose", M),
                    (function (t) {
                        var n = i.get(t),
                            r = i.get(t.texture);
                        if (!t) return;
                        void 0 !== r.__webglTexture && e.deleteTexture(r.__webglTexture);
                        t.depthTexture && t.depthTexture.dispose();
                        if (t.isWebGLRenderTargetCube) for (var o = 0; o < 6; o++) e.deleteFramebuffer(n.__webglFramebuffer[o]), n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer[o]);
                        else e.deleteFramebuffer(n.__webglFramebuffer), n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer);
                        if (t.isWebGLMultiviewRenderTarget) {
                            e.deleteTexture(n.__webglColorTexture), e.deleteTexture(n.__webglDepthStencilTexture), (a.memory.textures -= 2);
                            o = 0;
                            for (var s = n.__webglViewFramebuffers.length; o < s; o++) e.deleteFramebuffer(n.__webglViewFramebuffers[o]);
                        }
                        i.remove(t.texture), i.remove(t);
                    })(n),
                    a.memory.textures--;
            }
            var S = 0;
            function E(e, t) {
                var r = i.get(e);
                if (
                    (e.isVideoTexture &&
                        (function (e) {
                            var t = a.render.frame;
                            p.get(e) !== t && (p.set(e, t), e.update());
                        })(e),
                    e.version > 0 && r.__version !== e.version)
                ) {
                    var o = e.image;
                    if (void 0 === o) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                    else {
                        if (!1 !== o.complete) return void O(r, e, t);
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
                    }
                }
                n.activeTexture(33984 + t), n.bindTexture(3553, r.__webglTexture);
            }
            function T(t, r) {
                if (6 === t.image.length) {
                    var a = i.get(t);
                    if (t.version > 0 && a.__version !== t.version) {
                        P(a, t), n.activeTexture(33984 + r), n.bindTexture(34067, a.__webglTexture), e.pixelStorei(37440, t.flipY);
                        for (var s = t && t.isCompressedTexture, l = t.image[0] && t.image[0].isDataTexture, h = [], d = 0; d < 6; d++) h[d] = s || l ? (l ? t.image[d].image : t.image[d]) : v(t.image[d], !1, !0, u);
                        var p,
                            f = h[0],
                            m = g(f) || c,
                            b = o.convert(t.format),
                            w = o.convert(t.type),
                            M = _(b, w);
                        if ((R(34067, t, m), s)) {
                            for (d = 0; d < 6; d++) {
                                p = h[d].mipmaps;
                                for (var S = 0; S < p.length; S++) {
                                    var E = p[S];
                                    t.format !== je && t.format !== ke
                                        ? null !== b
                                            ? n.compressedTexImage2D(34069 + d, S, M, E.width, E.height, 0, E.data)
                                            : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()")
                                        : n.texImage2D(34069 + d, S, M, E.width, E.height, 0, b, w, E.data);
                                }
                            }
                            a.__maxMipLevel = p.length - 1;
                        } else {
                            p = t.mipmaps;
                            for (d = 0; d < 6; d++)
                                if (l) {
                                    n.texImage2D(34069 + d, 0, M, h[d].width, h[d].height, 0, b, w, h[d].data);
                                    for (S = 0; S < p.length; S++) {
                                        var T = (E = p[S]).image[d].image;
                                        n.texImage2D(34069 + d, S + 1, M, T.width, T.height, 0, b, w, T.data);
                                    }
                                } else {
                                    n.texImage2D(34069 + d, 0, M, b, w, h[d]);
                                    for (S = 0; S < p.length; S++) {
                                        E = p[S];
                                        n.texImage2D(34069 + d, S + 1, M, b, w, E.image[d]);
                                    }
                                }
                            a.__maxMipLevel = p.length;
                        }
                        y(t, m) && x(34067, t, f.width, f.height), (a.__version = t.version), t.onUpdate && t.onUpdate(t);
                    } else n.activeTexture(33984 + r), n.bindTexture(34067, a.__webglTexture);
                }
            }
            function A(e, t) {
                n.activeTexture(33984 + t), n.bindTexture(34067, i.get(e).__webglTexture);
            }
            var L = { [ge]: 10497, [ye]: 33071, [xe]: 33648 },
                C = { [_e]: 9728, [be]: 9984, [Me]: 9986, [Ee]: 9729, [Te]: 9985, [Le]: 9987 };
            function R(n, o, a) {
                a
                    ? (e.texParameteri(n, 10242, L[o.wrapS]),
                      e.texParameteri(n, 10243, L[o.wrapT]),
                      (32879 !== n && 35866 !== n) || e.texParameteri(n, 32882, L[o.wrapR]),
                      e.texParameteri(n, 10240, C[o.magFilter]),
                      e.texParameteri(n, 10241, C[o.minFilter]))
                    : (e.texParameteri(n, 10242, 33071),
                      e.texParameteri(n, 10243, 33071),
                      (32879 !== n && 35866 !== n) || e.texParameteri(n, 32882, 33071),
                      (o.wrapS === ye && o.wrapT === ye) || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
                      e.texParameteri(n, 10240, b(o.magFilter)),
                      e.texParameteri(n, 10241, b(o.minFilter)),
                      o.minFilter !== _e && o.minFilter !== Ee && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));
                var s = t.get("EXT_texture_filter_anisotropic");
                if (s) {
                    if (o.type === Ue && null === t.get("OES_texture_float_linear")) return;
                    if (o.type === Be && null === (c || t.get("OES_texture_half_float_linear"))) return;
                    (o.anisotropy > 1 || i.get(o).__currentAnisotropy) && (e.texParameterf(n, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o.anisotropy, r.getMaxAnisotropy())), (i.get(o).__currentAnisotropy = o.anisotropy));
                }
            }
            function P(t, n) {
                void 0 === t.__webglInit && ((t.__webglInit = !0), n.addEventListener("dispose", w), (t.__webglTexture = e.createTexture()), a.memory.textures++);
            }
            function O(t, i, r) {
                var a = 3553;
                i.isDataTexture2DArray && (a = 35866),
                    i.isDataTexture3D && (a = 32879),
                    P(t, i),
                    n.activeTexture(33984 + r),
                    n.bindTexture(a, t.__webglTexture),
                    e.pixelStorei(37440, i.flipY),
                    e.pixelStorei(37441, i.premultiplyAlpha),
                    e.pixelStorei(3317, i.unpackAlignment);
                var s =
                        (function (e) {
                            return !c && (e.wrapS !== ye || e.wrapT !== ye || (e.minFilter !== _e && e.minFilter !== Ee));
                        })(i) && !1 === g(i.image),
                    l = v(i.image, s, !1, h),
                    u = g(l) || c,
                    d = o.convert(i.format),
                    p = o.convert(i.type),
                    f = _(d, p);
                R(a, i, u);
                var m,
                    b = i.mipmaps;
                if (i.isDepthTexture) {
                    if (((f = 6402), i.type === Ue)) {
                        if (!1 === c) throw new Error("Float Depth Texture only supported in WebGL2.0");
                        f = 36012;
                    } else c && (f = 33189);
                    i.format === Ye && 6402 === f && i.type !== De && i.type !== Ne && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), (i.type = De), (p = o.convert(i.type))),
                        i.format === Je && ((f = 34041), i.type !== He && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), (i.type = He), (p = o.convert(i.type)))),
                        n.texImage2D(3553, 0, f, l.width, l.height, 0, d, p, null);
                } else if (i.isDataTexture)
                    if (b.length > 0 && u) {
                        for (var w = 0, M = b.length; w < M; w++) (m = b[w]), n.texImage2D(3553, w, f, m.width, m.height, 0, d, p, m.data);
                        (i.generateMipmaps = !1), (t.__maxMipLevel = b.length - 1);
                    } else n.texImage2D(3553, 0, f, l.width, l.height, 0, d, p, l.data), (t.__maxMipLevel = 0);
                else if (i.isCompressedTexture) {
                    for (w = 0, M = b.length; w < M; w++)
                        (m = b[w]),
                            i.format !== je && i.format !== ke
                                ? null !== d
                                    ? n.compressedTexImage2D(3553, w, f, m.width, m.height, 0, m.data)
                                    : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()")
                                : n.texImage2D(3553, w, f, m.width, m.height, 0, d, p, m.data);
                    t.__maxMipLevel = b.length - 1;
                } else if (i.isDataTexture2DArray) n.texImage3D(35866, 0, f, l.width, l.height, l.depth, 0, d, p, l.data), (t.__maxMipLevel = 0);
                else if (i.isDataTexture3D) n.texImage3D(32879, 0, f, l.width, l.height, l.depth, 0, d, p, l.data), (t.__maxMipLevel = 0);
                else if (b.length > 0 && u) {
                    for (w = 0, M = b.length; w < M; w++) (m = b[w]), n.texImage2D(3553, w, f, d, p, m);
                    (i.generateMipmaps = !1), (t.__maxMipLevel = b.length - 1);
                } else n.texImage2D(3553, 0, f, d, p, l), (t.__maxMipLevel = 0);
                y(i, u) && x(3553, i, l.width, l.height), (t.__version = i.version), i.onUpdate && i.onUpdate(i);
            }
            function D(t, r, a, s) {
                var c = o.convert(r.texture.format),
                    l = o.convert(r.texture.type),
                    u = _(c, l);
                n.texImage2D(s, 0, u, r.width, r.height, 0, c, l, null), e.bindFramebuffer(36160, t), e.framebufferTexture2D(36160, a, s, i.get(r.texture).__webglTexture, 0), e.bindFramebuffer(36160, null);
            }
            function I(t, n, i) {
                if ((e.bindRenderbuffer(36161, t), n.depthBuffer && !n.stencilBuffer)) {
                    if (i) {
                        var r = U(n);
                        e.renderbufferStorageMultisample(36161, r, 33189, n.width, n.height);
                    } else e.renderbufferStorage(36161, 33189, n.width, n.height);
                    e.framebufferRenderbuffer(36160, 36096, 36161, t);
                } else if (n.depthBuffer && n.stencilBuffer) {
                    if (i) {
                        r = U(n);
                        e.renderbufferStorageMultisample(36161, r, 35056, n.width, n.height);
                    } else e.renderbufferStorage(36161, 34041, n.width, n.height);
                    e.framebufferRenderbuffer(36160, 33306, 36161, t);
                } else {
                    var a = _(o.convert(n.texture.format), o.convert(n.texture.type));
                    if (i) {
                        r = U(n);
                        e.renderbufferStorageMultisample(36161, r, a, n.width, n.height);
                    } else e.renderbufferStorage(36161, a, n.width, n.height);
                }
                e.bindRenderbuffer(36161, null);
            }
            function N(t) {
                var n = i.get(t),
                    r = !0 === t.isWebGLRenderTargetCube;
                if (t.depthTexture) {
                    if (r) throw new Error("target.depthTexture not supported in Cube render targets");
                    !(function (t, n) {
                        if (n && n.isWebGLRenderTargetCube) throw new Error("Depth Texture with cube render targets is not supported");
                        if ((e.bindFramebuffer(36160, t), !n.depthTexture || !n.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        (i.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height) ||
                            ((n.depthTexture.image.width = n.width), (n.depthTexture.image.height = n.height), (n.depthTexture.needsUpdate = !0)),
                            E(n.depthTexture, 0);
                        var r = i.get(n.depthTexture).__webglTexture;
                        if (n.depthTexture.format === Ye) e.framebufferTexture2D(36160, 36096, 3553, r, 0);
                        else {
                            if (n.depthTexture.format !== Je) throw new Error("Unknown depthTexture format");
                            e.framebufferTexture2D(36160, 33306, 3553, r, 0);
                        }
                    })(n.__webglFramebuffer, t);
                } else if (r) {
                    n.__webglDepthbuffer = [];
                    for (var o = 0; o < 6; o++) e.bindFramebuffer(36160, n.__webglFramebuffer[o]), (n.__webglDepthbuffer[o] = e.createRenderbuffer()), I(n.__webglDepthbuffer[o], t);
                } else e.bindFramebuffer(36160, n.__webglFramebuffer), (n.__webglDepthbuffer = e.createRenderbuffer()), I(n.__webglDepthbuffer, t);
                e.bindFramebuffer(36160, null);
            }
            function U(e) {
                return c && e.isWebGLMultisampleRenderTarget ? Math.min(d, e.samples) : 0;
            }
            var B = !1,
                z = !1;
            (this.allocateTextureUnit = function () {
                var e = S;
                return e >= l && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + l), (S += 1), e;
            }),
                (this.resetTextureUnits = function () {
                    S = 0;
                }),
                (this.setTexture2D = E),
                (this.setTexture2DArray = function (e, t) {
                    var r = i.get(e);
                    e.version > 0 && r.__version !== e.version ? O(r, e, t) : (n.activeTexture(33984 + t), n.bindTexture(35866, r.__webglTexture));
                }),
                (this.setTexture3D = function (e, t) {
                    var r = i.get(e);
                    e.version > 0 && r.__version !== e.version ? O(r, e, t) : (n.activeTexture(33984 + t), n.bindTexture(32879, r.__webglTexture));
                }),
                (this.setTextureCube = T),
                (this.setTextureCubeDynamic = A),
                (this.setupRenderTarget = function (r) {
                    var s = i.get(r),
                        l = i.get(r.texture);
                    r.addEventListener("dispose", M), (l.__webglTexture = e.createTexture()), a.memory.textures++;
                    var u = !0 === r.isWebGLRenderTargetCube,
                        h = !0 === r.isWebGLMultisampleRenderTarget,
                        d = !0 === r.isWebGLMultiviewRenderTarget,
                        p = g(r) || c;
                    if (u) {
                        s.__webglFramebuffer = [];
                        for (var f = 0; f < 6; f++) s.__webglFramebuffer[f] = e.createFramebuffer();
                    } else if (((s.__webglFramebuffer = e.createFramebuffer()), h))
                        if (c) {
                            (s.__webglMultisampledFramebuffer = e.createFramebuffer()), (s.__webglColorRenderbuffer = e.createRenderbuffer()), e.bindRenderbuffer(36161, s.__webglColorRenderbuffer);
                            var m = _(o.convert(r.texture.format), o.convert(r.texture.type)),
                                v = U(r);
                            e.renderbufferStorageMultisample(36161, v, m, r.width, r.height),
                                e.bindFramebuffer(36160, s.__webglMultisampledFramebuffer),
                                e.framebufferRenderbuffer(36160, 36064, 36161, s.__webglColorRenderbuffer),
                                e.bindRenderbuffer(36161, null),
                                r.depthBuffer && ((s.__webglDepthRenderbuffer = e.createRenderbuffer()), I(s.__webglDepthRenderbuffer, r, !0)),
                                e.bindFramebuffer(36160, null);
                        } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
                    else if (d) {
                        var b = r.width,
                            w = r.height,
                            S = r.numViews;
                        e.bindFramebuffer(36160, s.__webglFramebuffer);
                        var E = t.get("OVR_multiview2");
                        a.memory.textures += 2;
                        var T = e.createTexture();
                        e.bindTexture(35866, T),
                            e.texParameteri(35866, 10240, 9728),
                            e.texParameteri(35866, 10241, 9728),
                            e.texImage3D(35866, 0, 32856, b, w, S, 0, 6408, 5121, null),
                            E.framebufferTextureMultiviewOVR(36160, 36064, T, 0, 0, S);
                        var A = e.createTexture();
                        e.bindTexture(35866, A),
                            e.texParameteri(35866, 10240, 9728),
                            e.texParameteri(35866, 10241, 9728),
                            e.texImage3D(35866, 0, 35056, b, w, S, 0, 34041, 34042, null),
                            E.framebufferTextureMultiviewOVR(36160, 33306, A, 0, 0, S);
                        var L = new Array(S);
                        for (f = 0; f < S; ++f) (L[f] = e.createFramebuffer()), e.bindFramebuffer(36160, L[f]), e.framebufferTextureLayer(36160, 36064, T, 0, f);
                        (s.__webglColorTexture = T), (s.__webglDepthStencilTexture = A), (s.__webglViewFramebuffers = L), e.bindFramebuffer(36160, null), e.bindTexture(35866, null);
                    }
                    if (u) {
                        n.bindTexture(34067, l.__webglTexture), R(34067, r.texture, p);
                        for (f = 0; f < 6; f++) D(s.__webglFramebuffer[f], r, 36064, 34069 + f);
                        y(r.texture, p) && x(34067, r.texture, r.width, r.height), n.bindTexture(34067, null);
                    } else d || (n.bindTexture(3553, l.__webglTexture), R(3553, r.texture, p), D(s.__webglFramebuffer, r, 36064, 3553), y(r.texture, p) && x(3553, r.texture, r.width, r.height), n.bindTexture(3553, null));
                    r.depthBuffer && N(r);
                }),
                (this.updateRenderTargetMipmap = function (e) {
                    var t = e.texture;
                    if (y(t, g(e) || c)) {
                        var r = e.isWebGLRenderTargetCube ? 34067 : 3553,
                            o = i.get(t).__webglTexture;
                        n.bindTexture(r, o), x(r, t, e.width, e.height), n.bindTexture(r, null);
                    }
                }),
                (this.updateMultisampleRenderTarget = function (t) {
                    if (t.isWebGLMultisampleRenderTarget)
                        if (c) {
                            var n = i.get(t);
                            e.bindFramebuffer(36008, n.__webglMultisampledFramebuffer), e.bindFramebuffer(36009, n.__webglFramebuffer);
                            var r = t.width,
                                o = t.height,
                                a = 16384;
                            t.depthBuffer && (a |= 256), t.stencilBuffer && (a |= 1024), e.blitFramebuffer(0, 0, r, o, 0, 0, r, o, a, 9728);
                        } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
                }),
                (this.safeSetTexture2D = function (e, t) {
                    e && e.isWebGLRenderTarget && (!1 === B && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), (B = !0)), (e = e.texture)), E(e, t);
                }),
                (this.safeSetTextureCube = function (e, t) {
                    e && e.isWebGLRenderTargetCube && (!1 === z && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), (z = !0)), (e = e.texture)),
                        (e && e.isCubeTexture) || (Array.isArray(e.image) && 6 === e.image.length) ? T(e, t) : A(e, t);
                });
        }
        function hs(e, t, n) {
            var i = n.isWebGL2;
            return {
                convert: function (e) {
                    var n;
                    if (e === Re) return 5121;
                    if (e === ze) return 32819;
                    if (e === Fe) return 32820;
                    if (e === Ge) return 33635;
                    if (e === Pe) return 5120;
                    if (e === Oe) return 5122;
                    if (e === De) return 5123;
                    if (e === Ie) return 5124;
                    if (e === Ne) return 5125;
                    if (e === Ue) return 5126;
                    if (e === Be) return i ? 5131 : null !== (n = t.get("OES_texture_half_float")) ? n.HALF_FLOAT_OES : null;
                    if (e === Ve) return 6406;
                    if (e === ke) return 6407;
                    if (e === je) return 6408;
                    if (e === We) return 6409;
                    if (e === qe) return 6410;
                    if (e === Ye) return 6402;
                    if (e === Je) return 34041;
                    if (e === Ze) return 6403;
                    if (e === Ke || e === Qe || e === $e || e === et) {
                        if (null === (n = t.get("WEBGL_compressed_texture_s3tc"))) return null;
                        if (e === Ke) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        if (e === Qe) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        if (e === $e) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        if (e === et) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                    }
                    if (e === tt || e === nt || e === it || e === rt) {
                        if (null === (n = t.get("WEBGL_compressed_texture_pvrtc"))) return null;
                        if (e === tt) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (e === nt) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (e === it) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (e === rt) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                    }
                    return e === ot
                        ? null !== (n = t.get("WEBGL_compressed_texture_etc1"))
                            ? n.COMPRESSED_RGB_ETC1_WEBGL
                            : null
                        : e === at || e === st || e === ct || e === lt || e === ut || e === ht || e === dt || e === pt || e === ft || e === mt || e === vt || e === gt || e === yt || e === xt
                        ? null !== (n = t.get("WEBGL_compressed_texture_astc"))
                            ? e
                            : null
                        : e === He
                        ? i
                            ? 34042
                            : null !== (n = t.get("WEBGL_depth_texture"))
                            ? n.UNSIGNED_INT_24_8_WEBGL
                            : null
                        : void 0;
                },
            };
        }
        function ds(e, t, n, i) {
            On.call(this, e, t, i), (this.depthBuffer = !1), (this.stencilBuffer = !1), (this.numViews = n);
        }
        function ps(e, t) {
            var n,
                i,
                r,
                o,
                a,
                s,
                c,
                l = 2,
                u = e.extensions,
                h = e.properties,
                d = 0;
            function p(e) {
                return e.isArrayCamera ? e.cameras : ((a[0] = e), a);
            }
            (this.isAvailable = function () {
                if (void 0 === c) {
                    var e = u.get("OVR_multiview2");
                    if ((c = null !== e && !1 === t.getContextAttributes().antialias)) {
                        (d = t.getParameter(e.MAX_VIEWS_OVR)), (n = new ds(0, 0, l)), (s = new _n()), (o = []), (r = []), (a = []);
                        for (var i = 0; i < d; i++) (o[i] = new Hn()), (r[i] = new An());
                    }
                }
                return c;
            }),
                (this.attachCamera = function (t) {
                    !1 !==
                        (function (e) {
                            if (void 0 === e.isArrayCamera) return !0;
                            var t = e.cameras;
                            if (t.length > d) return !1;
                            for (var n = 1, i = t.length; n < i; n++) if (t[0].viewport.z !== t[n].viewport.z || t[0].viewport.w !== t[n].viewport.w) return !1;
                            return !0;
                        })(t) &&
                        ((i = e.getRenderTarget()),
                        (function (t) {
                            if ((i ? s.set(i.width, i.height) : e.getDrawingBufferSize(s), t.isArrayCamera)) {
                                var r = t.cameras[0].viewport;
                                n.setSize(r.z, r.w), n.setNumViews(t.cameras.length);
                            } else n.setSize(s.x, s.y), n.setNumViews(l);
                        })(t),
                        e.setRenderTarget(n));
                }),
                (this.detachCamera = function (r) {
                    n === e.getRenderTarget() &&
                        (e.setRenderTarget(i),
                        (function (e) {
                            var i = n,
                                r = i.numViews,
                                o = h.get(i).__webglViewFramebuffers,
                                a = i.width,
                                c = i.height;
                            if (e.isArrayCamera)
                                for (var l = 0; l < r; l++) {
                                    var u = e.cameras[l].viewport,
                                        d = u.x,
                                        p = u.y,
                                        f = d + u.z,
                                        m = p + u.w;
                                    t.bindFramebuffer(36008, o[l]), t.blitFramebuffer(0, 0, a, c, d, p, f, m, 16384, 9728);
                                }
                            else t.bindFramebuffer(36008, o[0]), t.blitFramebuffer(0, 0, a, c, 0, 0, s.x, s.y, 16384, 9728);
                        })(r));
                }),
                (this.updateCameraProjectionMatricesUniform = function (e, n) {
                    for (var i = p(e), r = 0; r < i.length; r++) o[r].copy(i[r].projectionMatrix);
                    n.setValue(t, "projectionMatrices", o);
                }),
                (this.updateCameraViewMatricesUniform = function (e, n) {
                    for (var i = p(e), r = 0; r < i.length; r++) o[r].copy(i[r].matrixWorldInverse);
                    n.setValue(t, "viewMatrices", o);
                }),
                (this.updateObjectMatricesUniforms = function (e, n, i) {
                    for (var a = p(n), s = 0; s < a.length; s++) o[s].multiplyMatrices(a[s].matrixWorldInverse, e.matrixWorld), r[s].getNormalMatrix(o[s]);
                    i.setValue(t, "modelViewMatrices", o), i.setValue(t, "normalMatrices", r);
                });
        }
        function fs() {
            oi.call(this), (this.type = "Group");
        }
        function ms(e) {
            ro.call(this), (this.cameras = e || []);
        }
        (ds.prototype = Object.assign(Object.create(On.prototype), {
            constructor: ds,
            isWebGLMultiviewRenderTarget: !0,
            copy: function (e) {
                return On.prototype.copy.call(this, e), (this.numViews = e.numViews), this;
            },
            setNumViews: function (e) {
                return this.numViews !== e && ((this.numViews = e), this.dispose()), this;
            },
        })),
            (fs.prototype = Object.assign(Object.create(oi.prototype), { constructor: fs, isGroup: !0 })),
            (ms.prototype = Object.assign(Object.create(ro.prototype), { constructor: ms, isArrayCamera: !0 }));
        var vs,
            gs = new Sn(),
            ys = new Sn();
        function xs(e, t, n) {
            gs.setFromMatrixPosition(t.matrixWorld), ys.setFromMatrixPosition(n.matrixWorld);
            var i = gs.distanceTo(ys),
                r = t.projectionMatrix.elements,
                o = n.projectionMatrix.elements,
                a = r[14] / (r[10] - 1),
                s = r[14] / (r[10] + 1),
                c = (r[9] + 1) / r[5],
                l = (r[9] - 1) / r[5],
                u = (r[8] - 1) / r[0],
                h = (o[8] + 1) / o[0],
                d = a * u,
                p = a * h,
                f = i / (-u + h),
                m = f * -u;
            t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(m), e.translateZ(f), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.getInverse(e.matrixWorld);
            var v = a + f,
                g = s + f,
                y = d - m,
                x = p + (i - m),
                _ = ((c * s) / g) * v,
                b = ((l * s) / g) * v;
            e.projectionMatrix.makePerspective(y, x, _, b, v, g);
        }
        function _s(e) {
            var t,
                n,
                i = this,
                r = null,
                o = null,
                a = [],
                s = new Hn(),
                c = new Hn(),
                l = 1,
                u = "local-floor";
            "undefined" != typeof window && "VRFrameData" in window && ((o = new window.VRFrameData()), window.addEventListener("vrdisplaypresentchange", b, !1));
            var h = new Hn(),
                d = new bn(),
                p = new Sn(),
                f = new ro(),
                m = new ro();
            (m.viewport = new Pn()), m.layers.enable(1);
            var v = new ro();
            (v.viewport = new Pn()), v.layers.enable(2);
            var g = new ms([m, v]);
            function y() {
                return null !== r && !0 === r.isPresenting;
            }
            g.layers.enable(1), g.layers.enable(2);
            var x,
                _ = new _n();
            function b() {
                if (y()) {
                    var o = r.getEyeParameters("left");
                    (t = 2 * o.renderWidth * l),
                        (n = o.renderHeight * l),
                        (x = e.getPixelRatio()),
                        e.getSize(_),
                        e.setDrawingBufferSize(t, n, 1),
                        m.viewport.set(0, 0, t / 2, n),
                        v.viewport.set(t / 2, 0, t / 2, n),
                        T.start(),
                        i.dispatchEvent({ type: "sessionstart" });
                } else i.enabled && e.setDrawingBufferSize(_.width, _.height, x), T.stop(), i.dispatchEvent({ type: "sessionend" });
            }
            var w = [],
                M = [];
            function S(e) {
                for (var t = navigator.getGamepads && navigator.getGamepads(), n = 0, i = t.length; n < i; n++) {
                    var r = t[n];
                    if (
                        r &&
                        ("Daydream Controller" === r.id ||
                            "Gear VR Controller" === r.id ||
                            "Oculus Go Controller" === r.id ||
                            "OpenVR Gamepad" === r.id ||
                            r.id.startsWith("Oculus Touch") ||
                            r.id.startsWith("HTC Vive Focus") ||
                            r.id.startsWith("Spatial Controller"))
                    ) {
                        var o = r.hand;
                        if (0 === e && ("" === o || "right" === o)) return r;
                        if (1 === e && "left" === o) return r;
                    }
                }
            }
            function E(e, i) {
                null !== i && 4 === i.length && e.set(i[0] * t, i[1] * n, i[2] * t, i[3] * n);
            }
            (this.enabled = !1),
                (this.getController = function (e) {
                    var t = a[e];
                    return void 0 === t && (((t = new fs()).matrixAutoUpdate = !1), (t.visible = !1), (a[e] = t)), t;
                }),
                (this.getDevice = function () {
                    return r;
                }),
                (this.setDevice = function (e) {
                    void 0 !== e && (r = e), T.setContext(e);
                }),
                (this.setFramebufferScaleFactor = function (e) {
                    l = e;
                }),
                (this.setReferenceSpaceType = function (e) {
                    u = e;
                }),
                (this.getCamera = function (e) {
                    var t = "local-floor" === u ? 1.6 : 0;
                    if (((r.depthNear = e.near), (r.depthFar = e.far), r.getFrameData(o), "local-floor" === u)) {
                        var n = r.stageParameters;
                        n ? s.fromArray(n.sittingToStandingTransform) : s.makeTranslation(0, t, 0);
                    }
                    var i = o.pose;
                    f.matrix.copy(s),
                        f.matrix.decompose(f.position, f.quaternion, f.scale),
                        null !== i.orientation && (d.fromArray(i.orientation), f.quaternion.multiply(d)),
                        null !== i.position && (d.setFromRotationMatrix(s), p.fromArray(i.position), p.applyQuaternion(d), f.position.add(p)),
                        f.updateMatrixWorld(),
                        e.matrixWorld.copy(f.matrixWorld);
                    for (var l = e.children, y = 0, x = l.length; y < x; y++) l[y].updateMatrixWorld(!0);
                    (m.near = e.near),
                        (v.near = e.near),
                        (m.far = e.far),
                        (v.far = e.far),
                        m.matrixWorldInverse.fromArray(o.leftViewMatrix),
                        v.matrixWorldInverse.fromArray(o.rightViewMatrix),
                        c.getInverse(s),
                        "local-floor" === u && (m.matrixWorldInverse.multiply(c), v.matrixWorldInverse.multiply(c));
                    var _ = e.parent;
                    null !== _ && (h.getInverse(_.matrixWorld), m.matrixWorldInverse.multiply(h), v.matrixWorldInverse.multiply(h)),
                        m.matrixWorld.getInverse(m.matrixWorldInverse),
                        v.matrixWorld.getInverse(v.matrixWorldInverse),
                        m.projectionMatrix.fromArray(o.leftProjectionMatrix),
                        v.projectionMatrix.fromArray(o.rightProjectionMatrix),
                        xs(g, m, v);
                    var b = r.getLayers();
                    if (b.length) {
                        var T = b[0];
                        E(m.viewport, T.leftBounds), E(v.viewport, T.rightBounds);
                    }
                    return (
                        (function () {
                            for (var e = 0; e < a.length; e++) {
                                var t = a[e],
                                    n = S(e);
                                if (void 0 !== n && void 0 !== n.pose) {
                                    if (null === n.pose) return;
                                    var i = n.pose;
                                    !1 === i.hasPosition && t.position.set(0.2, -0.6, -0.05),
                                        null !== i.position && t.position.fromArray(i.position),
                                        null !== i.orientation && t.quaternion.fromArray(i.orientation),
                                        t.matrix.compose(t.position, t.quaternion, t.scale),
                                        t.matrix.premultiply(s),
                                        t.matrix.decompose(t.position, t.quaternion, t.scale),
                                        (t.matrixWorldNeedsUpdate = !0),
                                        (t.visible = !0);
                                    var r = "Daydream Controller" === n.id ? 0 : 1;
                                    void 0 === w[e] && (w[e] = !1),
                                        w[e] !== n.buttons[r].pressed &&
                                            ((w[e] = n.buttons[r].pressed), !0 === w[e] ? t.dispatchEvent({ type: "selectstart" }) : (t.dispatchEvent({ type: "selectend" }), t.dispatchEvent({ type: "select" }))),
                                        (r = 2),
                                        void 0 === M[e] && (M[e] = !1),
                                        void 0 !== n.buttons[r] &&
                                            M[e] !== n.buttons[r].pressed &&
                                            ((M[e] = n.buttons[r].pressed), !0 === M[e] ? t.dispatchEvent({ type: "squeezestart" }) : (t.dispatchEvent({ type: "squeezeend" }), t.dispatchEvent({ type: "squeeze" })));
                                } else t.visible = !1;
                            }
                        })(),
                        g
                    );
                }),
                (this.getStandingMatrix = function () {
                    return s;
                }),
                (this.isPresenting = y);
            var T = new go();
            (this.setAnimationLoop = function (e) {
                T.setAnimationLoop(e), y() && T.start();
            }),
                (this.submitFrame = function () {
                    y() && r.submitFrame();
                }),
                (this.dispose = function () {
                    "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", b);
                }),
                (this.setFrameOfReferenceType = function () {
                    console.warn("THREE.WebVRManager: setFrameOfReferenceType() has been deprecated.");
                });
        }
        function bs(e, t) {
            var n = this,
                i = null,
                r = null,
                o = "local-floor",
                a = null,
                s = [],
                c = [];
            var l = new ro();
            l.layers.enable(1), (l.viewport = new Pn());
            var u = new ro();
            u.layers.enable(2), (u.viewport = new Pn());
            var h = new ms([l, u]);
            function d(e) {
                for (var t = 0; t < s.length; t++) c[t] === e.inputSource && s[t].dispatchEvent({ type: e.type });
            }
            function p() {
                e.setFramebuffer(null), e.setRenderTarget(e.getRenderTarget()), x.stop(), n.dispatchEvent({ type: "sessionend" });
            }
            function f(e) {
                (r = e), x.setContext(i), x.start(), n.dispatchEvent({ type: "sessionstart" });
            }
            function m() {
                for (var e = 0; e < s.length; e++) c[e] = v(e);
            }
            function v(e) {
                for (var t = i.inputSources, n = 0; n < t.length; n++) {
                    var r = t[n],
                        o = r.handedness;
                    if (0 === e && ("none" === o || "right" === o)) return r;
                    if (1 === e && "left" === o) return r;
                }
            }
            function g(e, t) {
                null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.getInverse(e.matrixWorld);
            }
            h.layers.enable(1),
                h.layers.enable(2),
                (this.enabled = !1),
                (this.getController = function (e) {
                    var t = s[e];
                    return void 0 === t && (((t = new fs()).matrixAutoUpdate = !1), (t.visible = !1), (s[e] = t)), t;
                }),
                (this.setFramebufferScaleFactor = function () {}),
                (this.setReferenceSpaceType = function (e) {
                    o = e;
                }),
                (this.getSession = function () {
                    return i;
                }),
                (this.setSession = function (e) {
                    null !== (i = e) &&
                        (i.addEventListener("select", d),
                        i.addEventListener("selectstart", d),
                        i.addEventListener("selectend", d),
                        i.addEventListener("squeeze", d),
                        i.addEventListener("squeezestart", d),
                        i.addEventListener("squeezeend", d),
                        i.addEventListener("end", p),
                        i.updateRenderState({ baseLayer: new XRWebGLLayer(i, t) }),
                        i.requestReferenceSpace(o).then(f),
                        i.addEventListener("inputsourceschange", m),
                        m());
                }),
                (this.getCamera = function (e) {
                    var t = e.parent,
                        n = h.cameras;
                    g(h, t);
                    for (var i = 0; i < n.length; i++) g(n[i], t);
                    e.matrixWorld.copy(h.matrixWorld);
                    for (var r = e.children, o = ((i = 0), r.length); i < o; i++) r[i].updateMatrixWorld(!0);
                    return xs(h, l, u), h;
                }),
                (this.isPresenting = function () {
                    return null !== i && null !== r;
                });
            var y = null;
            var x = new go();
            x.setAnimationLoop(function (t, n) {
                if (null !== (a = n.getViewerPose(r))) {
                    var o = a.views,
                        l = i.renderState.baseLayer;
                    e.setFramebuffer(l.framebuffer);
                    for (var u = 0; u < o.length; u++) {
                        var d = o[u],
                            p = l.getViewport(d),
                            f = d.transform.inverse.matrix,
                            m = h.cameras[u];
                        m.matrix.fromArray(f).getInverse(m.matrix), m.projectionMatrix.fromArray(d.projectionMatrix), m.viewport.set(p.x, p.y, p.width, p.height), 0 === u && h.matrix.copy(m.matrix);
                    }
                }
                for (u = 0; u < s.length; u++) {
                    var v = s[u],
                        g = c[u];
                    if (g) {
                        var x = n.getPose(g.targetRaySpace, r);
                        if (null !== x) {
                            v.matrix.fromArray(x.transform.matrix), v.matrix.decompose(v.position, v.rotation, v.scale), (v.visible = !0);
                            continue;
                        }
                    }
                    v.visible = !1;
                }
                y && y(t);
            }),
                (this.setAnimationLoop = function (e) {
                    y = e;
                }),
                (this.dispose = function () {}),
                (this.getStandingMatrix = function () {
                    return console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed."), new Hn();
                }),
                (this.getDevice = function () {
                    console.warn("THREE.WebXRManager: getDevice() has been deprecated.");
                }),
                (this.setDevice = function () {
                    console.warn("THREE.WebXRManager: setDevice() has been deprecated.");
                }),
                (this.setFrameOfReferenceType = function () {
                    console.warn("THREE.WebXRManager: setFrameOfReferenceType() has been deprecated.");
                }),
                (this.submitFrame = function () {});
        }
        function ws(e) {
            var t = void 0 !== (e = e || {}).canvas ? e.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
                n = void 0 !== e.context ? e.context : null,
                i = void 0 !== e.alpha && e.alpha,
                r = void 0 === e.depth || e.depth,
                o = void 0 === e.stencil || e.stencil,
                a = void 0 !== e.antialias && e.antialias,
                s = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
                c = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
                l = void 0 !== e.powerPreference ? e.powerPreference : "default",
                u = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat,
                h = null,
                d = null;
            (this.domElement = t),
                (this.debug = { checkShaderErrors: !0 }),
                (this.autoClear = !0),
                (this.autoClearColor = !0),
                (this.autoClearDepth = !0),
                (this.autoClearStencil = !0),
                (this.sortObjects = !0),
                (this.clippingPlanes = []),
                (this.localClippingEnabled = !1),
                (this.gammaFactor = 2),
                (this.gammaInput = !1),
                (this.gammaOutput = !1),
                (this.physicallyCorrectLights = !1),
                (this.toneMapping = re),
                (this.toneMappingExposure = 1),
                (this.toneMappingWhitePoint = 1),
                (this.maxMorphTargets = 8),
                (this.maxMorphNormals = 4);
            var p,
                f,
                m,
                v,
                y,
                x,
                _,
                b,
                w,
                M,
                S,
                E,
                T,
                A,
                L,
                C,
                R,
                P,
                O = this,
                D = !1,
                I = null,
                N = 0,
                U = 0,
                B = null,
                z = null,
                F = -1,
                G = { geometry: null, program: null, wireframe: !1 },
                H = null,
                V = null,
                k = new Pn(),
                j = new Pn(),
                W = null,
                q = t.width,
                X = t.height,
                Y = 1,
                J = new Pn(0, 0, q, X),
                Z = new Pn(0, 0, q, X),
                K = !1,
                Q = new po(),
                $ = new So(),
                ee = !1,
                te = !1,
                ne = new Hn(),
                ie = new Sn();
            function oe() {
                return null === B ? Y : 1;
            }
            try {
                var ae = { alpha: i, depth: r, stencil: o, antialias: a, premultipliedAlpha: s, preserveDrawingBuffer: c, powerPreference: l, failIfMajorPerformanceCaveat: u, xrCompatible: !0 };
                if ((t.addEventListener("webglcontextlost", he, !1), t.addEventListener("webglcontextrestored", de, !1), null === (p = n || t.getContext("webgl", ae) || t.getContext("experimental-webgl", ae))))
                    throw null !== t.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
                void 0 === p.getShaderPrecisionFormat &&
                    (p.getShaderPrecisionFormat = function () {
                        return { rangeMin: 1, rangeMax: 1, precision: 1 };
                    });
            } catch (e) {
                throw (console.error("THREE.WebGLRenderer: " + e.message), e);
            }
            function se() {
                (f = new Eo(p)),
                    !1 === (m = new Mo(p, f, e)).isWebGL2 &&
                        (f.get("WEBGL_depth_texture"),
                        f.get("OES_texture_float"),
                        f.get("OES_texture_half_float"),
                        f.get("OES_texture_half_float_linear"),
                        f.get("OES_standard_derivatives"),
                        f.get("OES_element_index_uint"),
                        f.get("ANGLE_instanced_arrays")),
                    f.get("OES_texture_float_linear"),
                    (P = new hs(p, f, m)),
                    (v = new ls(p, f, m)).scissor(j.copy(Z).multiplyScalar(Y).floor()),
                    v.viewport(k.copy(J).multiplyScalar(Y).floor()),
                    (y = new Lo(p)),
                    (x = new Xa()),
                    (_ = new us(p, f, v, x, m, P, y)),
                    (b = new yo(p)),
                    (w = new To(p, b, y)),
                    (M = new Po(p, w, b, y)),
                    (L = new Ro(p)),
                    (S = new qa(O, f, m)),
                    (E = new Ka()),
                    (T = new is()),
                    (A = new bo(O, v, M, s)),
                    (C = new wo(p, f, y, m)),
                    (R = new Ao(p, f, y, m)),
                    (y.programs = S.programs),
                    (O.capabilities = m),
                    (O.extensions = f),
                    (O.properties = x),
                    (O.renderLists = E),
                    (O.state = v),
                    (O.info = y);
            }
            se();
            var ce = "undefined" != typeof navigator && "xr" in navigator ? new bs(O, p) : new _s(O);
            this.vr = ce;
            var le = new ps(O, p),
                ue = new cs(O, M, m.maxTextureSize);
            function he(e) {
                e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), (D = !0);
            }
            function de() {
                console.log("THREE.WebGLRenderer: Context Restored."), (D = !1), se();
            }
            function pe(e) {
                var t = e.target;
                t.removeEventListener("dispose", pe),
                    (function (e) {
                        fe(e), x.remove(e);
                    })(t);
            }
            function fe(e) {
                var t = x.get(e).program;
                (e.program = void 0), void 0 !== t && S.releaseProgram(t);
            }
            (this.shadowMap = ue),
                (this.getContext = function () {
                    return p;
                }),
                (this.getContextAttributes = function () {
                    return p.getContextAttributes();
                }),
                (this.forceContextLoss = function () {
                    var e = f.get("WEBGL_lose_context");
                    e && e.loseContext();
                }),
                (this.forceContextRestore = function () {
                    var e = f.get("WEBGL_lose_context");
                    e && e.restoreContext();
                }),
                (this.getPixelRatio = function () {
                    return Y;
                }),
                (this.setPixelRatio = function (e) {
                    void 0 !== e && ((Y = e), this.setSize(q, X, !1));
                }),
                (this.getSize = function (e) {
                    return void 0 === e && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), (e = new _n())), e.set(q, X);
                }),
                (this.setSize = function (e, n, i) {
                    ce.isPresenting()
                        ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.")
                        : ((q = e), (X = n), (t.width = Math.floor(e * Y)), (t.height = Math.floor(n * Y)), !1 !== i && ((t.style.width = e + "px"), (t.style.height = n + "px")), this.setViewport(0, 0, e, n));
                }),
                (this.getDrawingBufferSize = function (e) {
                    return void 0 === e && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), (e = new _n())), e.set(q * Y, X * Y).floor();
                }),
                (this.setDrawingBufferSize = function (e, n, i) {
                    (q = e), (X = n), (Y = i), (t.width = Math.floor(e * i)), (t.height = Math.floor(n * i)), this.setViewport(0, 0, e, n);
                }),
                (this.getCurrentViewport = function (e) {
                    return void 0 === e && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), (e = new Pn())), e.copy(k);
                }),
                (this.getViewport = function (e) {
                    return e.copy(J);
                }),
                (this.setViewport = function (e, t, n, i) {
                    e.isVector4 ? J.set(e.x, e.y, e.z, e.w) : J.set(e, t, n, i), v.viewport(k.copy(J).multiplyScalar(Y).floor());
                }),
                (this.getScissor = function (e) {
                    return e.copy(Z);
                }),
                (this.setScissor = function (e, t, n, i) {
                    e.isVector4 ? Z.set(e.x, e.y, e.z, e.w) : Z.set(e, t, n, i), v.scissor(j.copy(Z).multiplyScalar(Y).floor());
                }),
                (this.getScissorTest = function () {
                    return K;
                }),
                (this.setScissorTest = function (e) {
                    v.setScissorTest((K = e));
                }),
                (this.getClearColor = function () {
                    return A.getClearColor();
                }),
                (this.setClearColor = function () {
                    A.setClearColor.apply(A, arguments);
                }),
                (this.getClearAlpha = function () {
                    return A.getClearAlpha();
                }),
                (this.setClearAlpha = function () {
                    A.setClearAlpha.apply(A, arguments);
                }),
                (this.clear = function (e, t, n) {
                    var i = 0;
                    (void 0 === e || e) && (i |= 16384), (void 0 === t || t) && (i |= 256), (void 0 === n || n) && (i |= 1024), p.clear(i);
                }),
                (this.clearColor = function () {
                    this.clear(!0, !1, !1);
                }),
                (this.clearDepth = function () {
                    this.clear(!1, !0, !1);
                }),
                (this.clearStencil = function () {
                    this.clear(!1, !1, !0);
                }),
                (this.dispose = function () {
                    t.removeEventListener("webglcontextlost", he, !1), t.removeEventListener("webglcontextrestored", de, !1), E.dispose(), T.dispose(), x.dispose(), M.dispose(), ce.dispose(), ve.stop();
                }),
                (this.renderBufferImmediate = function (e, t) {
                    v.initAttributes();
                    var n = x.get(e);
                    e.hasPositions && !n.position && (n.position = p.createBuffer()),
                        e.hasNormals && !n.normal && (n.normal = p.createBuffer()),
                        e.hasUvs && !n.uv && (n.uv = p.createBuffer()),
                        e.hasColors && !n.color && (n.color = p.createBuffer());
                    var i = t.getAttributes();
                    e.hasPositions && (p.bindBuffer(34962, n.position), p.bufferData(34962, e.positionArray, 35048), v.enableAttribute(i.position), p.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)),
                        e.hasNormals && (p.bindBuffer(34962, n.normal), p.bufferData(34962, e.normalArray, 35048), v.enableAttribute(i.normal), p.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)),
                        e.hasUvs && (p.bindBuffer(34962, n.uv), p.bufferData(34962, e.uvArray, 35048), v.enableAttribute(i.uv), p.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)),
                        e.hasColors && (p.bindBuffer(34962, n.color), p.bufferData(34962, e.colorArray, 35048), v.enableAttribute(i.color), p.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)),
                        v.disableUnusedAttributes(),
                        p.drawArrays(4, 0, e.count),
                        (e.count = 0);
                }),
                (this.renderBufferDirect = function (e, t, n, i, r, o) {
                    var a = r.isMesh && r.matrixWorld.determinant() < 0;
                    v.setMaterial(i, a);
                    var s = be(e, t, i, r),
                        c = !1;
                    (G.geometry === n.id && G.program === s.id && G.wireframe === (!0 === i.wireframe)) || ((G.geometry = n.id), (G.program = s.id), (G.wireframe = !0 === i.wireframe), (c = !0)),
                        r.morphTargetInfluences && (L.update(r, n, i, s), (c = !0));
                    var l = n.index,
                        u = n.attributes.position;
                    if ((null === l || 0 !== l.count) && void 0 !== u && 0 !== u.count) {
                        var h,
                            d = 1;
                        !0 === i.wireframe && ((l = w.getWireframeAttribute(n)), (d = 2));
                        var g = C;
                        null !== l && ((h = b.get(l)), (g = R).setIndex(h)),
                            c &&
                                (!(function (e, t, n, i) {
                                    if (!1 === m.isWebGL2 && (e.isInstancedMesh || t.isInstancedBufferGeometry) && null === f.get("ANGLE_instanced_arrays")) return;
                                    v.initAttributes();
                                    var r = t.attributes,
                                        o = i.getAttributes(),
                                        a = n.defaultAttributeValues;
                                    for (var s in o) {
                                        var c = o[s];
                                        if (c >= 0) {
                                            var l = r[s];
                                            if (void 0 !== l) {
                                                var u = l.normalized,
                                                    h = l.itemSize;
                                                if (void 0 === (M = b.get(l))) continue;
                                                var d = M.buffer,
                                                    g = M.type,
                                                    y = M.bytesPerElement;
                                                if (l.isInterleavedBufferAttribute) {
                                                    var x = l.data,
                                                        _ = x.stride,
                                                        w = l.offset;
                                                    x && x.isInstancedInterleavedBuffer
                                                        ? (v.enableAttributeAndDivisor(c, x.meshPerAttribute), void 0 === t.maxInstancedCount && (t.maxInstancedCount = x.meshPerAttribute * x.count))
                                                        : v.enableAttribute(c),
                                                        p.bindBuffer(34962, d),
                                                        p.vertexAttribPointer(c, h, g, u, _ * y, w * y);
                                                } else
                                                    l.isInstancedBufferAttribute
                                                        ? (v.enableAttributeAndDivisor(c, l.meshPerAttribute), void 0 === t.maxInstancedCount && (t.maxInstancedCount = l.meshPerAttribute * l.count))
                                                        : v.enableAttribute(c),
                                                        p.bindBuffer(34962, d),
                                                        p.vertexAttribPointer(c, h, g, u, 0, 0);
                                            } else if ("instanceMatrix" === s) {
                                                var M;
                                                if (void 0 === (M = b.get(e.instanceMatrix))) continue;
                                                (d = M.buffer), (g = M.type);
                                                v.enableAttributeAndDivisor(c + 0, 1),
                                                    v.enableAttributeAndDivisor(c + 1, 1),
                                                    v.enableAttributeAndDivisor(c + 2, 1),
                                                    v.enableAttributeAndDivisor(c + 3, 1),
                                                    p.bindBuffer(34962, d),
                                                    p.vertexAttribPointer(c + 0, 4, g, !1, 64, 0),
                                                    p.vertexAttribPointer(c + 1, 4, g, !1, 64, 16),
                                                    p.vertexAttribPointer(c + 2, 4, g, !1, 64, 32),
                                                    p.vertexAttribPointer(c + 3, 4, g, !1, 64, 48);
                                            } else if (void 0 !== a) {
                                                var S = a[s];
                                                if (void 0 !== S)
                                                    switch (S.length) {
                                                        case 2:
                                                            p.vertexAttrib2fv(c, S);
                                                            break;
                                                        case 3:
                                                            p.vertexAttrib3fv(c, S);
                                                            break;
                                                        case 4:
                                                            p.vertexAttrib4fv(c, S);
                                                            break;
                                                        default:
                                                            p.vertexAttrib1fv(c, S);
                                                    }
                                            }
                                        }
                                    }
                                    v.disableUnusedAttributes();
                                })(r, n, i, s),
                                null !== l && p.bindBuffer(34963, h.buffer));
                        var y = 1 / 0;
                        null !== l ? (y = l.count) : void 0 !== u && (y = u.count);
                        var x = n.drawRange.start * d,
                            _ = n.drawRange.count * d,
                            M = null !== o ? o.start * d : 0,
                            S = null !== o ? o.count * d : 1 / 0,
                            E = Math.max(x, M),
                            T = Math.min(y, x + _, M + S) - 1,
                            A = Math.max(0, T - E + 1);
                        if (0 !== A) {
                            if (r.isMesh)
                                if (!0 === i.wireframe) v.setLineWidth(i.wireframeLinewidth * oe()), g.setMode(1);
                                else
                                    switch (r.drawMode) {
                                        case Ct:
                                            g.setMode(4);
                                            break;
                                        case Rt:
                                            g.setMode(5);
                                            break;
                                        case Pt:
                                            g.setMode(6);
                                    }
                            else if (r.isLine) {
                                var P = i.linewidth;
                                void 0 === P && (P = 1), v.setLineWidth(P * oe()), r.isLineSegments ? g.setMode(1) : r.isLineLoop ? g.setMode(2) : g.setMode(3);
                            } else r.isPoints ? g.setMode(0) : r.isSprite && g.setMode(4);
                            r.isInstancedMesh ? g.renderInstances(n, E, A, r.count) : n.isInstancedBufferGeometry ? g.renderInstances(n, E, A, n.maxInstancedCount) : g.render(E, A);
                        }
                    }
                }),
                (this.compile = function (e, t) {
                    (d = T.get(e, t)).init(),
                        e.traverse(function (e) {
                            e.isLight && (d.pushLight(e), e.castShadow && d.pushShadow(e));
                        }),
                        d.setupLights(t),
                        e.traverse(function (t) {
                            if (t.material)
                                if (Array.isArray(t.material)) for (var n = 0; n < t.material.length; n++) _e(t.material[n], e.fog, t);
                                else _e(t.material, e.fog, t);
                        });
                });
            var me = null;
            var ve = new go();
            function ge(e, t, n, i) {
                if (!1 !== e.visible) {
                    if (e.layers.test(t.layers))
                        if (e.isGroup) n = e.renderOrder;
                        else if (e.isLOD) !0 === e.autoUpdate && e.update(t);
                        else if (e.isLight) d.pushLight(e), e.castShadow && d.pushShadow(e);
                        else if (e.isSprite) {
                            if (!e.frustumCulled || Q.intersectsSprite(e)) {
                                i && ie.setFromMatrixPosition(e.matrixWorld).applyMatrix4(ne);
                                var r = M.update(e);
                                (o = e.material).visible && h.push(e, r, o, n, ie.z, null);
                            }
                        } else if (e.isImmediateRenderObject) i && ie.setFromMatrixPosition(e.matrixWorld).applyMatrix4(ne), h.push(e, null, e.material, n, ie.z, null);
                        else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.frame !== y.render.frame && (e.skeleton.update(), (e.skeleton.frame = y.render.frame)), !e.frustumCulled || Q.intersectsObject(e))) {
                            i && ie.setFromMatrixPosition(e.matrixWorld).applyMatrix4(ne);
                            r = M.update(e);
                            var o = e.material;
                            if (Array.isArray(o))
                                for (var a = r.groups, s = 0, c = a.length; s < c; s++) {
                                    var l = a[s],
                                        u = o[l.materialIndex];
                                    u && u.visible && h.push(e, r, u, n, ie.z, l);
                                }
                            else o.visible && h.push(e, r, o, n, ie.z, null);
                        }
                    var p = e.children;
                    for (s = 0, c = p.length; s < c; s++) ge(p[s], t, n, i);
                }
            }
            function ye(e, t, n, i) {
                for (var r = 0, o = e.length; r < o; r++) {
                    var a = e[r],
                        s = a.object,
                        c = a.geometry,
                        l = void 0 === i ? a.material : i,
                        u = a.group;
                    if (n.isArrayCamera)
                        if (((V = n), ce.enabled && le.isAvailable())) xe(s, t, n, c, l, u);
                        else
                            for (var h = n.cameras, p = 0, f = h.length; p < f; p++) {
                                var m = h[p];
                                s.layers.test(m.layers) && (v.viewport(k.copy(m.viewport)), d.setupLights(m), xe(s, t, m, c, l, u));
                            }
                    else (V = null), xe(s, t, n, c, l, u);
                }
            }
            function xe(e, t, n, i, r, o) {
                if ((e.onBeforeRender(O, t, n, i, r, o), (d = T.get(t, V || n)), e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), e.isImmediateRenderObject)) {
                    v.setMaterial(r);
                    var a = be(n, t.fog, r, e);
                    (G.geometry = null),
                        (G.program = null),
                        (G.wireframe = !1),
                        (function (e, t) {
                            e.render(function (e) {
                                O.renderBufferImmediate(e, t);
                            });
                        })(e, a);
                } else O.renderBufferDirect(n, t.fog, i, r, e, o);
                e.onAfterRender(O, t, n, i, r, o), (d = T.get(t, V || n));
            }
            function _e(e, t, n) {
                var i = x.get(e),
                    r = d.state.lights,
                    o = d.state.shadowsArray,
                    a = r.state.version,
                    s = S.getParameters(e, r.state, o, t, $.numPlanes, $.numIntersection, n),
                    c = S.getProgramCacheKey(e, s),
                    l = i.program,
                    u = !0;
                if (void 0 === l) e.addEventListener("dispose", pe);
                else if (l.cacheKey !== c) fe(e);
                else if (i.lightsStateVersion !== a) (i.lightsStateVersion = a), (u = !1);
                else {
                    if (void 0 !== s.shaderID) return;
                    u = !1;
                }
                if (u) {
                    if (s.shaderID) {
                        var h = vo[s.shaderID];
                        i.shader = { name: e.type, uniforms: Kr(h.uniforms), vertexShader: h.vertexShader, fragmentShader: h.fragmentShader };
                    } else i.shader = { name: e.type, uniforms: e.uniforms, vertexShader: e.vertexShader, fragmentShader: e.fragmentShader };
                    e.onBeforeCompile(i.shader, O), (c = S.getProgramCacheKey(e, s)), (l = S.acquireProgram(e, i.shader, s, c)), (i.program = l), (e.program = l);
                }
                var p = l.getAttributes();
                if (e.morphTargets) {
                    e.numSupportedMorphTargets = 0;
                    for (var f = 0; f < O.maxMorphTargets; f++) p["morphTarget" + f] >= 0 && e.numSupportedMorphTargets++;
                }
                if (e.morphNormals) {
                    e.numSupportedMorphNormals = 0;
                    for (f = 0; f < O.maxMorphNormals; f++) p["morphNormal" + f] >= 0 && e.numSupportedMorphNormals++;
                }
                var m = i.shader.uniforms;
                ((e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping) || ((i.numClippingPlanes = $.numPlanes), (i.numIntersection = $.numIntersection), (m.clippingPlanes = $.uniform)),
                    (i.fog = t),
                    (i.needsLights = (function (e) {
                        return e.isMeshLambertMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || (e.isShaderMaterial && !0 === e.lights);
                    })(e)),
                    (i.lightsStateVersion = a),
                    i.needsLights &&
                        ((m.ambientLightColor.value = r.state.ambient),
                        (m.lightProbe.value = r.state.probe),
                        (m.directionalLights.value = r.state.directional),
                        (m.spotLights.value = r.state.spot),
                        (m.rectAreaLights.value = r.state.rectArea),
                        (m.pointLights.value = r.state.point),
                        (m.hemisphereLights.value = r.state.hemi),
                        (m.directionalShadowMap.value = r.state.directionalShadowMap),
                        (m.directionalShadowMatrix.value = r.state.directionalShadowMatrix),
                        (m.spotShadowMap.value = r.state.spotShadowMap),
                        (m.spotShadowMatrix.value = r.state.spotShadowMatrix),
                        (m.pointShadowMap.value = r.state.pointShadowMap),
                        (m.pointShadowMatrix.value = r.state.pointShadowMatrix));
                var v = i.program.getUniforms(),
                    g = La.seqWithValue(v.seq, m);
                i.uniformsList = g;
            }
            function be(e, t, n, i) {
                _.resetTextureUnits();
                var r = x.get(n),
                    o = d.state.lights;
                if (ee && (te || e !== H)) {
                    var a = e === H && n.id === F;
                    $.setState(n.clippingPlanes, n.clipIntersection, n.clipShadows, e, r, a);
                }
                n.version === r.__version &&
                    (void 0 === r.program
                        ? (n.needsUpdate = !0)
                        : n.fog && r.fog !== t
                        ? (n.needsUpdate = !0)
                        : r.needsLights && r.lightsStateVersion !== o.state.version
                        ? (n.needsUpdate = !0)
                        : void 0 === r.numClippingPlanes || (r.numClippingPlanes === $.numPlanes && r.numIntersection === $.numIntersection) || (n.needsUpdate = !0)),
                    n.version !== r.__version && (_e(n, t, i), (r.__version = n.version));
                var s,
                    c,
                    l = !1,
                    u = !1,
                    h = !1,
                    f = r.program,
                    y = f.getUniforms(),
                    b = r.shader.uniforms;
                if ((v.useProgram(f.program) && ((l = !0), (u = !0), (h = !0)), n.id !== F && ((F = n.id), (u = !0)), l || H !== e)) {
                    if (
                        (f.numMultiviewViews > 0 ? le.updateCameraProjectionMatricesUniform(e, y) : y.setValue(p, "projectionMatrix", e.projectionMatrix),
                        m.logarithmicDepthBuffer && y.setValue(p, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)),
                        H !== e && ((H = e), (u = !0), (h = !0)),
                        n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshStandardMaterial || n.envMap)
                    ) {
                        var w = y.map.cameraPosition;
                        void 0 !== w && w.setValue(p, ie.setFromMatrixPosition(e.matrixWorld));
                    }
                    (n.isMeshPhongMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && y.setValue(p, "isOrthographic", !0 === e.isOrthographicCamera),
                        (n.isMeshPhongMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.skinning) &&
                            (f.numMultiviewViews > 0 ? le.updateCameraViewMatricesUniform(e, y) : y.setValue(p, "viewMatrix", e.matrixWorldInverse));
                }
                if (n.skinning) {
                    y.setOptional(p, i, "bindMatrix"), y.setOptional(p, i, "bindMatrixInverse");
                    var M = i.skeleton;
                    if (M) {
                        var S = M.bones;
                        if (m.floatVertexTextures) {
                            if (void 0 === M.boneTexture) {
                                var E = Math.sqrt(4 * S.length);
                                (E = xn.ceilPowerOfTwo(E)), (E = Math.max(E, 4));
                                var T = new Float32Array(E * E * 4);
                                T.set(M.boneMatrices);
                                var A = new lo(T, E, E, je, Ue);
                                (M.boneMatrices = T), (M.boneTexture = A), (M.boneTextureSize = E);
                            }
                            y.setValue(p, "boneTexture", M.boneTexture, _), y.setValue(p, "boneTextureSize", M.boneTextureSize);
                        } else y.setOptional(p, M, "boneMatrices");
                    }
                }
                return (
                    (u || r.receiveShadow !== i.receiveShadow) && ((r.receiveShadow = i.receiveShadow), y.setValue(p, "receiveShadow", i.receiveShadow)),
                    u &&
                        (y.setValue(p, "toneMappingExposure", O.toneMappingExposure),
                        y.setValue(p, "toneMappingWhitePoint", O.toneMappingWhitePoint),
                        r.needsLights &&
                            ((c = h),
                            ((s = b).ambientLightColor.needsUpdate = c),
                            (s.lightProbe.needsUpdate = c),
                            (s.directionalLights.needsUpdate = c),
                            (s.pointLights.needsUpdate = c),
                            (s.spotLights.needsUpdate = c),
                            (s.rectAreaLights.needsUpdate = c),
                            (s.hemisphereLights.needsUpdate = c)),
                        t &&
                            n.fog &&
                            (function (e, t) {
                                e.fogColor.value.copy(t.color), t.isFog ? ((e.fogNear.value = t.near), (e.fogFar.value = t.far)) : t.isFogExp2 && (e.fogDensity.value = t.density);
                            })(b, t),
                        n.isMeshBasicMaterial
                            ? we(b, n)
                            : n.isMeshLambertMaterial
                            ? (we(b, n),
                              (function (e, t) {
                                  t.emissiveMap && (e.emissiveMap.value = t.emissiveMap);
                              })(b, n))
                            : n.isMeshPhongMaterial
                            ? (we(b, n),
                              n.isMeshToonMaterial
                                  ? (function (e, t) {
                                        Me(e, t), t.gradientMap && (e.gradientMap.value = t.gradientMap);
                                    })(b, n)
                                  : Me(b, n))
                            : n.isMeshStandardMaterial
                            ? (we(b, n),
                              n.isMeshPhysicalMaterial
                                  ? (function (e, t) {
                                        Se(e, t), (e.reflectivity.value = t.reflectivity), (e.clearcoat.value = t.clearcoat), (e.clearcoatRoughness.value = t.clearcoatRoughness), t.sheen && e.sheen.value.copy(t.sheen);
                                        t.clearcoatNormalMap && (e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale), (e.clearcoatNormalMap.value = t.clearcoatNormalMap), t.side === g && e.clearcoatNormalScale.value.negate());
                                        e.transparency.value = t.transparency;
                                    })(b, n)
                                  : Se(b, n))
                            : n.isMeshMatcapMaterial
                            ? (we(b, n),
                              (function (e, t) {
                                  t.matcap && (e.matcap.value = t.matcap);
                                  t.bumpMap && ((e.bumpMap.value = t.bumpMap), (e.bumpScale.value = t.bumpScale), t.side === g && (e.bumpScale.value *= -1));
                                  t.normalMap && ((e.normalMap.value = t.normalMap), e.normalScale.value.copy(t.normalScale), t.side === g && e.normalScale.value.negate());
                                  t.displacementMap && ((e.displacementMap.value = t.displacementMap), (e.displacementScale.value = t.displacementScale), (e.displacementBias.value = t.displacementBias));
                              })(b, n))
                            : n.isMeshDepthMaterial
                            ? (we(b, n),
                              (function (e, t) {
                                  t.displacementMap && ((e.displacementMap.value = t.displacementMap), (e.displacementScale.value = t.displacementScale), (e.displacementBias.value = t.displacementBias));
                              })(b, n))
                            : n.isMeshDistanceMaterial
                            ? (we(b, n),
                              (function (e, t) {
                                  t.displacementMap && ((e.displacementMap.value = t.displacementMap), (e.displacementScale.value = t.displacementScale), (e.displacementBias.value = t.displacementBias));
                                  e.referencePosition.value.copy(t.referencePosition), (e.nearDistance.value = t.nearDistance), (e.farDistance.value = t.farDistance);
                              })(b, n))
                            : n.isMeshNormalMaterial
                            ? (we(b, n),
                              (function (e, t) {
                                  t.bumpMap && ((e.bumpMap.value = t.bumpMap), (e.bumpScale.value = t.bumpScale), t.side === g && (e.bumpScale.value *= -1));
                                  t.normalMap && ((e.normalMap.value = t.normalMap), e.normalScale.value.copy(t.normalScale), t.side === g && e.normalScale.value.negate());
                                  t.displacementMap && ((e.displacementMap.value = t.displacementMap), (e.displacementScale.value = t.displacementScale), (e.displacementBias.value = t.displacementBias));
                              })(b, n))
                            : n.isLineBasicMaterial
                            ? ((function (e, t) {
                                  e.diffuse.value.copy(t.color), (e.opacity.value = t.opacity);
                              })(b, n),
                              n.isLineDashedMaterial &&
                                  (function (e, t) {
                                      (e.dashSize.value = t.dashSize), (e.totalSize.value = t.dashSize + t.gapSize), (e.scale.value = t.scale);
                                  })(b, n))
                            : n.isPointsMaterial
                            ? (function (e, t) {
                                  e.diffuse.value.copy(t.color), (e.opacity.value = t.opacity), (e.size.value = t.size * Y), (e.scale.value = 0.5 * X), t.map && (e.map.value = t.map);
                                  t.alphaMap && (e.alphaMap.value = t.alphaMap);
                                  var n;
                                  t.map ? (n = t.map) : t.alphaMap && (n = t.alphaMap);
                                  void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), e.uvTransform.value.copy(n.matrix));
                              })(b, n)
                            : n.isSpriteMaterial
                            ? (function (e, t) {
                                  e.diffuse.value.copy(t.color), (e.opacity.value = t.opacity), (e.rotation.value = t.rotation), t.map && (e.map.value = t.map);
                                  t.alphaMap && (e.alphaMap.value = t.alphaMap);
                                  var n;
                                  t.map ? (n = t.map) : t.alphaMap && (n = t.alphaMap);
                                  void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), e.uvTransform.value.copy(n.matrix));
                              })(b, n)
                            : n.isShadowMaterial && (b.color.value.copy(n.color), (b.opacity.value = n.opacity)),
                        void 0 !== b.ltc_1 && (b.ltc_1.value = mo.LTC_1),
                        void 0 !== b.ltc_2 && (b.ltc_2.value = mo.LTC_2),
                        La.upload(p, r.uniformsList, b, _),
                        n.isShaderMaterial && (n.uniformsNeedUpdate = !1)),
                    n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (La.upload(p, r.uniformsList, b, _), (n.uniformsNeedUpdate = !1)),
                    n.isSpriteMaterial && y.setValue(p, "center", i.center),
                    f.numMultiviewViews > 0 ? le.updateObjectMatricesUniforms(i, e, y) : (y.setValue(p, "modelViewMatrix", i.modelViewMatrix), y.setValue(p, "normalMatrix", i.normalMatrix)),
                    y.setValue(p, "modelMatrix", i.matrixWorld),
                    f
                );
            }
            function we(e, t) {
                var n;
                (e.opacity.value = t.opacity),
                    t.color && e.diffuse.value.copy(t.color),
                    t.emissive && e.emissive.value.copy(t.emissive).multiplyScalar(t.emissiveIntensity),
                    t.map && (e.map.value = t.map),
                    t.alphaMap && (e.alphaMap.value = t.alphaMap),
                    t.specularMap && (e.specularMap.value = t.specularMap),
                    t.envMap &&
                        ((e.envMap.value = t.envMap),
                        (e.flipEnvMap.value = t.envMap.isCubeTexture ? -1 : 1),
                        (e.reflectivity.value = t.reflectivity),
                        (e.refractionRatio.value = t.refractionRatio),
                        (e.maxMipLevel.value = x.get(t.envMap).__maxMipLevel)),
                    t.lightMap && ((e.lightMap.value = t.lightMap), (e.lightMapIntensity.value = t.lightMapIntensity)),
                    t.aoMap && ((e.aoMap.value = t.aoMap), (e.aoMapIntensity.value = t.aoMapIntensity)),
                    t.map
                        ? (n = t.map)
                        : t.specularMap
                        ? (n = t.specularMap)
                        : t.displacementMap
                        ? (n = t.displacementMap)
                        : t.normalMap
                        ? (n = t.normalMap)
                        : t.bumpMap
                        ? (n = t.bumpMap)
                        : t.roughnessMap
                        ? (n = t.roughnessMap)
                        : t.metalnessMap
                        ? (n = t.metalnessMap)
                        : t.alphaMap
                        ? (n = t.alphaMap)
                        : t.emissiveMap && (n = t.emissiveMap),
                    void 0 !== n && (n.isWebGLRenderTarget && (n = n.texture), !0 === n.matrixAutoUpdate && n.updateMatrix(), e.uvTransform.value.copy(n.matrix));
            }
            function Me(e, t) {
                e.specular.value.copy(t.specular),
                    (e.shininess.value = Math.max(t.shininess, 1e-4)),
                    t.emissiveMap && (e.emissiveMap.value = t.emissiveMap),
                    t.bumpMap && ((e.bumpMap.value = t.bumpMap), (e.bumpScale.value = t.bumpScale), t.side === g && (e.bumpScale.value *= -1)),
                    t.normalMap && ((e.normalMap.value = t.normalMap), e.normalScale.value.copy(t.normalScale), t.side === g && e.normalScale.value.negate()),
                    t.displacementMap && ((e.displacementMap.value = t.displacementMap), (e.displacementScale.value = t.displacementScale), (e.displacementBias.value = t.displacementBias));
            }
            function Se(e, t) {
                (e.roughness.value = t.roughness),
                    (e.metalness.value = t.metalness),
                    t.roughnessMap && (e.roughnessMap.value = t.roughnessMap),
                    t.metalnessMap && (e.metalnessMap.value = t.metalnessMap),
                    t.emissiveMap && (e.emissiveMap.value = t.emissiveMap),
                    t.bumpMap && ((e.bumpMap.value = t.bumpMap), (e.bumpScale.value = t.bumpScale), t.side === g && (e.bumpScale.value *= -1)),
                    t.normalMap && ((e.normalMap.value = t.normalMap), e.normalScale.value.copy(t.normalScale), t.side === g && e.normalScale.value.negate()),
                    t.displacementMap && ((e.displacementMap.value = t.displacementMap), (e.displacementScale.value = t.displacementScale), (e.displacementBias.value = t.displacementBias)),
                    t.envMap && (e.envMapIntensity.value = t.envMapIntensity);
            }
            ve.setAnimationLoop(function (e) {
                ce.isPresenting() || (me && me(e));
            }),
                "undefined" != typeof window && ve.setContext(window),
                (this.setAnimationLoop = function (e) {
                    (me = e), ce.setAnimationLoop(e), ve.start();
                }),
                (this.render = function (e, t) {
                    var n, i;
                    if (
                        (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), (n = arguments[2])),
                        void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), (i = arguments[3])),
                        t && t.isCamera)
                    ) {
                        if (!D) {
                            (G.geometry = null),
                                (G.program = null),
                                (G.wireframe = !1),
                                (F = -1),
                                (H = null),
                                !0 === e.autoUpdate && e.updateMatrixWorld(),
                                null === t.parent && t.updateMatrixWorld(),
                                ce.enabled && ce.isPresenting() && (t = ce.getCamera(t)),
                                (d = T.get(e, t)).init(),
                                e.onBeforeRender(O, e, t, n || B),
                                ne.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
                                Q.setFromMatrix(ne),
                                (te = this.localClippingEnabled),
                                (ee = $.init(this.clippingPlanes, te, t)),
                                (h = E.get(e, t)).init(),
                                ge(e, t, 0, O.sortObjects),
                                !0 === O.sortObjects && h.sort(),
                                ee && $.beginShadows();
                            var r = d.state.shadowsArray;
                            ue.render(r, e, t),
                                d.setupLights(t),
                                ee && $.endShadows(),
                                this.info.autoReset && this.info.reset(),
                                void 0 !== n && this.setRenderTarget(n),
                                ce.enabled && le.isAvailable() && le.attachCamera(t),
                                A.render(h, e, t, i);
                            var o = h.opaque,
                                a = h.transparent;
                            if (e.overrideMaterial) {
                                var s = e.overrideMaterial;
                                o.length && ye(o, e, t, s), a.length && ye(a, e, t, s);
                            } else o.length && ye(o, e, t), a.length && ye(a, e, t);
                            e.onAfterRender(O, e, t),
                                null !== B && (_.updateRenderTargetMipmap(B), _.updateMultisampleRenderTarget(B)),
                                v.buffers.depth.setTest(!0),
                                v.buffers.depth.setMask(!0),
                                v.buffers.color.setMask(!0),
                                v.setPolygonOffset(!1),
                                ce.enabled && (le.isAvailable() && le.detachCamera(t), ce.submitFrame()),
                                (h = null),
                                (d = null);
                        }
                    } else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                }),
                (this.setFramebuffer = function (e) {
                    I !== e && null === B && p.bindFramebuffer(36160, e), (I = e);
                }),
                (this.getActiveCubeFace = function () {
                    return N;
                }),
                (this.getActiveMipmapLevel = function () {
                    return U;
                }),
                (this.getRenderTarget = function () {
                    return B;
                }),
                (this.setRenderTarget = function (e, t, n) {
                    (B = e), (N = t), (U = n), e && void 0 === x.get(e).__webglFramebuffer && _.setupRenderTarget(e);
                    var i = I,
                        r = !1;
                    if (e) {
                        var o = x.get(e).__webglFramebuffer;
                        e.isWebGLRenderTargetCube ? ((i = o[t || 0]), (r = !0)) : (i = e.isWebGLMultisampleRenderTarget ? x.get(e).__webglMultisampledFramebuffer : o), k.copy(e.viewport), j.copy(e.scissor), (W = e.scissorTest);
                    } else k.copy(J).multiplyScalar(Y).floor(), j.copy(Z).multiplyScalar(Y).floor(), (W = K);
                    if ((z !== i && (p.bindFramebuffer(36160, i), (z = i)), v.viewport(k), v.scissor(j), v.setScissorTest(W), r)) {
                        var a = x.get(e.texture);
                        p.framebufferTexture2D(36160, 36064, 34069 + (t || 0), a.__webglTexture, n || 0);
                    }
                }),
                (this.readRenderTargetPixels = function (e, t, n, i, r, o, a) {
                    if (e && e.isWebGLRenderTarget) {
                        var s = x.get(e).__webglFramebuffer;
                        if ((e.isWebGLRenderTargetCube && void 0 !== a && (s = s[a]), s)) {
                            var c = !1;
                            s !== z && (p.bindFramebuffer(36160, s), (c = !0));
                            try {
                                var l = e.texture,
                                    u = l.format,
                                    h = l.type;
                                if (u !== je && P.convert(u) !== p.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                                if (
                                    !(
                                        h === Re ||
                                        P.convert(h) === p.getParameter(35738) ||
                                        (h === Ue && (m.isWebGL2 || f.get("OES_texture_float") || f.get("WEBGL_color_buffer_float"))) ||
                                        (h === Be && (m.isWebGL2 ? f.get("EXT_color_buffer_float") : f.get("EXT_color_buffer_half_float")))
                                    )
                                )
                                    return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                                36053 === p.checkFramebufferStatus(36160)
                                    ? t >= 0 && t <= e.width - i && n >= 0 && n <= e.height - r && p.readPixels(t, n, i, r, P.convert(u), P.convert(h), o)
                                    : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
                            } finally {
                                c && p.bindFramebuffer(36160, z);
                            }
                        }
                    } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                }),
                (this.copyFramebufferToTexture = function (e, t, n) {
                    void 0 === n && (n = 0);
                    var i = Math.pow(2, -n),
                        r = Math.floor(t.image.width * i),
                        o = Math.floor(t.image.height * i),
                        a = P.convert(t.format);
                    _.setTexture2D(t, 0), p.copyTexImage2D(3553, n, a, e.x, e.y, r, o, 0), v.unbindTexture();
                }),
                (this.copyTextureToTexture = function (e, t, n, i) {
                    var r = t.image.width,
                        o = t.image.height,
                        a = P.convert(n.format),
                        s = P.convert(n.type);
                    _.setTexture2D(n, 0), t.isDataTexture ? p.texSubImage2D(3553, i || 0, e.x, e.y, r, o, a, s, t.image.data) : p.texSubImage2D(3553, i || 0, e.x, e.y, a, s, t.image), v.unbindTexture();
                }),
                (this.initTexture = function (e) {
                    _.setTexture2D(e, 0), v.unbindTexture();
                }),
                "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
        }
        function Ms(e, t) {
            (this.name = ""), (this.color = new Zi(e)), (this.density = void 0 !== t ? t : 25e-5);
        }
        function Ss(e, t, n) {
            (this.name = ""), (this.color = new Zi(e)), (this.near = void 0 !== t ? t : 1), (this.far = void 0 !== n ? n : 1e3);
        }
        function Es(e, t) {
            (this.array = e), (this.stride = t), (this.count = void 0 !== e ? e.length / t : 0), (this.usage = sn), (this.updateRange = { offset: 0, count: -1 }), (this.version = 0);
        }
        function Ts(e, t, n, i) {
            (this.data = e), (this.itemSize = t), (this.offset = n), (this.normalized = !0 === i);
        }
        function As(e) {
            nr.call(this), (this.type = "SpriteMaterial"), (this.color = new Zi(16777215)), (this.map = null), (this.alphaMap = null), (this.rotation = 0), (this.sizeAttenuation = !0), (this.transparent = !0), this.setValues(e);
        }
        Object.assign(_s.prototype, vn.prototype),
            Object.assign(bs.prototype, vn.prototype),
            Object.assign(Ms.prototype, {
                isFogExp2: !0,
                clone: function () {
                    return new Ms(this.color, this.density);
                },
                toJSON: function () {
                    return { type: "FogExp2", color: this.color.getHex(), density: this.density };
                },
            }),
            Object.assign(Ss.prototype, {
                isFog: !0,
                clone: function () {
                    return new Ss(this.color, this.near, this.far);
                },
                toJSON: function () {
                    return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far };
                },
            }),
            Object.defineProperty(Es.prototype, "needsUpdate", {
                set: function (e) {
                    !0 === e && this.version++;
                },
            }),
            Object.assign(Es.prototype, {
                isInterleavedBuffer: !0,
                onUploadCallback: function () {},
                setUsage: function (e) {
                    return (this.usage = e), this;
                },
                copy: function (e) {
                    return (this.array = new e.array.constructor(e.array)), (this.count = e.count), (this.stride = e.stride), (this.usage = e.usage), this;
                },
                copyAt: function (e, t, n) {
                    (e *= this.stride), (n *= t.stride);
                    for (var i = 0, r = this.stride; i < r; i++) this.array[e + i] = t.array[n + i];
                    return this;
                },
                set: function (e, t) {
                    return void 0 === t && (t = 0), this.array.set(e, t), this;
                },
                clone: function () {
                    return new this.constructor().copy(this);
                },
                onUpload: function (e) {
                    return (this.onUploadCallback = e), this;
                },
            }),
            Object.defineProperties(Ts.prototype, {
                count: {
                    get: function () {
                        return this.data.count;
                    },
                },
                array: {
                    get: function () {
                        return this.data.array;
                    },
                },
            }),
            Object.assign(Ts.prototype, {
                isInterleavedBufferAttribute: !0,
                setX: function (e, t) {
                    return (this.data.array[e * this.data.stride + this.offset] = t), this;
                },
                setY: function (e, t) {
                    return (this.data.array[e * this.data.stride + this.offset + 1] = t), this;
                },
                setZ: function (e, t) {
                    return (this.data.array[e * this.data.stride + this.offset + 2] = t), this;
                },
                setW: function (e, t) {
                    return (this.data.array[e * this.data.stride + this.offset + 3] = t), this;
                },
                getX: function (e) {
                    return this.data.array[e * this.data.stride + this.offset];
                },
                getY: function (e) {
                    return this.data.array[e * this.data.stride + this.offset + 1];
                },
                getZ: function (e) {
                    return this.data.array[e * this.data.stride + this.offset + 2];
                },
                getW: function (e) {
                    return this.data.array[e * this.data.stride + this.offset + 3];
                },
                setXY: function (e, t, n) {
                    return (e = e * this.data.stride + this.offset), (this.data.array[e + 0] = t), (this.data.array[e + 1] = n), this;
                },
                setXYZ: function (e, t, n, i) {
                    return (e = e * this.data.stride + this.offset), (this.data.array[e + 0] = t), (this.data.array[e + 1] = n), (this.data.array[e + 2] = i), this;
                },
                setXYZW: function (e, t, n, i, r) {
                    return (e = e * this.data.stride + this.offset), (this.data.array[e + 0] = t), (this.data.array[e + 1] = n), (this.data.array[e + 2] = i), (this.data.array[e + 3] = r), this;
                },
            }),
            (As.prototype = Object.create(nr.prototype)),
            (As.prototype.constructor = As),
            (As.prototype.isSpriteMaterial = !0),
            (As.prototype.copy = function (e) {
                return nr.prototype.copy.call(this, e), this.color.copy(e.color), (this.map = e.map), (this.alphaMap = e.alphaMap), (this.rotation = e.rotation), (this.sizeAttenuation = e.sizeAttenuation), this;
            });
        var Ls = new Sn(),
            Cs = new Sn(),
            Rs = new Sn(),
            Ps = new _n(),
            Os = new _n(),
            Ds = new Hn(),
            Is = new Sn(),
            Ns = new Sn(),
            Us = new Sn(),
            Bs = new _n(),
            zs = new _n(),
            Fs = new _n();
        function Gs(e) {
            if ((oi.call(this), (this.type = "Sprite"), void 0 === vs)) {
                vs = new Mr();
                var t = new Es(new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]), 5);
                vs.setIndex([0, 1, 2, 0, 2, 3]), vs.setAttribute("position", new Ts(t, 3, 0, !1)), vs.setAttribute("uv", new Ts(t, 2, 3, !1));
            }
            (this.geometry = vs), (this.material = void 0 !== e ? e : new As()), (this.center = new _n(0.5, 0.5));
        }
        function Hs(e, t, n, i, r, o) {
            Ps.subVectors(e, n).addScalar(0.5).multiply(i), void 0 !== r ? ((Os.x = o * Ps.x - r * Ps.y), (Os.y = r * Ps.x + o * Ps.y)) : Os.copy(Ps), e.copy(t), (e.x += Os.x), (e.y += Os.y), e.applyMatrix4(Ds);
        }
        Gs.prototype = Object.assign(Object.create(oi.prototype), {
            constructor: Gs,
            isSprite: !0,
            raycast: function (e, t) {
                null === e.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),
                    Cs.setFromMatrixScale(this.matrixWorld),
                    Ds.copy(e.camera.matrixWorld),
                    this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld),
                    Rs.setFromMatrixPosition(this.modelViewMatrix),
                    e.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && Cs.multiplyScalar(-Rs.z);
                var n,
                    i,
                    r = this.material.rotation;
                0 !== r && ((i = Math.cos(r)), (n = Math.sin(r)));
                var o = this.center;
                Hs(Is.set(-0.5, -0.5, 0), Rs, o, Cs, n, i), Hs(Ns.set(0.5, -0.5, 0), Rs, o, Cs, n, i), Hs(Us.set(0.5, 0.5, 0), Rs, o, Cs, n, i), Bs.set(0, 0), zs.set(1, 0), Fs.set(1, 1);
                var a = e.ray.intersectTriangle(Is, Ns, Us, !1, Ls);
                if (null !== a || (Hs(Ns.set(-0.5, 0.5, 0), Rs, o, Cs, n, i), zs.set(0, 1), null !== (a = e.ray.intersectTriangle(Is, Us, Ns, !1, Ls)))) {
                    var s = e.ray.origin.distanceTo(Ls);
                    s < e.near || s > e.far || t.push({ distance: s, point: Ls.clone(), uv: qi.getUV(Ls, Is, Ns, Us, Bs, zs, Fs, new _n()), face: null, object: this });
                }
            },
            clone: function () {
                return new this.constructor(this.material).copy(this);
            },
            copy: function (e) {
                return oi.prototype.copy.call(this, e), void 0 !== e.center && this.center.copy(e.center), this;
            },
        });
        var Vs = new Sn(),
            ks = new Sn();
        function js() {
            oi.call(this), (this.type = "LOD"), Object.defineProperties(this, { levels: { enumerable: !0, value: [] } }), (this.autoUpdate = !0);
        }
        function Ws(e, t) {
            e && e.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."),
                Hr.call(this, e, t),
                (this.type = "SkinnedMesh"),
                (this.bindMode = "attached"),
                (this.bindMatrix = new Hn()),
                (this.bindMatrixInverse = new Hn());
        }
        (js.prototype = Object.assign(Object.create(oi.prototype), {
            constructor: js,
            isLOD: !0,
            copy: function (e) {
                oi.prototype.copy.call(this, e, !1);
                for (var t = e.levels, n = 0, i = t.length; n < i; n++) {
                    var r = t[n];
                    this.addLevel(r.object.clone(), r.distance);
                }
                return (this.autoUpdate = e.autoUpdate), this;
            },
            addLevel: function (e, t) {
                void 0 === t && (t = 0), (t = Math.abs(t));
                for (var n = this.levels, i = 0; i < n.length && !(t < n[i].distance); i++);
                return n.splice(i, 0, { distance: t, object: e }), this.add(e), this;
            },
            getObjectForDistance: function (e) {
                var t = this.levels;
                if (t.length > 0) {
                    for (var n = 1, i = t.length; n < i && !(e < t[n].distance); n++);
                    return t[n - 1].object;
                }
                return null;
            },
            raycast: function (e, t) {
                if (this.levels.length > 0) {
                    Vs.setFromMatrixPosition(this.matrixWorld);
                    var n = e.ray.origin.distanceTo(Vs);
                    this.getObjectForDistance(n).raycast(e, t);
                }
            },
            update: function (e) {
                var t = this.levels;
                if (t.length > 1) {
                    Vs.setFromMatrixPosition(e.matrixWorld), ks.setFromMatrixPosition(this.matrixWorld);
                    var n = Vs.distanceTo(ks);
                    t[0].object.visible = !0;
                    for (var i = 1, r = t.length; i < r && n >= t[i].distance; i++) (t[i - 1].object.visible = !1), (t[i].object.visible = !0);
                    for (; i < r; i++) t[i].object.visible = !1;
                }
            },
            toJSON: function (e) {
                var t = oi.prototype.toJSON.call(this, e);
                !1 === this.autoUpdate && (t.object.autoUpdate = !1), (t.object.levels = []);
                for (var n = this.levels, i = 0, r = n.length; i < r; i++) {
                    var o = n[i];
                    t.object.levels.push({ object: o.object.uuid, distance: o.distance });
                }
                return t;
            },
        })),
            (Ws.prototype = Object.assign(Object.create(Hr.prototype), {
                constructor: Ws,
                isSkinnedMesh: !0,
                bind: function (e, t) {
                    (this.skeleton = e), void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), (t = this.matrixWorld)), this.bindMatrix.copy(t), this.bindMatrixInverse.getInverse(t);
                },
                pose: function () {
                    this.skeleton.pose();
                },
                normalizeSkinWeights: function () {
                    for (var e = new Pn(), t = this.geometry.attributes.skinWeight, n = 0, i = t.count; n < i; n++) {
                        (e.x = t.getX(n)), (e.y = t.getY(n)), (e.z = t.getZ(n)), (e.w = t.getW(n));
                        var r = 1 / e.manhattanLength();
                        r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w);
                    }
                },
                updateMatrixWorld: function (e) {
                    Hr.prototype.updateMatrixWorld.call(this, e),
                        "attached" === this.bindMode
                            ? this.bindMatrixInverse.getInverse(this.matrixWorld)
                            : "detached" === this.bindMode
                            ? this.bindMatrixInverse.getInverse(this.bindMatrix)
                            : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
                },
                clone: function () {
                    return new this.constructor(this.geometry, this.material).copy(this);
                },
            }));
        var qs = new Hn(),
            Xs = new Hn();
        function Ys(e, t) {
            if (((e = e || []), (this.bones = e.slice(0)), (this.boneMatrices = new Float32Array(16 * this.bones.length)), (this.frame = -1), void 0 === t)) this.calculateInverses();
            else if (this.bones.length === t.length) this.boneInverses = t.slice(0);
            else {
                console.warn("THREE.Skeleton boneInverses is the wrong length."), (this.boneInverses = []);
                for (var n = 0, i = this.bones.length; n < i; n++) this.boneInverses.push(new Hn());
            }
        }
        function Js() {
            oi.call(this), (this.type = "Bone");
        }
        Object.assign(Ys.prototype, {
            calculateInverses: function () {
                this.boneInverses = [];
                for (var e = 0, t = this.bones.length; e < t; e++) {
                    var n = new Hn();
                    this.bones[e] && n.getInverse(this.bones[e].matrixWorld), this.boneInverses.push(n);
                }
            },
            pose: function () {
                var e, t, n;
                for (t = 0, n = this.bones.length; t < n; t++) (e = this.bones[t]) && e.matrixWorld.getInverse(this.boneInverses[t]);
                for (t = 0, n = this.bones.length; t < n; t++)
                    (e = this.bones[t]) && (e.parent && e.parent.isBone ? (e.matrix.getInverse(e.parent.matrixWorld), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale));
            },
            update: function () {
                for (var e = this.bones, t = this.boneInverses, n = this.boneMatrices, i = this.boneTexture, r = 0, o = e.length; r < o; r++) {
                    var a = e[r] ? e[r].matrixWorld : Xs;
                    qs.multiplyMatrices(a, t[r]), qs.toArray(n, 16 * r);
                }
                void 0 !== i && (i.needsUpdate = !0);
            },
            clone: function () {
                return new Ys(this.bones, this.boneInverses);
            },
            getBoneByName: function (e) {
                for (var t = 0, n = this.bones.length; t < n; t++) {
                    var i = this.bones[t];
                    if (i.name === e) return i;
                }
            },
        }),
            (Js.prototype = Object.assign(Object.create(oi.prototype), { constructor: Js, isBone: !0 }));
        var Zs = new Hn(),
            Ks = new Hn(),
            Qs = [],
            $s = new Hr();
        function ec(e, t, n) {
            Hr.call(this, e, t), (this.instanceMatrix = new rr(new Float32Array(16 * n), 16)), (this.count = n);
        }
        function tc(e) {
            nr.call(this), (this.type = "LineBasicMaterial"), (this.color = new Zi(16777215)), (this.linewidth = 1), (this.linecap = "round"), (this.linejoin = "round"), this.setValues(e);
        }
        (ec.prototype = Object.assign(Object.create(Hr.prototype), {
            constructor: ec,
            isInstancedMesh: !0,
            getMatrixAt: function (e, t) {
                t.fromArray(this.instanceMatrix.array, 16 * e);
            },
            raycast: function (e, t) {
                var n = this.matrixWorld,
                    i = this.count;
                if ((($s.geometry = this.geometry), ($s.material = this.material), void 0 !== $s.material))
                    for (var r = 0; r < i; r++) this.getMatrixAt(r, Zs), Ks.multiplyMatrices(n, Zs), ($s.matrixWorld = Ks), $s.raycast(e, Qs), Qs.length > 0 && ((Qs[0].instanceId = r), (Qs[0].object = this), t.push(Qs[0]), (Qs.length = 0));
            },
            setMatrixAt: function (e, t) {
                t.toArray(this.instanceMatrix.array, 16 * e);
            },
            updateMorphTargets: function () {},
        })),
            (tc.prototype = Object.create(nr.prototype)),
            (tc.prototype.constructor = tc),
            (tc.prototype.isLineBasicMaterial = !0),
            (tc.prototype.copy = function (e) {
                return nr.prototype.copy.call(this, e), this.color.copy(e.color), (this.linewidth = e.linewidth), (this.linecap = e.linecap), (this.linejoin = e.linejoin), this;
            });
        var nc = new Sn(),
            ic = new Sn(),
            rc = new Hn(),
            oc = new Pi(),
            ac = new Mi();
        function sc(e, t, n) {
            1 === n && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."),
                oi.call(this),
                (this.type = "Line"),
                (this.geometry = void 0 !== e ? e : new Mr()),
                (this.material = void 0 !== t ? t : new tc({ color: 16777215 * Math.random() }));
        }
        sc.prototype = Object.assign(Object.create(oi.prototype), {
            constructor: sc,
            isLine: !0,
            computeLineDistances: function () {
                var e = this.geometry;
                if (e.isBufferGeometry)
                    if (null === e.index) {
                        for (var t = e.attributes.position, n = [0], i = 1, r = t.count; i < r; i++) nc.fromBufferAttribute(t, i - 1), ic.fromBufferAttribute(t, i), (n[i] = n[i - 1]), (n[i] += nc.distanceTo(ic));
                        e.setAttribute("lineDistance", new dr(n, 1));
                    } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else if (e.isGeometry) {
                    var o = e.vertices;
                    (n = e.lineDistances)[0] = 0;
                    for (i = 1, r = o.length; i < r; i++) (n[i] = n[i - 1]), (n[i] += o[i - 1].distanceTo(o[i]));
                }
                return this;
            },
            raycast: function (e, t) {
                var n = e.linePrecision,
                    i = this.geometry,
                    r = this.matrixWorld;
                if ((null === i.boundingSphere && i.computeBoundingSphere(), ac.copy(i.boundingSphere), ac.applyMatrix4(r), (ac.radius += n), !1 !== e.ray.intersectsSphere(ac))) {
                    rc.getInverse(r), oc.copy(e.ray).applyMatrix4(rc);
                    var o = n / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        a = o * o,
                        s = new Sn(),
                        c = new Sn(),
                        l = new Sn(),
                        u = new Sn(),
                        h = this && this.isLineSegments ? 2 : 1;
                    if (i.isBufferGeometry) {
                        var d = i.index,
                            p = i.attributes.position.array;
                        if (null !== d)
                            for (var f = d.array, m = 0, v = f.length - 1; m < v; m += h) {
                                var g = f[m],
                                    y = f[m + 1];
                                if ((s.fromArray(p, 3 * g), c.fromArray(p, 3 * y), !(oc.distanceSqToSegment(s, c, u, l) > a)))
                                    u.applyMatrix4(this.matrixWorld),
                                        (b = e.ray.origin.distanceTo(u)) < e.near || b > e.far || t.push({ distance: b, point: l.clone().applyMatrix4(this.matrixWorld), index: m, face: null, faceIndex: null, object: this });
                            }
                        else
                            for (m = 0, v = p.length / 3 - 1; m < v; m += h) {
                                if ((s.fromArray(p, 3 * m), c.fromArray(p, 3 * m + 3), !(oc.distanceSqToSegment(s, c, u, l) > a)))
                                    u.applyMatrix4(this.matrixWorld),
                                        (b = e.ray.origin.distanceTo(u)) < e.near || b > e.far || t.push({ distance: b, point: l.clone().applyMatrix4(this.matrixWorld), index: m, face: null, faceIndex: null, object: this });
                            }
                    } else if (i.isGeometry) {
                        var x = i.vertices,
                            _ = x.length;
                        for (m = 0; m < _ - 1; m += h) {
                            var b;
                            if (!(oc.distanceSqToSegment(x[m], x[m + 1], u, l) > a))
                                u.applyMatrix4(this.matrixWorld),
                                    (b = e.ray.origin.distanceTo(u)) < e.near || b > e.far || t.push({ distance: b, point: l.clone().applyMatrix4(this.matrixWorld), index: m, face: null, faceIndex: null, object: this });
                        }
                    }
                }
            },
            clone: function () {
                return new this.constructor(this.geometry, this.material).copy(this);
            },
        });
        var cc = new Sn(),
            lc = new Sn();
        function uc(e, t) {
            sc.call(this, e, t), (this.type = "LineSegments");
        }
        function hc(e, t) {
            sc.call(this, e, t), (this.type = "LineLoop");
        }
        function dc(e) {
            nr.call(this), (this.type = "PointsMaterial"), (this.color = new Zi(16777215)), (this.map = null), (this.alphaMap = null), (this.size = 1), (this.sizeAttenuation = !0), (this.morphTargets = !1), this.setValues(e);
        }
        (uc.prototype = Object.assign(Object.create(sc.prototype), {
            constructor: uc,
            isLineSegments: !0,
            computeLineDistances: function () {
                var e = this.geometry;
                if (e.isBufferGeometry)
                    if (null === e.index) {
                        for (var t = e.attributes.position, n = [], i = 0, r = t.count; i < r; i += 2) cc.fromBufferAttribute(t, i), lc.fromBufferAttribute(t, i + 1), (n[i] = 0 === i ? 0 : n[i - 1]), (n[i + 1] = n[i] + cc.distanceTo(lc));
                        e.setAttribute("lineDistance", new dr(n, 1));
                    } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else if (e.isGeometry) {
                    var o = e.vertices;
                    for (n = e.lineDistances, i = 0, r = o.length; i < r; i += 2) cc.copy(o[i]), lc.copy(o[i + 1]), (n[i] = 0 === i ? 0 : n[i - 1]), (n[i + 1] = n[i] + cc.distanceTo(lc));
                }
                return this;
            },
        })),
            (hc.prototype = Object.assign(Object.create(sc.prototype), { constructor: hc, isLineLoop: !0 })),
            (dc.prototype = Object.create(nr.prototype)),
            (dc.prototype.constructor = dc),
            (dc.prototype.isPointsMaterial = !0),
            (dc.prototype.copy = function (e) {
                return (
                    nr.prototype.copy.call(this, e), this.color.copy(e.color), (this.map = e.map), (this.alphaMap = e.alphaMap), (this.size = e.size), (this.sizeAttenuation = e.sizeAttenuation), (this.morphTargets = e.morphTargets), this
                );
            });
        var pc = new Hn(),
            fc = new Pi(),
            mc = new Mi(),
            vc = new Sn();
        function gc(e, t) {
            oi.call(this), (this.type = "Points"), (this.geometry = void 0 !== e ? e : new Mr()), (this.material = void 0 !== t ? t : new dc({ color: 16777215 * Math.random() })), this.updateMorphTargets();
        }
        function yc(e, t, n, i, r, o, a) {
            var s = fc.distanceSqToPoint(e);
            if (s < n) {
                var c = new Sn();
                fc.closestPointToPoint(e, c), c.applyMatrix4(i);
                var l = r.ray.origin.distanceTo(c);
                if (l < r.near || l > r.far) return;
                o.push({ distance: l, distanceToRay: Math.sqrt(s), point: c, index: t, face: null, object: a });
            }
        }
        function xc(e, t, n, i, r, o, a, s, c) {
            Rn.call(this, e, t, n, i, r, o, a, s, c), (this.format = void 0 !== a ? a : ke), (this.minFilter = void 0 !== o ? o : Ee), (this.magFilter = void 0 !== r ? r : Ee), (this.generateMipmaps = !1);
        }
        function _c(e, t, n, i, r, o, a, s, c, l, u, h) {
            Rn.call(this, null, o, a, s, c, l, i, r, u, h), (this.image = { width: t, height: n }), (this.mipmaps = e), (this.flipY = !1), (this.generateMipmaps = !1);
        }
        function bc(e, t, n, i, r, o, a, s, c) {
            Rn.call(this, e, t, n, i, r, o, a, s, c), (this.needsUpdate = !0);
        }
        function wc(e, t, n, i, r, o, a, s, c, l) {
            if ((l = void 0 !== l ? l : Ye) !== Ye && l !== Je) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
            void 0 === n && l === Ye && (n = De),
                void 0 === n && l === Je && (n = He),
                Rn.call(this, null, i, r, o, a, s, l, n, c),
                (this.image = { width: e, height: t }),
                (this.magFilter = void 0 !== a ? a : _e),
                (this.minFilter = void 0 !== s ? s : _e),
                (this.flipY = !1),
                (this.generateMipmaps = !1);
        }
        function Mc(e) {
            Mr.call(this), (this.type = "WireframeGeometry");
            var t,
                n,
                i,
                r,
                o,
                a,
                s,
                c,
                l,
                u,
                h = [],
                d = [0, 0],
                p = {},
                f = ["a", "b", "c"];
            if (e && e.isGeometry) {
                var m = e.faces;
                for (t = 0, i = m.length; t < i; t++) {
                    var v = m[t];
                    for (n = 0; n < 3; n++) (s = v[f[n]]), (c = v[f[(n + 1) % 3]]), (d[0] = Math.min(s, c)), (d[1] = Math.max(s, c)), void 0 === p[(l = d[0] + "," + d[1])] && (p[l] = { index1: d[0], index2: d[1] });
                }
                for (l in p) (a = p[l]), (u = e.vertices[a.index1]), h.push(u.x, u.y, u.z), (u = e.vertices[a.index2]), h.push(u.x, u.y, u.z);
            } else if (e && e.isBufferGeometry) {
                var g, y, x, _, b, w, M;
                if (((u = new Sn()), null !== e.index)) {
                    for (g = e.attributes.position, y = e.index, 0 === (x = e.groups).length && (x = [{ start: 0, count: y.count, materialIndex: 0 }]), r = 0, o = x.length; r < o; ++r)
                        for (t = b = (_ = x[r]).start, i = b + _.count; t < i; t += 3)
                            for (n = 0; n < 3; n++) (s = y.getX(t + n)), (c = y.getX(t + ((n + 1) % 3))), (d[0] = Math.min(s, c)), (d[1] = Math.max(s, c)), void 0 === p[(l = d[0] + "," + d[1])] && (p[l] = { index1: d[0], index2: d[1] });
                    for (l in p) (a = p[l]), u.fromBufferAttribute(g, a.index1), h.push(u.x, u.y, u.z), u.fromBufferAttribute(g, a.index2), h.push(u.x, u.y, u.z);
                } else
                    for (t = 0, i = (g = e.attributes.position).count / 3; t < i; t++)
                        for (n = 0; n < 3; n++) (w = 3 * t + n), u.fromBufferAttribute(g, w), h.push(u.x, u.y, u.z), (M = 3 * t + ((n + 1) % 3)), u.fromBufferAttribute(g, M), h.push(u.x, u.y, u.z);
            }
            this.setAttribute("position", new dr(h, 3));
        }
        function Sc(e, t, n) {
            Yr.call(this), (this.type = "ParametricGeometry"), (this.parameters = { func: e, slices: t, stacks: n }), this.fromBufferGeometry(new Ec(e, t, n)), this.mergeVertices();
        }
        function Ec(e, t, n) {
            Mr.call(this), (this.type = "ParametricBufferGeometry"), (this.parameters = { func: e, slices: t, stacks: n });
            var i,
                r,
                o = [],
                a = [],
                s = [],
                c = [],
                l = new Sn(),
                u = new Sn(),
                h = new Sn(),
                d = new Sn(),
                p = new Sn();
            e.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
            var f = t + 1;
            for (i = 0; i <= n; i++) {
                var m = i / n;
                for (r = 0; r <= t; r++) {
                    var v = r / t;
                    e(v, m, u),
                        a.push(u.x, u.y, u.z),
                        v - 1e-5 >= 0 ? (e(v - 1e-5, m, h), d.subVectors(u, h)) : (e(v + 1e-5, m, h), d.subVectors(h, u)),
                        m - 1e-5 >= 0 ? (e(v, m - 1e-5, h), p.subVectors(u, h)) : (e(v, m + 1e-5, h), p.subVectors(h, u)),
                        l.crossVectors(d, p).normalize(),
                        s.push(l.x, l.y, l.z),
                        c.push(v, m);
                }
            }
            for (i = 0; i < n; i++)
                for (r = 0; r < t; r++) {
                    var g = i * f + r,
                        y = i * f + r + 1,
                        x = (i + 1) * f + r + 1,
                        _ = (i + 1) * f + r;
                    o.push(g, y, _), o.push(y, x, _);
                }
            this.setIndex(o), this.setAttribute("position", new dr(a, 3)), this.setAttribute("normal", new dr(s, 3)), this.setAttribute("uv", new dr(c, 2));
        }
        function Tc(e, t, n, i) {
            Yr.call(this), (this.type = "PolyhedronGeometry"), (this.parameters = { vertices: e, indices: t, radius: n, detail: i }), this.fromBufferGeometry(new Ac(e, t, n, i)), this.mergeVertices();
        }
        function Ac(e, t, n, i) {
            Mr.call(this), (this.type = "PolyhedronBufferGeometry"), (this.parameters = { vertices: e, indices: t, radius: n, detail: i }), (n = n || 1);
            var r = [],
                o = [];
            function a(e, t, n, i) {
                var r,
                    o,
                    a = Math.pow(2, i),
                    c = [];
                for (r = 0; r <= a; r++) {
                    c[r] = [];
                    var l = e.clone().lerp(n, r / a),
                        u = t.clone().lerp(n, r / a),
                        h = a - r;
                    for (o = 0; o <= h; o++) c[r][o] = 0 === o && r === a ? l : l.clone().lerp(u, o / h);
                }
                for (r = 0; r < a; r++)
                    for (o = 0; o < 2 * (a - r) - 1; o++) {
                        var d = Math.floor(o / 2);
                        o % 2 == 0 ? (s(c[r][d + 1]), s(c[r + 1][d]), s(c[r][d])) : (s(c[r][d + 1]), s(c[r + 1][d + 1]), s(c[r + 1][d]));
                    }
            }
            function s(e) {
                r.push(e.x, e.y, e.z);
            }
            function c(t, n) {
                var i = 3 * t;
                (n.x = e[i + 0]), (n.y = e[i + 1]), (n.z = e[i + 2]);
            }
            function l(e, t, n, i) {
                i < 0 && 1 === e.x && (o[t] = e.x - 1), 0 === n.x && 0 === n.z && (o[t] = i / 2 / Math.PI + 0.5);
            }
            function u(e) {
                return Math.atan2(e.z, -e.x);
            }
            !(function (e) {
                for (var n = new Sn(), i = new Sn(), r = new Sn(), o = 0; o < t.length; o += 3) c(t[o + 0], n), c(t[o + 1], i), c(t[o + 2], r), a(n, i, r, e);
            })((i = i || 0)),
                (function (e) {
                    for (var t = new Sn(), n = 0; n < r.length; n += 3) (t.x = r[n + 0]), (t.y = r[n + 1]), (t.z = r[n + 2]), t.normalize().multiplyScalar(e), (r[n + 0] = t.x), (r[n + 1] = t.y), (r[n + 2] = t.z);
                })(n),
                (function () {
                    for (var e = new Sn(), t = 0; t < r.length; t += 3) {
                        (e.x = r[t + 0]), (e.y = r[t + 1]), (e.z = r[t + 2]);
                        var n = u(e) / 2 / Math.PI + 0.5,
                            i = ((a = e), Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI + 0.5);
                        o.push(n, 1 - i);
                    }
                    var a;
                    (function () {
                        for (var e = new Sn(), t = new Sn(), n = new Sn(), i = new Sn(), a = new _n(), s = new _n(), c = new _n(), h = 0, d = 0; h < r.length; h += 9, d += 6) {
                            e.set(r[h + 0], r[h + 1], r[h + 2]),
                                t.set(r[h + 3], r[h + 4], r[h + 5]),
                                n.set(r[h + 6], r[h + 7], r[h + 8]),
                                a.set(o[d + 0], o[d + 1]),
                                s.set(o[d + 2], o[d + 3]),
                                c.set(o[d + 4], o[d + 5]),
                                i.copy(e).add(t).add(n).divideScalar(3);
                            var p = u(i);
                            l(a, d + 0, e, p), l(s, d + 2, t, p), l(c, d + 4, n, p);
                        }
                    })(),
                        (function () {
                            for (var e = 0; e < o.length; e += 6) {
                                var t = o[e + 0],
                                    n = o[e + 2],
                                    i = o[e + 4],
                                    r = Math.max(t, n, i),
                                    a = Math.min(t, n, i);
                                r > 0.9 && a < 0.1 && (t < 0.2 && (o[e + 0] += 1), n < 0.2 && (o[e + 2] += 1), i < 0.2 && (o[e + 4] += 1));
                            }
                        })();
                })(),
                this.setAttribute("position", new dr(r, 3)),
                this.setAttribute("normal", new dr(r.slice(), 3)),
                this.setAttribute("uv", new dr(o, 2)),
                0 === i ? this.computeVertexNormals() : this.normalizeNormals();
        }
        function Lc(e, t) {
            Yr.call(this), (this.type = "TetrahedronGeometry"), (this.parameters = { radius: e, detail: t }), this.fromBufferGeometry(new Cc(e, t)), this.mergeVertices();
        }
        function Cc(e, t) {
            Ac.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t), (this.type = "TetrahedronBufferGeometry"), (this.parameters = { radius: e, detail: t });
        }
        function Rc(e, t) {
            Yr.call(this), (this.type = "OctahedronGeometry"), (this.parameters = { radius: e, detail: t }), this.fromBufferGeometry(new Pc(e, t)), this.mergeVertices();
        }
        function Pc(e, t) {
            Ac.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t),
                (this.type = "OctahedronBufferGeometry"),
                (this.parameters = { radius: e, detail: t });
        }
        function Oc(e, t) {
            Yr.call(this), (this.type = "IcosahedronGeometry"), (this.parameters = { radius: e, detail: t }), this.fromBufferGeometry(new Dc(e, t)), this.mergeVertices();
        }
        function Dc(e, t) {
            var n = (1 + Math.sqrt(5)) / 2,
                i = [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1];
            Ac.call(this, i, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t),
                (this.type = "IcosahedronBufferGeometry"),
                (this.parameters = { radius: e, detail: t });
        }
        function Ic(e, t) {
            Yr.call(this), (this.type = "DodecahedronGeometry"), (this.parameters = { radius: e, detail: t }), this.fromBufferGeometry(new Nc(e, t)), this.mergeVertices();
        }
        function Nc(e, t) {
            var n = (1 + Math.sqrt(5)) / 2,
                i = 1 / n,
                r = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, 0, -n, 0, -i, n, 0, -i, -n, 0, i, n, 0, i];
            Ac.call(
                this,
                r,
                [
                    3,
                    11,
                    7,
                    3,
                    7,
                    15,
                    3,
                    15,
                    13,
                    7,
                    19,
                    17,
                    7,
                    17,
                    6,
                    7,
                    6,
                    15,
                    17,
                    4,
                    8,
                    17,
                    8,
                    10,
                    17,
                    10,
                    6,
                    8,
                    0,
                    16,
                    8,
                    16,
                    2,
                    8,
                    2,
                    10,
                    0,
                    12,
                    1,
                    0,
                    1,
                    18,
                    0,
                    18,
                    16,
                    6,
                    10,
                    2,
                    6,
                    2,
                    13,
                    6,
                    13,
                    15,
                    2,
                    16,
                    18,
                    2,
                    18,
                    3,
                    2,
                    3,
                    13,
                    18,
                    1,
                    9,
                    18,
                    9,
                    11,
                    18,
                    11,
                    3,
                    4,
                    14,
                    12,
                    4,
                    12,
                    0,
                    4,
                    0,
                    8,
                    11,
                    9,
                    5,
                    11,
                    5,
                    19,
                    11,
                    19,
                    7,
                    19,
                    5,
                    14,
                    19,
                    14,
                    4,
                    19,
                    4,
                    17,
                    1,
                    12,
                    14,
                    1,
                    14,
                    5,
                    1,
                    5,
                    9,
                ],
                e,
                t
            ),
                (this.type = "DodecahedronBufferGeometry"),
                (this.parameters = { radius: e, detail: t });
        }
        function Uc(e, t, n, i, r, o) {
            Yr.call(this), (this.type = "TubeGeometry"), (this.parameters = { path: e, tubularSegments: t, radius: n, radialSegments: i, closed: r }), void 0 !== o && console.warn("THREE.TubeGeometry: taper has been removed.");
            var a = new Bc(e, t, n, i, r);
            (this.tangents = a.tangents), (this.normals = a.normals), (this.binormals = a.binormals), this.fromBufferGeometry(a), this.mergeVertices();
        }
        function Bc(e, t, n, i, r) {
            Mr.call(this), (this.type = "TubeBufferGeometry"), (this.parameters = { path: e, tubularSegments: t, radius: n, radialSegments: i, closed: r }), (t = t || 64), (n = n || 1), (i = i || 8), (r = r || !1);
            var o = e.computeFrenetFrames(t, r);
            (this.tangents = o.tangents), (this.normals = o.normals), (this.binormals = o.binormals);
            var a,
                s,
                c = new Sn(),
                l = new Sn(),
                u = new _n(),
                h = new Sn(),
                d = [],
                p = [],
                f = [],
                m = [];
            function v(r) {
                h = e.getPointAt(r / t, h);
                var a = o.normals[r],
                    u = o.binormals[r];
                for (s = 0; s <= i; s++) {
                    var f = (s / i) * Math.PI * 2,
                        m = Math.sin(f),
                        v = -Math.cos(f);
                    (l.x = v * a.x + m * u.x), (l.y = v * a.y + m * u.y), (l.z = v * a.z + m * u.z), l.normalize(), p.push(l.x, l.y, l.z), (c.x = h.x + n * l.x), (c.y = h.y + n * l.y), (c.z = h.z + n * l.z), d.push(c.x, c.y, c.z);
                }
            }
            !(function () {
                for (a = 0; a < t; a++) v(a);
                v(!1 === r ? t : 0),
                    (function () {
                        for (a = 0; a <= t; a++) for (s = 0; s <= i; s++) (u.x = a / t), (u.y = s / i), f.push(u.x, u.y);
                    })(),
                    (function () {
                        for (s = 1; s <= t; s++)
                            for (a = 1; a <= i; a++) {
                                var e = (i + 1) * (s - 1) + (a - 1),
                                    n = (i + 1) * s + (a - 1),
                                    r = (i + 1) * s + a,
                                    o = (i + 1) * (s - 1) + a;
                                m.push(e, n, o), m.push(n, r, o);
                            }
                    })();
            })(),
                this.setIndex(m),
                this.setAttribute("position", new dr(d, 3)),
                this.setAttribute("normal", new dr(p, 3)),
                this.setAttribute("uv", new dr(f, 2));
        }
        function zc(e, t, n, i, r, o, a) {
            Yr.call(this),
                (this.type = "TorusKnotGeometry"),
                (this.parameters = { radius: e, tube: t, tubularSegments: n, radialSegments: i, p: r, q: o }),
                void 0 !== a && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."),
                this.fromBufferGeometry(new Fc(e, t, n, i, r, o)),
                this.mergeVertices();
        }
        function Fc(e, t, n, i, r, o) {
            Mr.call(this),
                (this.type = "TorusKnotBufferGeometry"),
                (this.parameters = { radius: e, tube: t, tubularSegments: n, radialSegments: i, p: r, q: o }),
                (e = e || 1),
                (t = t || 0.4),
                (n = Math.floor(n) || 64),
                (i = Math.floor(i) || 8),
                (r = r || 2),
                (o = o || 3);
            var a,
                s,
                c = [],
                l = [],
                u = [],
                h = [],
                d = new Sn(),
                p = new Sn(),
                f = new Sn(),
                m = new Sn(),
                v = new Sn(),
                g = new Sn(),
                y = new Sn();
            for (a = 0; a <= n; ++a) {
                var x = (a / n) * r * Math.PI * 2;
                for (A(x, r, o, e, f), A(x + 0.01, r, o, e, m), g.subVectors(m, f), y.addVectors(m, f), v.crossVectors(g, y), y.crossVectors(v, g), v.normalize(), y.normalize(), s = 0; s <= i; ++s) {
                    var _ = (s / i) * Math.PI * 2,
                        b = -t * Math.cos(_),
                        w = t * Math.sin(_);
                    (d.x = f.x + (b * y.x + w * v.x)), (d.y = f.y + (b * y.y + w * v.y)), (d.z = f.z + (b * y.z + w * v.z)), l.push(d.x, d.y, d.z), p.subVectors(d, f).normalize(), u.push(p.x, p.y, p.z), h.push(a / n), h.push(s / i);
                }
            }
            for (s = 1; s <= n; s++)
                for (a = 1; a <= i; a++) {
                    var M = (i + 1) * (s - 1) + (a - 1),
                        S = (i + 1) * s + (a - 1),
                        E = (i + 1) * s + a,
                        T = (i + 1) * (s - 1) + a;
                    c.push(M, S, T), c.push(S, E, T);
                }
            function A(e, t, n, i, r) {
                var o = Math.cos(e),
                    a = Math.sin(e),
                    s = (n / t) * e,
                    c = Math.cos(s);
                (r.x = i * (2 + c) * 0.5 * o), (r.y = i * (2 + c) * a * 0.5), (r.z = i * Math.sin(s) * 0.5);
            }
            this.setIndex(c), this.setAttribute("position", new dr(l, 3)), this.setAttribute("normal", new dr(u, 3)), this.setAttribute("uv", new dr(h, 2));
        }
        function Gc(e, t, n, i, r) {
            Yr.call(this), (this.type = "TorusGeometry"), (this.parameters = { radius: e, tube: t, radialSegments: n, tubularSegments: i, arc: r }), this.fromBufferGeometry(new Hc(e, t, n, i, r)), this.mergeVertices();
        }
        function Hc(e, t, n, i, r) {
            Mr.call(this),
                (this.type = "TorusBufferGeometry"),
                (this.parameters = { radius: e, tube: t, radialSegments: n, tubularSegments: i, arc: r }),
                (e = e || 1),
                (t = t || 0.4),
                (n = Math.floor(n) || 8),
                (i = Math.floor(i) || 6),
                (r = r || 2 * Math.PI);
            var o,
                a,
                s = [],
                c = [],
                l = [],
                u = [],
                h = new Sn(),
                d = new Sn(),
                p = new Sn();
            for (o = 0; o <= n; o++)
                for (a = 0; a <= i; a++) {
                    var f = (a / i) * r,
                        m = (o / n) * Math.PI * 2;
                    (d.x = (e + t * Math.cos(m)) * Math.cos(f)),
                        (d.y = (e + t * Math.cos(m)) * Math.sin(f)),
                        (d.z = t * Math.sin(m)),
                        c.push(d.x, d.y, d.z),
                        (h.x = e * Math.cos(f)),
                        (h.y = e * Math.sin(f)),
                        p.subVectors(d, h).normalize(),
                        l.push(p.x, p.y, p.z),
                        u.push(a / i),
                        u.push(o / n);
                }
            for (o = 1; o <= n; o++)
                for (a = 1; a <= i; a++) {
                    var v = (i + 1) * o + a - 1,
                        g = (i + 1) * (o - 1) + a - 1,
                        y = (i + 1) * (o - 1) + a,
                        x = (i + 1) * o + a;
                    s.push(v, g, x), s.push(g, y, x);
                }
            this.setIndex(s), this.setAttribute("position", new dr(c, 3)), this.setAttribute("normal", new dr(l, 3)), this.setAttribute("uv", new dr(u, 2));
        }
        (gc.prototype = Object.assign(Object.create(oi.prototype), {
            constructor: gc,
            isPoints: !0,
            raycast: function (e, t) {
                var n = this.geometry,
                    i = this.matrixWorld,
                    r = e.params.Points.threshold;
                if ((null === n.boundingSphere && n.computeBoundingSphere(), mc.copy(n.boundingSphere), mc.applyMatrix4(i), (mc.radius += r), !1 !== e.ray.intersectsSphere(mc))) {
                    pc.getInverse(i), fc.copy(e.ray).applyMatrix4(pc);
                    var o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        a = o * o;
                    if (n.isBufferGeometry) {
                        var s = n.index,
                            c = n.attributes.position.array;
                        if (null !== s)
                            for (var l = s.array, u = 0, h = l.length; u < h; u++) {
                                var d = l[u];
                                vc.fromArray(c, 3 * d), yc(vc, d, a, i, e, t, this);
                            }
                        else {
                            u = 0;
                            for (var p = c.length / 3; u < p; u++) vc.fromArray(c, 3 * u), yc(vc, u, a, i, e, t, this);
                        }
                    } else {
                        var f = n.vertices;
                        for (u = 0, p = f.length; u < p; u++) yc(f[u], u, a, i, e, t, this);
                    }
                }
            },
            updateMorphTargets: function () {
                var e,
                    t,
                    n,
                    i = this.geometry;
                if (i.isBufferGeometry) {
                    var r = i.morphAttributes,
                        o = Object.keys(r);
                    if (o.length > 0) {
                        var a = r[o[0]];
                        if (void 0 !== a)
                            for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, e = 0, t = a.length; e < t; e++) (n = a[e].name || String(e)), this.morphTargetInfluences.push(0), (this.morphTargetDictionary[n] = e);
                    }
                } else {
                    var s = i.morphTargets;
                    void 0 !== s && s.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
                }
            },
            clone: function () {
                return new this.constructor(this.geometry, this.material).copy(this);
            },
        })),
            (xc.prototype = Object.assign(Object.create(Rn.prototype), {
                constructor: xc,
                isVideoTexture: !0,
                update: function () {
                    var e = this.image;
                    e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
                },
            })),
            (_c.prototype = Object.create(Rn.prototype)),
            (_c.prototype.constructor = _c),
            (_c.prototype.isCompressedTexture = !0),
            (bc.prototype = Object.create(Rn.prototype)),
            (bc.prototype.constructor = bc),
            (bc.prototype.isCanvasTexture = !0),
            (wc.prototype = Object.create(Rn.prototype)),
            (wc.prototype.constructor = wc),
            (wc.prototype.isDepthTexture = !0),
            (Mc.prototype = Object.create(Mr.prototype)),
            (Mc.prototype.constructor = Mc),
            (Sc.prototype = Object.create(Yr.prototype)),
            (Sc.prototype.constructor = Sc),
            (Ec.prototype = Object.create(Mr.prototype)),
            (Ec.prototype.constructor = Ec),
            (Tc.prototype = Object.create(Yr.prototype)),
            (Tc.prototype.constructor = Tc),
            (Ac.prototype = Object.create(Mr.prototype)),
            (Ac.prototype.constructor = Ac),
            (Lc.prototype = Object.create(Yr.prototype)),
            (Lc.prototype.constructor = Lc),
            (Cc.prototype = Object.create(Ac.prototype)),
            (Cc.prototype.constructor = Cc),
            (Rc.prototype = Object.create(Yr.prototype)),
            (Rc.prototype.constructor = Rc),
            (Pc.prototype = Object.create(Ac.prototype)),
            (Pc.prototype.constructor = Pc),
            (Oc.prototype = Object.create(Yr.prototype)),
            (Oc.prototype.constructor = Oc),
            (Dc.prototype = Object.create(Ac.prototype)),
            (Dc.prototype.constructor = Dc),
            (Ic.prototype = Object.create(Yr.prototype)),
            (Ic.prototype.constructor = Ic),
            (Nc.prototype = Object.create(Ac.prototype)),
            (Nc.prototype.constructor = Nc),
            (Uc.prototype = Object.create(Yr.prototype)),
            (Uc.prototype.constructor = Uc),
            (Bc.prototype = Object.create(Mr.prototype)),
            (Bc.prototype.constructor = Bc),
            (Bc.prototype.toJSON = function () {
                var e = Mr.prototype.toJSON.call(this);
                return (e.path = this.parameters.path.toJSON()), e;
            }),
            (zc.prototype = Object.create(Yr.prototype)),
            (zc.prototype.constructor = zc),
            (Fc.prototype = Object.create(Mr.prototype)),
            (Fc.prototype.constructor = Fc),
            (Gc.prototype = Object.create(Yr.prototype)),
            (Gc.prototype.constructor = Gc),
            (Hc.prototype = Object.create(Mr.prototype)),
            (Hc.prototype.constructor = Hc);
        var Vc = function (e, t, n) {
            n = n || 2;
            var i,
                r,
                o,
                a,
                s,
                c,
                l,
                u = t && t.length,
                h = u ? t[0] * n : e.length,
                d = kc(e, 0, h, n, !0),
                p = [];
            if (!d || d.next === d.prev) return p;
            if (
                (u &&
                    (d = (function (e, t, n, i) {
                        var r,
                            o,
                            a,
                            s,
                            c,
                            l = [];
                        for (r = 0, o = t.length; r < o; r++) (a = t[r] * i), (s = r < o - 1 ? t[r + 1] * i : e.length), (c = kc(e, a, s, i, !1)) === c.next && (c.steiner = !0), l.push($c(c));
                        for (l.sort(Zc), r = 0; r < l.length; r++) Kc(l[r], n), (n = jc(n, n.next));
                        return n;
                    })(e, t, d, n)),
                e.length > 80 * n)
            ) {
                (i = o = e[0]), (r = a = e[1]);
                for (var f = n; f < h; f += n) (s = e[f]) < i && (i = s), (c = e[f + 1]) < r && (r = c), s > o && (o = s), c > a && (a = c);
                l = 0 !== (l = Math.max(o - i, a - r)) ? 1 / l : 0;
            }
            return Wc(d, p, n, i, r, l), p;
        };
        function kc(e, t, n, i, r) {
            var o, a;
            if (
                r ===
                (function (e, t, n, i) {
                    for (var r = 0, o = t, a = n - i; o < n; o += i) (r += (e[a] - e[o]) * (e[o + 1] + e[a + 1])), (a = o);
                    return r;
                })(e, t, n, i) >
                    0
            )
                for (o = t; o < n; o += i) a = sl(o, e[o], e[o + 1], a);
            else for (o = n - i; o >= t; o -= i) a = sl(o, e[o], e[o + 1], a);
            return a && il(a, a.next) && (cl(a), (a = a.next)), a;
        }
        function jc(e, t) {
            if (!e) return e;
            t || (t = e);
            var n,
                i = e;
            do {
                if (((n = !1), i.steiner || (!il(i, i.next) && 0 !== nl(i.prev, i, i.next)))) i = i.next;
                else {
                    if ((cl(i), (i = t = i.prev) === i.next)) break;
                    n = !0;
                }
            } while (n || i !== t);
            return t;
        }
        function Wc(e, t, n, i, r, o, a) {
            if (e) {
                !a &&
                    o &&
                    (function (e, t, n, i) {
                        var r = e;
                        do {
                            null === r.z && (r.z = Qc(r.x, r.y, t, n, i)), (r.prevZ = r.prev), (r.nextZ = r.next), (r = r.next);
                        } while (r !== e);
                        (r.prevZ.nextZ = null),
                            (r.prevZ = null),
                            (function (e) {
                                var t,
                                    n,
                                    i,
                                    r,
                                    o,
                                    a,
                                    s,
                                    c,
                                    l = 1;
                                do {
                                    for (n = e, e = null, o = null, a = 0; n; ) {
                                        for (a++, i = n, s = 0, t = 0; t < l && (s++, (i = i.nextZ)); t++);
                                        for (c = l; s > 0 || (c > 0 && i); ) 0 !== s && (0 === c || !i || n.z <= i.z) ? ((r = n), (n = n.nextZ), s--) : ((r = i), (i = i.nextZ), c--), o ? (o.nextZ = r) : (e = r), (r.prevZ = o), (o = r);
                                        n = i;
                                    }
                                    (o.nextZ = null), (l *= 2);
                                } while (a > 1);
                            })(r);
                    })(e, i, r, o);
                for (var s, c, l = e; e.prev !== e.next; )
                    if (((s = e.prev), (c = e.next), o ? Xc(e, i, r, o) : qc(e))) t.push(s.i / n), t.push(e.i / n), t.push(c.i / n), cl(e), (e = c.next), (l = c.next);
                    else if ((e = c) === l) {
                        a ? (1 === a ? Wc((e = Yc(e, t, n)), t, n, i, r, o, 2) : 2 === a && Jc(e, t, n, i, r, o)) : Wc(jc(e), t, n, i, r, o, 1);
                        break;
                    }
            }
        }
        function qc(e) {
            var t = e.prev,
                n = e,
                i = e.next;
            if (nl(t, n, i) >= 0) return !1;
            for (var r = e.next.next; r !== e.prev; ) {
                if (el(t.x, t.y, n.x, n.y, i.x, i.y, r.x, r.y) && nl(r.prev, r, r.next) >= 0) return !1;
                r = r.next;
            }
            return !0;
        }
        function Xc(e, t, n, i) {
            var r = e.prev,
                o = e,
                a = e.next;
            if (nl(r, o, a) >= 0) return !1;
            for (
                var s = r.x < o.x ? (r.x < a.x ? r.x : a.x) : o.x < a.x ? o.x : a.x,
                    c = r.y < o.y ? (r.y < a.y ? r.y : a.y) : o.y < a.y ? o.y : a.y,
                    l = r.x > o.x ? (r.x > a.x ? r.x : a.x) : o.x > a.x ? o.x : a.x,
                    u = r.y > o.y ? (r.y > a.y ? r.y : a.y) : o.y > a.y ? o.y : a.y,
                    h = Qc(s, c, t, n, i),
                    d = Qc(l, u, t, n, i),
                    p = e.prevZ,
                    f = e.nextZ;
                p && p.z >= h && f && f.z <= d;

            ) {
                if (p !== e.prev && p !== e.next && el(r.x, r.y, o.x, o.y, a.x, a.y, p.x, p.y) && nl(p.prev, p, p.next) >= 0) return !1;
                if (((p = p.prevZ), f !== e.prev && f !== e.next && el(r.x, r.y, o.x, o.y, a.x, a.y, f.x, f.y) && nl(f.prev, f, f.next) >= 0)) return !1;
                f = f.nextZ;
            }
            for (; p && p.z >= h; ) {
                if (p !== e.prev && p !== e.next && el(r.x, r.y, o.x, o.y, a.x, a.y, p.x, p.y) && nl(p.prev, p, p.next) >= 0) return !1;
                p = p.prevZ;
            }
            for (; f && f.z <= d; ) {
                if (f !== e.prev && f !== e.next && el(r.x, r.y, o.x, o.y, a.x, a.y, f.x, f.y) && nl(f.prev, f, f.next) >= 0) return !1;
                f = f.nextZ;
            }
            return !0;
        }
        function Yc(e, t, n) {
            var i = e;
            do {
                var r = i.prev,
                    o = i.next.next;
                !il(r, o) && rl(r, i, i.next, o) && ol(r, o) && ol(o, r) && (t.push(r.i / n), t.push(i.i / n), t.push(o.i / n), cl(i), cl(i.next), (i = e = o)), (i = i.next);
            } while (i !== e);
            return i;
        }
        function Jc(e, t, n, i, r, o) {
            var a = e;
            do {
                for (var s = a.next.next; s !== a.prev; ) {
                    if (a.i !== s.i && tl(a, s)) {
                        var c = al(a, s);
                        return (a = jc(a, a.next)), (c = jc(c, c.next)), Wc(a, t, n, i, r, o), void Wc(c, t, n, i, r, o);
                    }
                    s = s.next;
                }
                a = a.next;
            } while (a !== e);
        }
        function Zc(e, t) {
            return e.x - t.x;
        }
        function Kc(e, t) {
            if (
                (t = (function (e, t) {
                    var n,
                        i = t,
                        r = e.x,
                        o = e.y,
                        a = -1 / 0;
                    do {
                        if (o <= i.y && o >= i.next.y && i.next.y !== i.y) {
                            var s = i.x + ((o - i.y) * (i.next.x - i.x)) / (i.next.y - i.y);
                            if (s <= r && s > a) {
                                if (((a = s), s === r)) {
                                    if (o === i.y) return i;
                                    if (o === i.next.y) return i.next;
                                }
                                n = i.x < i.next.x ? i : i.next;
                            }
                        }
                        i = i.next;
                    } while (i !== t);
                    if (!n) return null;
                    if (r === a) return n.prev;
                    var c,
                        l = n,
                        u = n.x,
                        h = n.y,
                        d = 1 / 0;
                    i = n.next;
                    for (; i !== l; )
                        r >= i.x && i.x >= u && r !== i.x && el(o < h ? r : a, o, u, h, o < h ? a : r, o, i.x, i.y) && ((c = Math.abs(o - i.y) / (r - i.x)) < d || (c === d && i.x > n.x)) && ol(i, e) && ((n = i), (d = c)), (i = i.next);
                    return n;
                })(e, t))
            ) {
                var n = al(t, e);
                jc(n, n.next);
            }
        }
        function Qc(e, t, n, i, r) {
            return (
                (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * r) | (e << 8))) | (e << 4))) | (e << 2))) | (e << 1))) |
                ((t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) * r) | (t << 8))) | (t << 4))) | (t << 2))) | (t << 1))) << 1)
            );
        }
        function $c(e) {
            var t = e,
                n = e;
            do {
                (t.x < n.x || (t.x === n.x && t.y < n.y)) && (n = t), (t = t.next);
            } while (t !== e);
            return n;
        }
        function el(e, t, n, i, r, o, a, s) {
            return (r - a) * (t - s) - (e - a) * (o - s) >= 0 && (e - a) * (i - s) - (n - a) * (t - s) >= 0 && (n - a) * (o - s) - (r - a) * (i - s) >= 0;
        }
        function tl(e, t) {
            return (
                e.next.i !== t.i &&
                e.prev.i !== t.i &&
                !(function (e, t) {
                    var n = e;
                    do {
                        if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && rl(n, n.next, e, t)) return !0;
                        n = n.next;
                    } while (n !== e);
                    return !1;
                })(e, t) &&
                ol(e, t) &&
                ol(t, e) &&
                (function (e, t) {
                    var n = e,
                        i = !1,
                        r = (e.x + t.x) / 2,
                        o = (e.y + t.y) / 2;
                    do {
                        n.y > o != n.next.y > o && n.next.y !== n.y && r < ((n.next.x - n.x) * (o - n.y)) / (n.next.y - n.y) + n.x && (i = !i), (n = n.next);
                    } while (n !== e);
                    return i;
                })(e, t)
            );
        }
        function nl(e, t, n) {
            return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y);
        }
        function il(e, t) {
            return e.x === t.x && e.y === t.y;
        }
        function rl(e, t, n, i) {
            return !!((il(e, n) && il(t, i)) || (il(e, i) && il(n, t))) || (nl(e, t, n) > 0 != nl(e, t, i) > 0 && nl(n, i, e) > 0 != nl(n, i, t) > 0);
        }
        function ol(e, t) {
            return nl(e.prev, e, e.next) < 0 ? nl(e, t, e.next) >= 0 && nl(e, e.prev, t) >= 0 : nl(e, t, e.prev) < 0 || nl(e, e.next, t) < 0;
        }
        function al(e, t) {
            var n = new ll(e.i, e.x, e.y),
                i = new ll(t.i, t.x, t.y),
                r = e.next,
                o = t.prev;
            return (e.next = t), (t.prev = e), (n.next = r), (r.prev = n), (i.next = n), (n.prev = i), (o.next = i), (i.prev = o), i;
        }
        function sl(e, t, n, i) {
            var r = new ll(e, t, n);
            return i ? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r)) : ((r.prev = r), (r.next = r)), r;
        }
        function cl(e) {
            (e.next.prev = e.prev), (e.prev.next = e.next), e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ);
        }
        function ll(e, t, n) {
            (this.i = e), (this.x = t), (this.y = n), (this.prev = null), (this.next = null), (this.z = null), (this.prevZ = null), (this.nextZ = null), (this.steiner = !1);
        }
        var ul = {
            area: function (e) {
                for (var t = e.length, n = 0, i = t - 1, r = 0; r < t; i = r++) n += e[i].x * e[r].y - e[r].x * e[i].y;
                return 0.5 * n;
            },
            isClockWise: function (e) {
                return ul.area(e) < 0;
            },
            triangulateShape: function (e, t) {
                var n = [],
                    i = [],
                    r = [];
                hl(e), dl(n, e);
                var o = e.length;
                t.forEach(hl);
                for (var a = 0; a < t.length; a++) i.push(o), (o += t[a].length), dl(n, t[a]);
                var s = Vc(n, i);
                for (a = 0; a < s.length; a += 3) r.push(s.slice(a, a + 3));
                return r;
            },
        };
        function hl(e) {
            var t = e.length;
            t > 2 && e[t - 1].equals(e[0]) && e.pop();
        }
        function dl(e, t) {
            for (var n = 0; n < t.length; n++) e.push(t[n].x), e.push(t[n].y);
        }
        function pl(e, t) {
            Yr.call(this), (this.type = "ExtrudeGeometry"), (this.parameters = { shapes: e, options: t }), this.fromBufferGeometry(new fl(e, t)), this.mergeVertices();
        }
        function fl(e, t) {
            Mr.call(this), (this.type = "ExtrudeBufferGeometry"), (this.parameters = { shapes: e, options: t }), (e = Array.isArray(e) ? e : [e]);
            for (var n = this, i = [], r = [], o = 0, a = e.length; o < a; o++) {
                s(e[o]);
            }
            function s(e) {
                var o = [],
                    a = void 0 !== t.curveSegments ? t.curveSegments : 12,
                    s = void 0 !== t.steps ? t.steps : 1,
                    c = void 0 !== t.depth ? t.depth : 100,
                    l = void 0 === t.bevelEnabled || t.bevelEnabled,
                    u = void 0 !== t.bevelThickness ? t.bevelThickness : 6,
                    h = void 0 !== t.bevelSize ? t.bevelSize : u - 2,
                    d = void 0 !== t.bevelOffset ? t.bevelOffset : 0,
                    p = void 0 !== t.bevelSegments ? t.bevelSegments : 3,
                    f = t.extrudePath,
                    m = void 0 !== t.UVGenerator ? t.UVGenerator : ml;
                void 0 !== t.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), (c = t.amount));
                var v,
                    g,
                    y,
                    x,
                    _,
                    b,
                    w,
                    M,
                    S = !1;
                f && ((v = f.getSpacedPoints(s)), (S = !0), (l = !1), (g = f.computeFrenetFrames(s, !1)), (y = new Sn()), (x = new Sn()), (_ = new Sn())), l || ((p = 0), (u = 0), (h = 0), (d = 0));
                var E = e.extractPoints(a),
                    T = E.shape,
                    A = E.holes;
                if (!ul.isClockWise(T)) for (T = T.reverse(), w = 0, M = A.length; w < M; w++) (b = A[w]), ul.isClockWise(b) && (A[w] = b.reverse());
                var L = ul.triangulateShape(T, A),
                    C = T;
                for (w = 0, M = A.length; w < M; w++) (b = A[w]), (T = T.concat(b));
                function R(e, t, n) {
                    return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(n).add(e);
                }
                var P,
                    O,
                    D,
                    I,
                    N,
                    U,
                    B = T.length,
                    z = L.length;
                function F(e, t, n) {
                    var i,
                        r,
                        o,
                        a = e.x - t.x,
                        s = e.y - t.y,
                        c = n.x - e.x,
                        l = n.y - e.y,
                        u = a * a + s * s,
                        h = a * l - s * c;
                    if (Math.abs(h) > Number.EPSILON) {
                        var d = Math.sqrt(u),
                            p = Math.sqrt(c * c + l * l),
                            f = t.x - s / d,
                            m = t.y + a / d,
                            v = ((n.x - l / p - f) * l - (n.y + c / p - m) * c) / (a * l - s * c),
                            g = (i = f + a * v - e.x) * i + (r = m + s * v - e.y) * r;
                        if (g <= 2) return new _n(i, r);
                        o = Math.sqrt(g / 2);
                    } else {
                        var y = !1;
                        a > Number.EPSILON ? c > Number.EPSILON && (y = !0) : a < -Number.EPSILON ? c < -Number.EPSILON && (y = !0) : Math.sign(s) === Math.sign(l) && (y = !0),
                            y ? ((i = -s), (r = a), (o = Math.sqrt(u))) : ((i = a), (r = s), (o = Math.sqrt(u / 2)));
                    }
                    return new _n(i / o, r / o);
                }
                for (var G = [], H = 0, V = C.length, k = V - 1, j = H + 1; H < V; H++, k++, j++) k === V && (k = 0), j === V && (j = 0), (G[H] = F(C[H], C[k], C[j]));
                var W,
                    q,
                    X = [],
                    Y = G.concat();
                for (w = 0, M = A.length; w < M; w++) {
                    for (b = A[w], W = [], H = 0, k = (V = b.length) - 1, j = H + 1; H < V; H++, k++, j++) k === V && (k = 0), j === V && (j = 0), (W[H] = F(b[H], b[k], b[j]));
                    X.push(W), (Y = Y.concat(W));
                }
                for (P = 0; P < p; P++) {
                    for (D = P / p, I = u * Math.cos((D * Math.PI) / 2), O = h * Math.sin((D * Math.PI) / 2) + d, H = 0, V = C.length; H < V; H++) Z((N = R(C[H], G[H], O)).x, N.y, -I);
                    for (w = 0, M = A.length; w < M; w++) for (b = A[w], W = X[w], H = 0, V = b.length; H < V; H++) Z((N = R(b[H], W[H], O)).x, N.y, -I);
                }
                for (O = h + d, H = 0; H < B; H++) (N = l ? R(T[H], Y[H], O) : T[H]), S ? (x.copy(g.normals[0]).multiplyScalar(N.x), y.copy(g.binormals[0]).multiplyScalar(N.y), _.copy(v[0]).add(x).add(y), Z(_.x, _.y, _.z)) : Z(N.x, N.y, 0);
                for (q = 1; q <= s; q++)
                    for (H = 0; H < B; H++)
                        (N = l ? R(T[H], Y[H], O) : T[H]), S ? (x.copy(g.normals[q]).multiplyScalar(N.x), y.copy(g.binormals[q]).multiplyScalar(N.y), _.copy(v[q]).add(x).add(y), Z(_.x, _.y, _.z)) : Z(N.x, N.y, (c / s) * q);
                for (P = p - 1; P >= 0; P--) {
                    for (D = P / p, I = u * Math.cos((D * Math.PI) / 2), O = h * Math.sin((D * Math.PI) / 2) + d, H = 0, V = C.length; H < V; H++) Z((N = R(C[H], G[H], O)).x, N.y, c + I);
                    for (w = 0, M = A.length; w < M; w++) for (b = A[w], W = X[w], H = 0, V = b.length; H < V; H++) (N = R(b[H], W[H], O)), S ? Z(N.x, N.y + v[s - 1].y, v[s - 1].x + I) : Z(N.x, N.y, c + I);
                }
                function J(e, t) {
                    var n, i;
                    for (H = e.length; --H >= 0; ) {
                        (n = H), (i = H - 1) < 0 && (i = e.length - 1);
                        var r = 0,
                            o = s + 2 * p;
                        for (r = 0; r < o; r++) {
                            var a = B * r,
                                c = B * (r + 1);
                            Q(t + n + a, t + i + a, t + i + c, t + n + c);
                        }
                    }
                }
                function Z(e, t, n) {
                    o.push(e), o.push(t), o.push(n);
                }
                function K(e, t, r) {
                    $(e), $(t), $(r);
                    var o = i.length / 3,
                        a = m.generateTopUV(n, i, o - 3, o - 2, o - 1);
                    ee(a[0]), ee(a[1]), ee(a[2]);
                }
                function Q(e, t, r, o) {
                    $(e), $(t), $(o), $(t), $(r), $(o);
                    var a = i.length / 3,
                        s = m.generateSideWallUV(n, i, a - 6, a - 3, a - 2, a - 1);
                    ee(s[0]), ee(s[1]), ee(s[3]), ee(s[1]), ee(s[2]), ee(s[3]);
                }
                function $(e) {
                    i.push(o[3 * e + 0]), i.push(o[3 * e + 1]), i.push(o[3 * e + 2]);
                }
                function ee(e) {
                    r.push(e.x), r.push(e.y);
                }
                !(function () {
                    var e = i.length / 3;
                    if (l) {
                        var t = 0,
                            r = B * t;
                        for (H = 0; H < z; H++) K((U = L[H])[2] + r, U[1] + r, U[0] + r);
                        for (r = B * (t = s + 2 * p), H = 0; H < z; H++) K((U = L[H])[0] + r, U[1] + r, U[2] + r);
                    } else {
                        for (H = 0; H < z; H++) K((U = L[H])[2], U[1], U[0]);
                        for (H = 0; H < z; H++) K((U = L[H])[0] + B * s, U[1] + B * s, U[2] + B * s);
                    }
                    n.addGroup(e, i.length / 3 - e, 0);
                })(),
                    (function () {
                        var e = i.length / 3,
                            t = 0;
                        for (J(C, t), t += C.length, w = 0, M = A.length; w < M; w++) J((b = A[w]), t), (t += b.length);
                        n.addGroup(e, i.length / 3 - e, 1);
                    })();
            }
            this.setAttribute("position", new dr(i, 3)), this.setAttribute("uv", new dr(r, 2)), this.computeVertexNormals();
        }
        (pl.prototype = Object.create(Yr.prototype)),
            (pl.prototype.constructor = pl),
            (pl.prototype.toJSON = function () {
                var e = Yr.prototype.toJSON.call(this);
                return vl(this.parameters.shapes, this.parameters.options, e);
            }),
            (fl.prototype = Object.create(Mr.prototype)),
            (fl.prototype.constructor = fl),
            (fl.prototype.toJSON = function () {
                var e = Mr.prototype.toJSON.call(this);
                return vl(this.parameters.shapes, this.parameters.options, e);
            });
        var ml = {
            generateTopUV: function (e, t, n, i, r) {
                var o = t[3 * n],
                    a = t[3 * n + 1],
                    s = t[3 * i],
                    c = t[3 * i + 1],
                    l = t[3 * r],
                    u = t[3 * r + 1];
                return [new _n(o, a), new _n(s, c), new _n(l, u)];
            },
            generateSideWallUV: function (e, t, n, i, r, o) {
                var a = t[3 * n],
                    s = t[3 * n + 1],
                    c = t[3 * n + 2],
                    l = t[3 * i],
                    u = t[3 * i + 1],
                    h = t[3 * i + 2],
                    d = t[3 * r],
                    p = t[3 * r + 1],
                    f = t[3 * r + 2],
                    m = t[3 * o],
                    v = t[3 * o + 1],
                    g = t[3 * o + 2];
                return Math.abs(s - u) < 0.01 ? [new _n(a, 1 - c), new _n(l, 1 - h), new _n(d, 1 - f), new _n(m, 1 - g)] : [new _n(s, 1 - c), new _n(u, 1 - h), new _n(p, 1 - f), new _n(v, 1 - g)];
            },
        };
        function vl(e, t, n) {
            if (((n.shapes = []), Array.isArray(e)))
                for (var i = 0, r = e.length; i < r; i++) {
                    var o = e[i];
                    n.shapes.push(o.uuid);
                }
            else n.shapes.push(e.uuid);
            return void 0 !== t.extrudePath && (n.options.extrudePath = t.extrudePath.toJSON()), n;
        }
        function gl(e, t) {
            Yr.call(this), (this.type = "TextGeometry"), (this.parameters = { text: e, parameters: t }), this.fromBufferGeometry(new yl(e, t)), this.mergeVertices();
        }
        function yl(e, t) {
            var n = (t = t || {}).font;
            if (!n || !n.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new Yr();
            var i = n.generateShapes(e, t.size);
            (t.depth = void 0 !== t.height ? t.height : 50),
                void 0 === t.bevelThickness && (t.bevelThickness = 10),
                void 0 === t.bevelSize && (t.bevelSize = 8),
                void 0 === t.bevelEnabled && (t.bevelEnabled = !1),
                fl.call(this, i, t),
                (this.type = "TextBufferGeometry");
        }
        function xl(e, t, n, i, r, o, a) {
            Yr.call(this),
                (this.type = "SphereGeometry"),
                (this.parameters = { radius: e, widthSegments: t, heightSegments: n, phiStart: i, phiLength: r, thetaStart: o, thetaLength: a }),
                this.fromBufferGeometry(new _l(e, t, n, i, r, o, a)),
                this.mergeVertices();
        }
        function _l(e, t, n, i, r, o, a) {
            Mr.call(this),
                (this.type = "SphereBufferGeometry"),
                (this.parameters = { radius: e, widthSegments: t, heightSegments: n, phiStart: i, phiLength: r, thetaStart: o, thetaLength: a }),
                (e = e || 1),
                (t = Math.max(3, Math.floor(t) || 8)),
                (n = Math.max(2, Math.floor(n) || 6)),
                (i = void 0 !== i ? i : 0),
                (r = void 0 !== r ? r : 2 * Math.PI),
                (o = void 0 !== o ? o : 0),
                (a = void 0 !== a ? a : Math.PI);
            var s,
                c,
                l = Math.min(o + a, Math.PI),
                u = 0,
                h = [],
                d = new Sn(),
                p = new Sn(),
                f = [],
                m = [],
                v = [],
                g = [];
            for (c = 0; c <= n; c++) {
                var y = [],
                    x = c / n,
                    _ = 0;
                for (0 == c && 0 == o ? (_ = 0.5 / t) : c == n && l == Math.PI && (_ = -0.5 / t), s = 0; s <= t; s++) {
                    var b = s / t;
                    (d.x = -e * Math.cos(i + b * r) * Math.sin(o + x * a)),
                        (d.y = e * Math.cos(o + x * a)),
                        (d.z = e * Math.sin(i + b * r) * Math.sin(o + x * a)),
                        m.push(d.x, d.y, d.z),
                        p.copy(d).normalize(),
                        v.push(p.x, p.y, p.z),
                        g.push(b + _, 1 - x),
                        y.push(u++);
                }
                h.push(y);
            }
            for (c = 0; c < n; c++)
                for (s = 0; s < t; s++) {
                    var w = h[c][s + 1],
                        M = h[c][s],
                        S = h[c + 1][s],
                        E = h[c + 1][s + 1];
                    (0 !== c || o > 0) && f.push(w, M, E), (c !== n - 1 || l < Math.PI) && f.push(M, S, E);
                }
            this.setIndex(f), this.setAttribute("position", new dr(m, 3)), this.setAttribute("normal", new dr(v, 3)), this.setAttribute("uv", new dr(g, 2));
        }
        function bl(e, t, n, i, r, o) {
            Yr.call(this),
                (this.type = "RingGeometry"),
                (this.parameters = { innerRadius: e, outerRadius: t, thetaSegments: n, phiSegments: i, thetaStart: r, thetaLength: o }),
                this.fromBufferGeometry(new wl(e, t, n, i, r, o)),
                this.mergeVertices();
        }
        function wl(e, t, n, i, r, o) {
            Mr.call(this),
                (this.type = "RingBufferGeometry"),
                (this.parameters = { innerRadius: e, outerRadius: t, thetaSegments: n, phiSegments: i, thetaStart: r, thetaLength: o }),
                (e = e || 0.5),
                (t = t || 1),
                (r = void 0 !== r ? r : 0),
                (o = void 0 !== o ? o : 2 * Math.PI),
                (n = void 0 !== n ? Math.max(3, n) : 8);
            var a,
                s,
                c,
                l = [],
                u = [],
                h = [],
                d = [],
                p = e,
                f = (t - e) / (i = void 0 !== i ? Math.max(1, i) : 1),
                m = new Sn(),
                v = new _n();
            for (s = 0; s <= i; s++) {
                for (c = 0; c <= n; c++) (a = r + (c / n) * o), (m.x = p * Math.cos(a)), (m.y = p * Math.sin(a)), u.push(m.x, m.y, m.z), h.push(0, 0, 1), (v.x = (m.x / t + 1) / 2), (v.y = (m.y / t + 1) / 2), d.push(v.x, v.y);
                p += f;
            }
            for (s = 0; s < i; s++) {
                var g = s * (n + 1);
                for (c = 0; c < n; c++) {
                    var y = (a = c + g),
                        x = a + n + 1,
                        _ = a + n + 2,
                        b = a + 1;
                    l.push(y, x, b), l.push(x, _, b);
                }
            }
            this.setIndex(l), this.setAttribute("position", new dr(u, 3)), this.setAttribute("normal", new dr(h, 3)), this.setAttribute("uv", new dr(d, 2));
        }
        function Ml(e, t, n, i) {
            Yr.call(this), (this.type = "LatheGeometry"), (this.parameters = { points: e, segments: t, phiStart: n, phiLength: i }), this.fromBufferGeometry(new Sl(e, t, n, i)), this.mergeVertices();
        }
        function Sl(e, t, n, i) {
            Mr.call(this), (this.type = "LatheBufferGeometry"), (this.parameters = { points: e, segments: t, phiStart: n, phiLength: i }), (t = Math.floor(t) || 12), (n = n || 0), (i = i || 2 * Math.PI), (i = xn.clamp(i, 0, 2 * Math.PI));
            var r,
                o,
                a,
                s = [],
                c = [],
                l = [],
                u = 1 / t,
                h = new Sn(),
                d = new _n();
            for (o = 0; o <= t; o++) {
                var p = n + o * u * i,
                    f = Math.sin(p),
                    m = Math.cos(p);
                for (a = 0; a <= e.length - 1; a++) (h.x = e[a].x * f), (h.y = e[a].y), (h.z = e[a].x * m), c.push(h.x, h.y, h.z), (d.x = o / t), (d.y = a / (e.length - 1)), l.push(d.x, d.y);
            }
            for (o = 0; o < t; o++)
                for (a = 0; a < e.length - 1; a++) {
                    var v = (r = a + o * e.length),
                        g = r + e.length,
                        y = r + e.length + 1,
                        x = r + 1;
                    s.push(v, g, x), s.push(g, y, x);
                }
            if ((this.setIndex(s), this.setAttribute("position", new dr(c, 3)), this.setAttribute("uv", new dr(l, 2)), this.computeVertexNormals(), i === 2 * Math.PI)) {
                var _ = this.attributes.normal.array,
                    b = new Sn(),
                    w = new Sn(),
                    M = new Sn();
                for (r = t * e.length * 3, o = 0, a = 0; o < e.length; o++, a += 3)
                    (b.x = _[a + 0]),
                        (b.y = _[a + 1]),
                        (b.z = _[a + 2]),
                        (w.x = _[r + a + 0]),
                        (w.y = _[r + a + 1]),
                        (w.z = _[r + a + 2]),
                        M.addVectors(b, w).normalize(),
                        (_[a + 0] = _[r + a + 0] = M.x),
                        (_[a + 1] = _[r + a + 1] = M.y),
                        (_[a + 2] = _[r + a + 2] = M.z);
            }
        }
        function El(e, t) {
            Yr.call(this),
                (this.type = "ShapeGeometry"),
                "object" == typeof t && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), (t = t.curveSegments)),
                (this.parameters = { shapes: e, curveSegments: t }),
                this.fromBufferGeometry(new Tl(e, t)),
                this.mergeVertices();
        }
        function Tl(e, t) {
            Mr.call(this), (this.type = "ShapeBufferGeometry"), (this.parameters = { shapes: e, curveSegments: t }), (t = t || 12);
            var n = [],
                i = [],
                r = [],
                o = [],
                a = 0,
                s = 0;
            if (!1 === Array.isArray(e)) l(e);
            else for (var c = 0; c < e.length; c++) l(e[c]), this.addGroup(a, s, c), (a += s), (s = 0);
            function l(e) {
                var a,
                    c,
                    l,
                    u = i.length / 3,
                    h = e.extractPoints(t),
                    d = h.shape,
                    p = h.holes;
                for (!1 === ul.isClockWise(d) && (d = d.reverse()), a = 0, c = p.length; a < c; a++) (l = p[a]), !0 === ul.isClockWise(l) && (p[a] = l.reverse());
                var f = ul.triangulateShape(d, p);
                for (a = 0, c = p.length; a < c; a++) (l = p[a]), (d = d.concat(l));
                for (a = 0, c = d.length; a < c; a++) {
                    var m = d[a];
                    i.push(m.x, m.y, 0), r.push(0, 0, 1), o.push(m.x, m.y);
                }
                for (a = 0, c = f.length; a < c; a++) {
                    var v = f[a],
                        g = v[0] + u,
                        y = v[1] + u,
                        x = v[2] + u;
                    n.push(g, y, x), (s += 3);
                }
            }
            this.setIndex(n), this.setAttribute("position", new dr(i, 3)), this.setAttribute("normal", new dr(r, 3)), this.setAttribute("uv", new dr(o, 2));
        }
        function Al(e, t) {
            if (((t.shapes = []), Array.isArray(e)))
                for (var n = 0, i = e.length; n < i; n++) {
                    var r = e[n];
                    t.shapes.push(r.uuid);
                }
            else t.shapes.push(e.uuid);
            return t;
        }
        function Ll(e, t) {
            Mr.call(this), (this.type = "EdgesGeometry"), (this.parameters = { thresholdAngle: t }), (t = void 0 !== t ? t : 1);
            var n,
                i,
                r,
                o,
                a = [],
                s = Math.cos(xn.DEG2RAD * t),
                c = [0, 0],
                l = {},
                u = ["a", "b", "c"];
            e.isBufferGeometry ? (o = new Yr()).fromBufferGeometry(e) : (o = e.clone()), o.mergeVertices(), o.computeFaceNormals();
            for (var h = o.vertices, d = o.faces, p = 0, f = d.length; p < f; p++)
                for (var m = d[p], v = 0; v < 3; v++)
                    (n = m[u[v]]), (i = m[u[(v + 1) % 3]]), (c[0] = Math.min(n, i)), (c[1] = Math.max(n, i)), void 0 === l[(r = c[0] + "," + c[1])] ? (l[r] = { index1: c[0], index2: c[1], face1: p, face2: void 0 }) : (l[r].face2 = p);
            for (r in l) {
                var g = l[r];
                if (void 0 === g.face2 || d[g.face1].normal.dot(d[g.face2].normal) <= s) {
                    var y = h[g.index1];
                    a.push(y.x, y.y, y.z), (y = h[g.index2]), a.push(y.x, y.y, y.z);
                }
            }
            this.setAttribute("position", new dr(a, 3));
        }
        function Cl(e, t, n, i, r, o, a, s) {
            Yr.call(this),
                (this.type = "CylinderGeometry"),
                (this.parameters = { radiusTop: e, radiusBottom: t, height: n, radialSegments: i, heightSegments: r, openEnded: o, thetaStart: a, thetaLength: s }),
                this.fromBufferGeometry(new Rl(e, t, n, i, r, o, a, s)),
                this.mergeVertices();
        }
        function Rl(e, t, n, i, r, o, a, s) {
            Mr.call(this), (this.type = "CylinderBufferGeometry"), (this.parameters = { radiusTop: e, radiusBottom: t, height: n, radialSegments: i, heightSegments: r, openEnded: o, thetaStart: a, thetaLength: s });
            var c = this;
            (e = void 0 !== e ? e : 1), (t = void 0 !== t ? t : 1), (n = n || 1), (i = Math.floor(i) || 8), (r = Math.floor(r) || 1), (o = void 0 !== o && o), (a = void 0 !== a ? a : 0), (s = void 0 !== s ? s : 2 * Math.PI);
            var l = [],
                u = [],
                h = [],
                d = [],
                p = 0,
                f = [],
                m = n / 2,
                v = 0;
            function g(n) {
                var r,
                    o,
                    f,
                    g = new _n(),
                    y = new Sn(),
                    x = 0,
                    _ = !0 === n ? e : t,
                    b = !0 === n ? 1 : -1;
                for (o = p, r = 1; r <= i; r++) u.push(0, m * b, 0), h.push(0, b, 0), d.push(0.5, 0.5), p++;
                for (f = p, r = 0; r <= i; r++) {
                    var w = (r / i) * s + a,
                        M = Math.cos(w),
                        S = Math.sin(w);
                    (y.x = _ * S), (y.y = m * b), (y.z = _ * M), u.push(y.x, y.y, y.z), h.push(0, b, 0), (g.x = 0.5 * M + 0.5), (g.y = 0.5 * S * b + 0.5), d.push(g.x, g.y), p++;
                }
                for (r = 0; r < i; r++) {
                    var E = o + r,
                        T = f + r;
                    !0 === n ? l.push(T, T + 1, E) : l.push(T + 1, T, E), (x += 3);
                }
                c.addGroup(v, x, !0 === n ? 1 : 2), (v += x);
            }
            !(function () {
                var o,
                    g,
                    y = new Sn(),
                    x = new Sn(),
                    _ = 0,
                    b = (t - e) / n;
                for (g = 0; g <= r; g++) {
                    var w = [],
                        M = g / r,
                        S = M * (t - e) + e;
                    for (o = 0; o <= i; o++) {
                        var E = o / i,
                            T = E * s + a,
                            A = Math.sin(T),
                            L = Math.cos(T);
                        (x.x = S * A), (x.y = -M * n + m), (x.z = S * L), u.push(x.x, x.y, x.z), y.set(A, b, L).normalize(), h.push(y.x, y.y, y.z), d.push(E, 1 - M), w.push(p++);
                    }
                    f.push(w);
                }
                for (o = 0; o < i; o++)
                    for (g = 0; g < r; g++) {
                        var C = f[g][o],
                            R = f[g + 1][o],
                            P = f[g + 1][o + 1],
                            O = f[g][o + 1];
                        l.push(C, R, O), l.push(R, P, O), (_ += 6);
                    }
                c.addGroup(v, _, 0), (v += _);
            })(),
                !1 === o && (e > 0 && g(!0), t > 0 && g(!1)),
                this.setIndex(l),
                this.setAttribute("position", new dr(u, 3)),
                this.setAttribute("normal", new dr(h, 3)),
                this.setAttribute("uv", new dr(d, 2));
        }
        function Pl(e, t, n, i, r, o, a) {
            Cl.call(this, 0, e, t, n, i, r, o, a), (this.type = "ConeGeometry"), (this.parameters = { radius: e, height: t, radialSegments: n, heightSegments: i, openEnded: r, thetaStart: o, thetaLength: a });
        }
        function Ol(e, t, n, i, r, o, a) {
            Rl.call(this, 0, e, t, n, i, r, o, a), (this.type = "ConeBufferGeometry"), (this.parameters = { radius: e, height: t, radialSegments: n, heightSegments: i, openEnded: r, thetaStart: o, thetaLength: a });
        }
        function Dl(e, t, n, i) {
            Yr.call(this), (this.type = "CircleGeometry"), (this.parameters = { radius: e, segments: t, thetaStart: n, thetaLength: i }), this.fromBufferGeometry(new Il(e, t, n, i)), this.mergeVertices();
        }
        function Il(e, t, n, i) {
            Mr.call(this),
                (this.type = "CircleBufferGeometry"),
                (this.parameters = { radius: e, segments: t, thetaStart: n, thetaLength: i }),
                (e = e || 1),
                (t = void 0 !== t ? Math.max(3, t) : 8),
                (n = void 0 !== n ? n : 0),
                (i = void 0 !== i ? i : 2 * Math.PI);
            var r,
                o,
                a = [],
                s = [],
                c = [],
                l = [],
                u = new Sn(),
                h = new _n();
            for (s.push(0, 0, 0), c.push(0, 0, 1), l.push(0.5, 0.5), o = 0, r = 3; o <= t; o++, r += 3) {
                var d = n + (o / t) * i;
                (u.x = e * Math.cos(d)), (u.y = e * Math.sin(d)), s.push(u.x, u.y, u.z), c.push(0, 0, 1), (h.x = (s[r] / e + 1) / 2), (h.y = (s[r + 1] / e + 1) / 2), l.push(h.x, h.y);
            }
            for (r = 1; r <= t; r++) a.push(r, r + 1, 0);
            this.setIndex(a), this.setAttribute("position", new dr(s, 3)), this.setAttribute("normal", new dr(c, 3)), this.setAttribute("uv", new dr(l, 2));
        }
        (gl.prototype = Object.create(Yr.prototype)),
            (gl.prototype.constructor = gl),
            (yl.prototype = Object.create(fl.prototype)),
            (yl.prototype.constructor = yl),
            (xl.prototype = Object.create(Yr.prototype)),
            (xl.prototype.constructor = xl),
            (_l.prototype = Object.create(Mr.prototype)),
            (_l.prototype.constructor = _l),
            (bl.prototype = Object.create(Yr.prototype)),
            (bl.prototype.constructor = bl),
            (wl.prototype = Object.create(Mr.prototype)),
            (wl.prototype.constructor = wl),
            (Ml.prototype = Object.create(Yr.prototype)),
            (Ml.prototype.constructor = Ml),
            (Sl.prototype = Object.create(Mr.prototype)),
            (Sl.prototype.constructor = Sl),
            (El.prototype = Object.create(Yr.prototype)),
            (El.prototype.constructor = El),
            (El.prototype.toJSON = function () {
                var e = Yr.prototype.toJSON.call(this);
                return Al(this.parameters.shapes, e);
            }),
            (Tl.prototype = Object.create(Mr.prototype)),
            (Tl.prototype.constructor = Tl),
            (Tl.prototype.toJSON = function () {
                var e = Mr.prototype.toJSON.call(this);
                return Al(this.parameters.shapes, e);
            }),
            (Ll.prototype = Object.create(Mr.prototype)),
            (Ll.prototype.constructor = Ll),
            (Cl.prototype = Object.create(Yr.prototype)),
            (Cl.prototype.constructor = Cl),
            (Rl.prototype = Object.create(Mr.prototype)),
            (Rl.prototype.constructor = Rl),
            (Pl.prototype = Object.create(Cl.prototype)),
            (Pl.prototype.constructor = Pl),
            (Ol.prototype = Object.create(Rl.prototype)),
            (Ol.prototype.constructor = Ol),
            (Dl.prototype = Object.create(Yr.prototype)),
            (Dl.prototype.constructor = Dl),
            (Il.prototype = Object.create(Mr.prototype)),
            (Il.prototype.constructor = Il);
        var Nl = Object.freeze({
            __proto__: null,
            WireframeGeometry: Mc,
            ParametricGeometry: Sc,
            ParametricBufferGeometry: Ec,
            TetrahedronGeometry: Lc,
            TetrahedronBufferGeometry: Cc,
            OctahedronGeometry: Rc,
            OctahedronBufferGeometry: Pc,
            IcosahedronGeometry: Oc,
            IcosahedronBufferGeometry: Dc,
            DodecahedronGeometry: Ic,
            DodecahedronBufferGeometry: Nc,
            PolyhedronGeometry: Tc,
            PolyhedronBufferGeometry: Ac,
            TubeGeometry: Uc,
            TubeBufferGeometry: Bc,
            TorusKnotGeometry: zc,
            TorusKnotBufferGeometry: Fc,
            TorusGeometry: Gc,
            TorusBufferGeometry: Hc,
            TextGeometry: gl,
            TextBufferGeometry: yl,
            SphereGeometry: xl,
            SphereBufferGeometry: _l,
            RingGeometry: bl,
            RingBufferGeometry: wl,
            PlaneGeometry: xo,
            PlaneBufferGeometry: _o,
            LatheGeometry: Ml,
            LatheBufferGeometry: Sl,
            ShapeGeometry: El,
            ShapeBufferGeometry: Tl,
            ExtrudeGeometry: pl,
            ExtrudeBufferGeometry: fl,
            EdgesGeometry: Ll,
            ConeGeometry: Pl,
            ConeBufferGeometry: Ol,
            CylinderGeometry: Cl,
            CylinderBufferGeometry: Rl,
            CircleGeometry: Dl,
            CircleBufferGeometry: Il,
            BoxGeometry: Jr,
            BoxBufferGeometry: Zr,
        });
        function Ul(e) {
            nr.call(this), (this.type = "ShadowMaterial"), (this.color = new Zi(0)), (this.transparent = !0), this.setValues(e);
        }
        function Bl(e) {
            no.call(this, e), (this.type = "RawShaderMaterial");
        }
        function zl(e) {
            nr.call(this),
                (this.defines = { STANDARD: "" }),
                (this.type = "MeshStandardMaterial"),
                (this.color = new Zi(16777215)),
                (this.roughness = 0.5),
                (this.metalness = 0.5),
                (this.map = null),
                (this.lightMap = null),
                (this.lightMapIntensity = 1),
                (this.aoMap = null),
                (this.aoMapIntensity = 1),
                (this.emissive = new Zi(0)),
                (this.emissiveIntensity = 1),
                (this.emissiveMap = null),
                (this.bumpMap = null),
                (this.bumpScale = 1),
                (this.normalMap = null),
                (this.normalMapType = Vt),
                (this.normalScale = new _n(1, 1)),
                (this.displacementMap = null),
                (this.displacementScale = 1),
                (this.displacementBias = 0),
                (this.roughnessMap = null),
                (this.metalnessMap = null),
                (this.alphaMap = null),
                (this.envMap = null),
                (this.envMapIntensity = 1),
                (this.refractionRatio = 0.98),
                (this.wireframe = !1),
                (this.wireframeLinewidth = 1),
                (this.wireframeLinecap = "round"),
                (this.wireframeLinejoin = "round"),
                (this.skinning = !1),
                (this.morphTargets = !1),
                (this.morphNormals = !1),
                this.setValues(e);
        }
        function Fl(e) {
            zl.call(this),
                (this.defines = { STANDARD: "", PHYSICAL: "" }),
                (this.type = "MeshPhysicalMaterial"),
                (this.reflectivity = 0.5),
                (this.clearcoat = 0),
                (this.clearcoatRoughness = 0),
                (this.sheen = null),
                (this.clearcoatNormalScale = new _n(1, 1)),
                (this.clearcoatNormalMap = null),
                (this.transparency = 0),
                this.setValues(e);
        }
        function Gl(e) {
            nr.call(this),
                (this.type = "MeshPhongMaterial"),
                (this.color = new Zi(16777215)),
                (this.specular = new Zi(1118481)),
                (this.shininess = 30),
                (this.map = null),
                (this.lightMap = null),
                (this.lightMapIntensity = 1),
                (this.aoMap = null),
                (this.aoMapIntensity = 1),
                (this.emissive = new Zi(0)),
                (this.emissiveIntensity = 1),
                (this.emissiveMap = null),
                (this.bumpMap = null),
                (this.bumpScale = 1),
                (this.normalMap = null),
                (this.normalMapType = Vt),
                (this.normalScale = new _n(1, 1)),
                (this.displacementMap = null),
                (this.displacementScale = 1),
                (this.displacementBias = 0),
                (this.specularMap = null),
                (this.alphaMap = null),
                (this.envMap = null),
                (this.combine = ee),
                (this.reflectivity = 1),
                (this.refractionRatio = 0.98),
                (this.wireframe = !1),
                (this.wireframeLinewidth = 1),
                (this.wireframeLinecap = "round"),
                (this.wireframeLinejoin = "round"),
                (this.skinning = !1),
                (this.morphTargets = !1),
                (this.morphNormals = !1),
                this.setValues(e);
        }
        function Hl(e) {
            Gl.call(this), (this.defines = { TOON: "" }), (this.type = "MeshToonMaterial"), (this.gradientMap = null), this.setValues(e);
        }
        function Vl(e) {
            nr.call(this),
                (this.type = "MeshNormalMaterial"),
                (this.bumpMap = null),
                (this.bumpScale = 1),
                (this.normalMap = null),
                (this.normalMapType = Vt),
                (this.normalScale = new _n(1, 1)),
                (this.displacementMap = null),
                (this.displacementScale = 1),
                (this.displacementBias = 0),
                (this.wireframe = !1),
                (this.wireframeLinewidth = 1),
                (this.fog = !1),
                (this.skinning = !1),
                (this.morphTargets = !1),
                (this.morphNormals = !1),
                this.setValues(e);
        }
        function kl(e) {
            nr.call(this),
                (this.type = "MeshLambertMaterial"),
                (this.color = new Zi(16777215)),
                (this.map = null),
                (this.lightMap = null),
                (this.lightMapIntensity = 1),
                (this.aoMap = null),
                (this.aoMapIntensity = 1),
                (this.emissive = new Zi(0)),
                (this.emissiveIntensity = 1),
                (this.emissiveMap = null),
                (this.specularMap = null),
                (this.alphaMap = null),
                (this.envMap = null),
                (this.combine = ee),
                (this.reflectivity = 1),
                (this.refractionRatio = 0.98),
                (this.wireframe = !1),
                (this.wireframeLinewidth = 1),
                (this.wireframeLinecap = "round"),
                (this.wireframeLinejoin = "round"),
                (this.skinning = !1),
                (this.morphTargets = !1),
                (this.morphNormals = !1),
                this.setValues(e);
        }
        function jl(e) {
            nr.call(this),
                (this.defines = { MATCAP: "" }),
                (this.type = "MeshMatcapMaterial"),
                (this.color = new Zi(16777215)),
                (this.matcap = null),
                (this.map = null),
                (this.bumpMap = null),
                (this.bumpScale = 1),
                (this.normalMap = null),
                (this.normalMapType = Vt),
                (this.normalScale = new _n(1, 1)),
                (this.displacementMap = null),
                (this.displacementScale = 1),
                (this.displacementBias = 0),
                (this.alphaMap = null),
                (this.skinning = !1),
                (this.morphTargets = !1),
                (this.morphNormals = !1),
                this.setValues(e);
        }
        function Wl(e) {
            tc.call(this), (this.type = "LineDashedMaterial"), (this.scale = 1), (this.dashSize = 3), (this.gapSize = 1), this.setValues(e);
        }
        (Ul.prototype = Object.create(nr.prototype)),
            (Ul.prototype.constructor = Ul),
            (Ul.prototype.isShadowMaterial = !0),
            (Ul.prototype.copy = function (e) {
                return nr.prototype.copy.call(this, e), this.color.copy(e.color), this;
            }),
            (Bl.prototype = Object.create(no.prototype)),
            (Bl.prototype.constructor = Bl),
            (Bl.prototype.isRawShaderMaterial = !0),
            (zl.prototype = Object.create(nr.prototype)),
            (zl.prototype.constructor = zl),
            (zl.prototype.isMeshStandardMaterial = !0),
            (zl.prototype.copy = function (e) {
                return (
                    nr.prototype.copy.call(this, e),
                    (this.defines = { STANDARD: "" }),
                    this.color.copy(e.color),
                    (this.roughness = e.roughness),
                    (this.metalness = e.metalness),
                    (this.map = e.map),
                    (this.lightMap = e.lightMap),
                    (this.lightMapIntensity = e.lightMapIntensity),
                    (this.aoMap = e.aoMap),
                    (this.aoMapIntensity = e.aoMapIntensity),
                    this.emissive.copy(e.emissive),
                    (this.emissiveMap = e.emissiveMap),
                    (this.emissiveIntensity = e.emissiveIntensity),
                    (this.bumpMap = e.bumpMap),
                    (this.bumpScale = e.bumpScale),
                    (this.normalMap = e.normalMap),
                    (this.normalMapType = e.normalMapType),
                    this.normalScale.copy(e.normalScale),
                    (this.displacementMap = e.displacementMap),
                    (this.displacementScale = e.displacementScale),
                    (this.displacementBias = e.displacementBias),
                    (this.roughnessMap = e.roughnessMap),
                    (this.metalnessMap = e.metalnessMap),
                    (this.alphaMap = e.alphaMap),
                    (this.envMap = e.envMap),
                    (this.envMapIntensity = e.envMapIntensity),
                    (this.refractionRatio = e.refractionRatio),
                    (this.wireframe = e.wireframe),
                    (this.wireframeLinewidth = e.wireframeLinewidth),
                    (this.wireframeLinecap = e.wireframeLinecap),
                    (this.wireframeLinejoin = e.wireframeLinejoin),
                    (this.skinning = e.skinning),
                    (this.morphTargets = e.morphTargets),
                    (this.morphNormals = e.morphNormals),
                    this
                );
            }),
            (Fl.prototype = Object.create(zl.prototype)),
            (Fl.prototype.constructor = Fl),
            (Fl.prototype.isMeshPhysicalMaterial = !0),
            (Fl.prototype.copy = function (e) {
                return (
                    zl.prototype.copy.call(this, e),
                    (this.defines = { STANDARD: "", PHYSICAL: "" }),
                    (this.reflectivity = e.reflectivity),
                    (this.clearcoat = e.clearcoat),
                    (this.clearcoatRoughness = e.clearcoatRoughness),
                    e.sheen ? (this.sheen = (this.sheen || new Zi()).copy(e.sheen)) : (this.sheen = null),
                    (this.clearcoatNormalMap = e.clearcoatNormalMap),
                    this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
                    (this.transparency = e.transparency),
                    this
                );
            }),
            (Gl.prototype = Object.create(nr.prototype)),
            (Gl.prototype.constructor = Gl),
            (Gl.prototype.isMeshPhongMaterial = !0),
            (Gl.prototype.copy = function (e) {
                return (
                    nr.prototype.copy.call(this, e),
                    this.color.copy(e.color),
                    this.specular.copy(e.specular),
                    (this.shininess = e.shininess),
                    (this.map = e.map),
                    (this.lightMap = e.lightMap),
                    (this.lightMapIntensity = e.lightMapIntensity),
                    (this.aoMap = e.aoMap),
                    (this.aoMapIntensity = e.aoMapIntensity),
                    this.emissive.copy(e.emissive),
                    (this.emissiveMap = e.emissiveMap),
                    (this.emissiveIntensity = e.emissiveIntensity),
                    (this.bumpMap = e.bumpMap),
                    (this.bumpScale = e.bumpScale),
                    (this.normalMap = e.normalMap),
                    (this.normalMapType = e.normalMapType),
                    this.normalScale.copy(e.normalScale),
                    (this.displacementMap = e.displacementMap),
                    (this.displacementScale = e.displacementScale),
                    (this.displacementBias = e.displacementBias),
                    (this.specularMap = e.specularMap),
                    (this.alphaMap = e.alphaMap),
                    (this.envMap = e.envMap),
                    (this.combine = e.combine),
                    (this.reflectivity = e.reflectivity),
                    (this.refractionRatio = e.refractionRatio),
                    (this.wireframe = e.wireframe),
                    (this.wireframeLinewidth = e.wireframeLinewidth),
                    (this.wireframeLinecap = e.wireframeLinecap),
                    (this.wireframeLinejoin = e.wireframeLinejoin),
                    (this.skinning = e.skinning),
                    (this.morphTargets = e.morphTargets),
                    (this.morphNormals = e.morphNormals),
                    this
                );
            }),
            (Hl.prototype = Object.create(Gl.prototype)),
            (Hl.prototype.constructor = Hl),
            (Hl.prototype.isMeshToonMaterial = !0),
            (Hl.prototype.copy = function (e) {
                return Gl.prototype.copy.call(this, e), (this.gradientMap = e.gradientMap), this;
            }),
            (Vl.prototype = Object.create(nr.prototype)),
            (Vl.prototype.constructor = Vl),
            (Vl.prototype.isMeshNormalMaterial = !0),
            (Vl.prototype.copy = function (e) {
                return (
                    nr.prototype.copy.call(this, e),
                    (this.bumpMap = e.bumpMap),
                    (this.bumpScale = e.bumpScale),
                    (this.normalMap = e.normalMap),
                    (this.normalMapType = e.normalMapType),
                    this.normalScale.copy(e.normalScale),
                    (this.displacementMap = e.displacementMap),
                    (this.displacementScale = e.displacementScale),
                    (this.displacementBias = e.displacementBias),
                    (this.wireframe = e.wireframe),
                    (this.wireframeLinewidth = e.wireframeLinewidth),
                    (this.skinning = e.skinning),
                    (this.morphTargets = e.morphTargets),
                    (this.morphNormals = e.morphNormals),
                    this
                );
            }),
            (kl.prototype = Object.create(nr.prototype)),
            (kl.prototype.constructor = kl),
            (kl.prototype.isMeshLambertMaterial = !0),
            (kl.prototype.copy = function (e) {
                return (
                    nr.prototype.copy.call(this, e),
                    this.color.copy(e.color),
                    (this.map = e.map),
                    (this.lightMap = e.lightMap),
                    (this.lightMapIntensity = e.lightMapIntensity),
                    (this.aoMap = e.aoMap),
                    (this.aoMapIntensity = e.aoMapIntensity),
                    this.emissive.copy(e.emissive),
                    (this.emissiveMap = e.emissiveMap),
                    (this.emissiveIntensity = e.emissiveIntensity),
                    (this.specularMap = e.specularMap),
                    (this.alphaMap = e.alphaMap),
                    (this.envMap = e.envMap),
                    (this.combine = e.combine),
                    (this.reflectivity = e.reflectivity),
                    (this.refractionRatio = e.refractionRatio),
                    (this.wireframe = e.wireframe),
                    (this.wireframeLinewidth = e.wireframeLinewidth),
                    (this.wireframeLinecap = e.wireframeLinecap),
                    (this.wireframeLinejoin = e.wireframeLinejoin),
                    (this.skinning = e.skinning),
                    (this.morphTargets = e.morphTargets),
                    (this.morphNormals = e.morphNormals),
                    this
                );
            }),
            (jl.prototype = Object.create(nr.prototype)),
            (jl.prototype.constructor = jl),
            (jl.prototype.isMeshMatcapMaterial = !0),
            (jl.prototype.copy = function (e) {
                return (
                    nr.prototype.copy.call(this, e),
                    (this.defines = { MATCAP: "" }),
                    this.color.copy(e.color),
                    (this.matcap = e.matcap),
                    (this.map = e.map),
                    (this.bumpMap = e.bumpMap),
                    (this.bumpScale = e.bumpScale),
                    (this.normalMap = e.normalMap),
                    (this.normalMapType = e.normalMapType),
                    this.normalScale.copy(e.normalScale),
                    (this.displacementMap = e.displacementMap),
                    (this.displacementScale = e.displacementScale),
                    (this.displacementBias = e.displacementBias),
                    (this.alphaMap = e.alphaMap),
                    (this.skinning = e.skinning),
                    (this.morphTargets = e.morphTargets),
                    (this.morphNormals = e.morphNormals),
                    this
                );
            }),
            (Wl.prototype = Object.create(tc.prototype)),
            (Wl.prototype.constructor = Wl),
            (Wl.prototype.isLineDashedMaterial = !0),
            (Wl.prototype.copy = function (e) {
                return tc.prototype.copy.call(this, e), (this.scale = e.scale), (this.dashSize = e.dashSize), (this.gapSize = e.gapSize), this;
            });
        var ql = Object.freeze({
                __proto__: null,
                ShadowMaterial: Ul,
                SpriteMaterial: As,
                RawShaderMaterial: Bl,
                ShaderMaterial: no,
                PointsMaterial: dc,
                MeshPhysicalMaterial: Fl,
                MeshStandardMaterial: zl,
                MeshPhongMaterial: Gl,
                MeshToonMaterial: Hl,
                MeshNormalMaterial: Vl,
                MeshLambertMaterial: kl,
                MeshDepthMaterial: rs,
                MeshDistanceMaterial: os,
                MeshBasicMaterial: ir,
                MeshMatcapMaterial: jl,
                LineDashedMaterial: Wl,
                LineBasicMaterial: tc,
                Material: nr,
            }),
            Xl = {
                arraySlice: function (e, t, n) {
                    return Xl.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length)) : e.slice(t, n);
                },
                convertArray: function (e, t, n) {
                    return !e || (!n && e.constructor === t) ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e);
                },
                isTypedArray: function (e) {
                    return ArrayBuffer.isView(e) && !(e instanceof DataView);
                },
                getKeyframeOrder: function (e) {
                    for (var t = e.length, n = new Array(t), i = 0; i !== t; ++i) n[i] = i;
                    return (
                        n.sort(function (t, n) {
                            return e[t] - e[n];
                        }),
                        n
                    );
                },
                sortedArray: function (e, t, n) {
                    for (var i = e.length, r = new e.constructor(i), o = 0, a = 0; a !== i; ++o) for (var s = n[o] * t, c = 0; c !== t; ++c) r[a++] = e[s + c];
                    return r;
                },
                flattenJSON: function (e, t, n, i) {
                    for (var r = 1, o = e[0]; void 0 !== o && void 0 === o[i]; ) o = e[r++];
                    if (void 0 !== o) {
                        var a = o[i];
                        if (void 0 !== a)
                            if (Array.isArray(a))
                                do {
                                    void 0 !== (a = o[i]) && (t.push(o.time), n.push.apply(n, a)), (o = e[r++]);
                                } while (void 0 !== o);
                            else if (void 0 !== a.toArray)
                                do {
                                    void 0 !== (a = o[i]) && (t.push(o.time), a.toArray(n, n.length)), (o = e[r++]);
                                } while (void 0 !== o);
                            else
                                do {
                                    void 0 !== (a = o[i]) && (t.push(o.time), n.push(a)), (o = e[r++]);
                                } while (void 0 !== o);
                    }
                },
                subclip: function (e, t, n, i, r) {
                    r = r || 30;
                    var o = e.clone();
                    o.name = t;
                    for (var a = [], s = 0; s < o.tracks.length; ++s) {
                        for (var c = o.tracks[s], l = c.getValueSize(), u = [], h = [], d = 0; d < c.times.length; ++d) {
                            var p = c.times[d] * r;
                            if (!(p < n || p >= i)) {
                                u.push(c.times[d]);
                                for (var f = 0; f < l; ++f) h.push(c.values[d * l + f]);
                            }
                        }
                        0 !== u.length && ((c.times = Xl.convertArray(u, c.times.constructor)), (c.values = Xl.convertArray(h, c.values.constructor)), a.push(c));
                    }
                    o.tracks = a;
                    var m = 1 / 0;
                    for (s = 0; s < o.tracks.length; ++s) m > o.tracks[s].times[0] && (m = o.tracks[s].times[0]);
                    for (s = 0; s < o.tracks.length; ++s) o.tracks[s].shift(-1 * m);
                    return o.resetDuration(), o;
                },
            };
        function Yl(e, t, n, i) {
            (this.parameterPositions = e), (this._cachedIndex = 0), (this.resultBuffer = void 0 !== i ? i : new t.constructor(n)), (this.sampleValues = t), (this.valueSize = n);
        }
        function Jl(e, t, n, i) {
            Yl.call(this, e, t, n, i), (this._weightPrev = -0), (this._offsetPrev = -0), (this._weightNext = -0), (this._offsetNext = -0);
        }
        function Zl(e, t, n, i) {
            Yl.call(this, e, t, n, i);
        }
        function Kl(e, t, n, i) {
            Yl.call(this, e, t, n, i);
        }
        function Ql(e, t, n, i) {
            if (void 0 === e) throw new Error("THREE.KeyframeTrack: track name is undefined");
            if (void 0 === t || 0 === t.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
            (this.name = e), (this.times = Xl.convertArray(t, this.TimeBufferType)), (this.values = Xl.convertArray(n, this.ValueBufferType)), this.setInterpolation(i || this.DefaultInterpolation);
        }
        function $l(e, t, n) {
            Ql.call(this, e, t, n);
        }
        function eu(e, t, n, i) {
            Ql.call(this, e, t, n, i);
        }
        function tu(e, t, n, i) {
            Ql.call(this, e, t, n, i);
        }
        function nu(e, t, n, i) {
            Yl.call(this, e, t, n, i);
        }
        function iu(e, t, n, i) {
            Ql.call(this, e, t, n, i);
        }
        function ru(e, t, n, i) {
            Ql.call(this, e, t, n, i);
        }
        function ou(e, t, n, i) {
            Ql.call(this, e, t, n, i);
        }
        function au(e, t, n) {
            (this.name = e), (this.tracks = n), (this.duration = void 0 !== t ? t : -1), (this.uuid = xn.generateUUID()), this.duration < 0 && this.resetDuration();
        }
        function su(e) {
            if (void 0 === e.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
            var t = (function (e) {
                switch (e.toLowerCase()) {
                    case "scalar":
                    case "double":
                    case "float":
                    case "number":
                    case "integer":
                        return tu;
                    case "vector":
                    case "vector2":
                    case "vector3":
                    case "vector4":
                        return ou;
                    case "color":
                        return eu;
                    case "quaternion":
                        return iu;
                    case "bool":
                    case "boolean":
                        return $l;
                    case "string":
                        return ru;
                }
                throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e);
            })(e.type);
            if (void 0 === e.times) {
                var n = [],
                    i = [];
                Xl.flattenJSON(e.keys, n, i, "value"), (e.times = n), (e.values = i);
            }
            return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation);
        }
        Object.assign(Yl.prototype, {
            evaluate: function (e) {
                var t = this.parameterPositions,
                    n = this._cachedIndex,
                    i = t[n],
                    r = t[n - 1];
                e: {
                    t: {
                        var o;
                        n: {
                            i: if (!(e < i)) {
                                for (var a = n + 2; ; ) {
                                    if (void 0 === i) {
                                        if (e < r) break i;
                                        return (n = t.length), (this._cachedIndex = n), this.afterEnd_(n - 1, e, r);
                                    }
                                    if (n === a) break;
                                    if (((r = i), e < (i = t[++n]))) break t;
                                }
                                o = t.length;
                                break n;
                            }
                            if (e >= r) break e;
                            var s = t[1];
                            e < s && ((n = 2), (r = s));
                            for (a = n - 2; ; ) {
                                if (void 0 === r) return (this._cachedIndex = 0), this.beforeStart_(0, e, i);
                                if (n === a) break;
                                if (((i = r), e >= (r = t[--n - 1]))) break t;
                            }
                            (o = n), (n = 0);
                        }
                        for (; n < o; ) {
                            var c = (n + o) >>> 1;
                            e < t[c] ? (o = c) : (n = c + 1);
                        }
                        if (((i = t[n]), void 0 === (r = t[n - 1]))) return (this._cachedIndex = 0), this.beforeStart_(0, e, i);
                        if (void 0 === i) return (n = t.length), (this._cachedIndex = n), this.afterEnd_(n - 1, r, e);
                    }
                    (this._cachedIndex = n), this.intervalChanged_(n, r, i);
                }
                return this.interpolate_(n, r, e, i);
            },
            settings: null,
            DefaultSettings_: {},
            getSettings_: function () {
                return this.settings || this.DefaultSettings_;
            },
            copySampleValue_: function (e) {
                for (var t = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = e * i, o = 0; o !== i; ++o) t[o] = n[r + o];
                return t;
            },
            interpolate_: function () {
                throw new Error("call to abstract method");
            },
            intervalChanged_: function () {},
        }),
            //!\ DECLARE ALIAS AFTER assign prototype !
            Object.assign(Yl.prototype, { beforeStart_: Yl.prototype.copySampleValue_, afterEnd_: Yl.prototype.copySampleValue_ }),
            (Jl.prototype = Object.assign(Object.create(Yl.prototype), {
                constructor: Jl,
                DefaultSettings_: { endingStart: Tt, endingEnd: Tt },
                intervalChanged_: function (e, t, n) {
                    var i = this.parameterPositions,
                        r = e - 2,
                        o = e + 1,
                        a = i[r],
                        s = i[o];
                    if (void 0 === a)
                        switch (this.getSettings_().endingStart) {
                            case At:
                                (r = e), (a = 2 * t - n);
                                break;
                            case Lt:
                                a = t + i[(r = i.length - 2)] - i[r + 1];
                                break;
                            default:
                                (r = e), (a = n);
                        }
                    if (void 0 === s)
                        switch (this.getSettings_().endingEnd) {
                            case At:
                                (o = e), (s = 2 * n - t);
                                break;
                            case Lt:
                                (o = 1), (s = n + i[1] - i[0]);
                                break;
                            default:
                                (o = e - 1), (s = t);
                        }
                    var c = 0.5 * (n - t),
                        l = this.valueSize;
                    (this._weightPrev = c / (t - a)), (this._weightNext = c / (s - n)), (this._offsetPrev = r * l), (this._offsetNext = o * l);
                },
                interpolate_: function (e, t, n, i) {
                    for (
                        var r = this.resultBuffer,
                            o = this.sampleValues,
                            a = this.valueSize,
                            s = e * a,
                            c = s - a,
                            l = this._offsetPrev,
                            u = this._offsetNext,
                            h = this._weightPrev,
                            d = this._weightNext,
                            p = (n - t) / (i - t),
                            f = p * p,
                            m = f * p,
                            v = -h * m + 2 * h * f - h * p,
                            g = (1 + h) * m + (-1.5 - 2 * h) * f + (-0.5 + h) * p + 1,
                            y = (-1 - d) * m + (1.5 + d) * f + 0.5 * p,
                            x = d * m - d * f,
                            _ = 0;
                        _ !== a;
                        ++_
                    )
                        r[_] = v * o[l + _] + g * o[c + _] + y * o[s + _] + x * o[u + _];
                    return r;
                },
            })),
            (Zl.prototype = Object.assign(Object.create(Yl.prototype), {
                constructor: Zl,
                interpolate_: function (e, t, n, i) {
                    for (var r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = e * a, c = s - a, l = (n - t) / (i - t), u = 1 - l, h = 0; h !== a; ++h) r[h] = o[c + h] * u + o[s + h] * l;
                    return r;
                },
            })),
            (Kl.prototype = Object.assign(Object.create(Yl.prototype), {
                constructor: Kl,
                interpolate_: function (e) {
                    return this.copySampleValue_(e - 1);
                },
            })),
            Object.assign(Ql, {
                toJSON: function (e) {
                    var t,
                        n = e.constructor;
                    if (void 0 !== n.toJSON) t = n.toJSON(e);
                    else {
                        t = { name: e.name, times: Xl.convertArray(e.times, Array), values: Xl.convertArray(e.values, Array) };
                        var i = e.getInterpolation();
                        i !== e.DefaultInterpolation && (t.interpolation = i);
                    }
                    return (t.type = e.ValueTypeName), t;
                },
            }),
            Object.assign(Ql.prototype, {
                constructor: Ql,
                TimeBufferType: Float32Array,
                ValueBufferType: Float32Array,
                DefaultInterpolation: St,
                InterpolantFactoryMethodDiscrete: function (e) {
                    return new Kl(this.times, this.values, this.getValueSize(), e);
                },
                InterpolantFactoryMethodLinear: function (e) {
                    return new Zl(this.times, this.values, this.getValueSize(), e);
                },
                InterpolantFactoryMethodSmooth: function (e) {
                    return new Jl(this.times, this.values, this.getValueSize(), e);
                },
                setInterpolation: function (e) {
                    var t;
                    switch (e) {
                        case Mt:
                            t = this.InterpolantFactoryMethodDiscrete;
                            break;
                        case St:
                            t = this.InterpolantFactoryMethodLinear;
                            break;
                        case Et:
                            t = this.InterpolantFactoryMethodSmooth;
                    }
                    if (void 0 === t) {
                        var n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                        if (void 0 === this.createInterpolant) {
                            if (e === this.DefaultInterpolation) throw new Error(n);
                            this.setInterpolation(this.DefaultInterpolation);
                        }
                        return console.warn("THREE.KeyframeTrack:", n), this;
                    }
                    return (this.createInterpolant = t), this;
                },
                getInterpolation: function () {
                    switch (this.createInterpolant) {
                        case this.InterpolantFactoryMethodDiscrete:
                            return Mt;
                        case this.InterpolantFactoryMethodLinear:
                            return St;
                        case this.InterpolantFactoryMethodSmooth:
                            return Et;
                    }
                },
                getValueSize: function () {
                    return this.values.length / this.times.length;
                },
                shift: function (e) {
                    if (0 !== e) for (var t = this.times, n = 0, i = t.length; n !== i; ++n) t[n] += e;
                    return this;
                },
                scale: function (e) {
                    if (1 !== e) for (var t = this.times, n = 0, i = t.length; n !== i; ++n) t[n] *= e;
                    return this;
                },
                trim: function (e, t) {
                    for (var n = this.times, i = n.length, r = 0, o = i - 1; r !== i && n[r] < e; ) ++r;
                    for (; -1 !== o && n[o] > t; ) --o;
                    if ((++o, 0 !== r || o !== i)) {
                        r >= o && (r = (o = Math.max(o, 1)) - 1);
                        var a = this.getValueSize();
                        (this.times = Xl.arraySlice(n, r, o)), (this.values = Xl.arraySlice(this.values, r * a, o * a));
                    }
                    return this;
                },
                validate: function () {
                    var e = !0,
                        t = this.getValueSize();
                    t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), (e = !1));
                    var n = this.times,
                        i = this.values,
                        r = n.length;
                    0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), (e = !1));
                    for (var o = null, a = 0; a !== r; a++) {
                        var s = n[a];
                        if ("number" == typeof s && isNaN(s)) {
                            console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, s), (e = !1);
                            break;
                        }
                        if (null !== o && o > s) {
                            console.error("THREE.KeyframeTrack: Out of order keys.", this, a, s, o), (e = !1);
                            break;
                        }
                        o = s;
                    }
                    if (void 0 !== i && Xl.isTypedArray(i)) {
                        a = 0;
                        for (var c = i.length; a !== c; ++a) {
                            var l = i[a];
                            if (isNaN(l)) {
                                console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, l), (e = !1);
                                break;
                            }
                        }
                    }
                    return e;
                },
                optimize: function () {
                    for (var e = this.times, t = this.values, n = this.getValueSize(), i = this.getInterpolation() === Et, r = 1, o = e.length - 1, a = 1; a < o; ++a) {
                        var s = !1,
                            c = e[a];
                        if (c !== e[a + 1] && (1 !== a || c !== c[0]))
                            if (i) s = !0;
                            else
                                for (var l = a * n, u = l - n, h = l + n, d = 0; d !== n; ++d) {
                                    var p = t[l + d];
                                    if (p !== t[u + d] || p !== t[h + d]) {
                                        s = !0;
                                        break;
                                    }
                                }
                        if (s) {
                            if (a !== r) {
                                e[r] = e[a];
                                var f = a * n,
                                    m = r * n;
                                for (d = 0; d !== n; ++d) t[m + d] = t[f + d];
                            }
                            ++r;
                        }
                    }
                    if (o > 0) {
                        e[r] = e[o];
                        for (f = o * n, m = r * n, d = 0; d !== n; ++d) t[m + d] = t[f + d];
                        ++r;
                    }
                    return r !== e.length && ((this.times = Xl.arraySlice(e, 0, r)), (this.values = Xl.arraySlice(t, 0, r * n))), this;
                },
                clone: function () {
                    var e = Xl.arraySlice(this.times, 0),
                        t = Xl.arraySlice(this.values, 0),
                        n = new (0, this.constructor)(this.name, e, t);
                    return (n.createInterpolant = this.createInterpolant), n;
                },
            }),
            ($l.prototype = Object.assign(Object.create(Ql.prototype), {
                constructor: $l,
                ValueTypeName: "bool",
                ValueBufferType: Array,
                DefaultInterpolation: Mt,
                InterpolantFactoryMethodLinear: void 0,
                InterpolantFactoryMethodSmooth: void 0,
            })),
            (eu.prototype = Object.assign(Object.create(Ql.prototype), { constructor: eu, ValueTypeName: "color" })),
            (tu.prototype = Object.assign(Object.create(Ql.prototype), { constructor: tu, ValueTypeName: "number" })),
            (nu.prototype = Object.assign(Object.create(Yl.prototype), {
                constructor: nu,
                interpolate_: function (e, t, n, i) {
                    for (var r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = e * a, c = (n - t) / (i - t), l = s + a; s !== l; s += 4) bn.slerpFlat(r, 0, o, s - a, o, s, c);
                    return r;
                },
            })),
            (iu.prototype = Object.assign(Object.create(Ql.prototype), {
                constructor: iu,
                ValueTypeName: "quaternion",
                DefaultInterpolation: St,
                InterpolantFactoryMethodLinear: function (e) {
                    return new nu(this.times, this.values, this.getValueSize(), e);
                },
                InterpolantFactoryMethodSmooth: void 0,
            })),
            (ru.prototype = Object.assign(Object.create(Ql.prototype), {
                constructor: ru,
                ValueTypeName: "string",
                ValueBufferType: Array,
                DefaultInterpolation: Mt,
                InterpolantFactoryMethodLinear: void 0,
                InterpolantFactoryMethodSmooth: void 0,
            })),
            (ou.prototype = Object.assign(Object.create(Ql.prototype), { constructor: ou, ValueTypeName: "vector" })),
            Object.assign(au, {
                parse: function (e) {
                    for (var t = [], n = e.tracks, i = 1 / (e.fps || 1), r = 0, o = n.length; r !== o; ++r) t.push(su(n[r]).scale(i));
                    return new au(e.name, e.duration, t);
                },
                toJSON: function (e) {
                    for (var t = [], n = e.tracks, i = { name: e.name, duration: e.duration, tracks: t, uuid: e.uuid }, r = 0, o = n.length; r !== o; ++r) t.push(Ql.toJSON(n[r]));
                    return i;
                },
                CreateFromMorphTargetSequence: function (e, t, n, i) {
                    for (var r = t.length, o = [], a = 0; a < r; a++) {
                        var s = [],
                            c = [];
                        s.push((a + r - 1) % r, a, (a + 1) % r), c.push(0, 1, 0);
                        var l = Xl.getKeyframeOrder(s);
                        (s = Xl.sortedArray(s, 1, l)), (c = Xl.sortedArray(c, 1, l)), i || 0 !== s[0] || (s.push(r), c.push(c[0])), o.push(new tu(".morphTargetInfluences[" + t[a].name + "]", s, c).scale(1 / n));
                    }
                    return new au(e, -1, o);
                },
                findByName: function (e, t) {
                    var n = e;
                    if (!Array.isArray(e)) {
                        var i = e;
                        n = (i.geometry && i.geometry.animations) || i.animations;
                    }
                    for (var r = 0; r < n.length; r++) if (n[r].name === t) return n[r];
                    return null;
                },
                CreateClipsFromMorphTargetSequences: function (e, t, n) {
                    for (var i = {}, r = /^([\w-]*?)([\d]+)$/, o = 0, a = e.length; o < a; o++) {
                        var s = e[o],
                            c = s.name.match(r);
                        if (c && c.length > 1) {
                            var l = i[(h = c[1])];
                            l || (i[h] = l = []), l.push(s);
                        }
                    }
                    var u = [];
                    for (var h in i) u.push(au.CreateFromMorphTargetSequence(h, i[h], t, n));
                    return u;
                },
                parseAnimation: function (e, t) {
                    if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                    for (
                        var n = function (e, t, n, i, r) {
                                if (0 !== n.length) {
                                    var o = [],
                                        a = [];
                                    Xl.flattenJSON(n, o, a, i), 0 !== o.length && r.push(new e(t, o, a));
                                }
                            },
                            i = [],
                            r = e.name || "default",
                            o = e.length || -1,
                            a = e.fps || 30,
                            s = e.hierarchy || [],
                            c = 0;
                        c < s.length;
                        c++
                    ) {
                        var l = s[c].keys;
                        if (l && 0 !== l.length)
                            if (l[0].morphTargets) {
                                for (var u = {}, h = 0; h < l.length; h++) if (l[h].morphTargets) for (var d = 0; d < l[h].morphTargets.length; d++) u[l[h].morphTargets[d]] = -1;
                                for (var p in u) {
                                    var f = [],
                                        m = [];
                                    for (d = 0; d !== l[h].morphTargets.length; ++d) {
                                        var v = l[h];
                                        f.push(v.time), m.push(v.morphTarget === p ? 1 : 0);
                                    }
                                    i.push(new tu(".morphTargetInfluence[" + p + "]", f, m));
                                }
                                o = u.length * (a || 1);
                            } else {
                                var g = ".bones[" + t[c].name + "]";
                                n(ou, g + ".position", l, "pos", i), n(iu, g + ".quaternion", l, "rot", i), n(ou, g + ".scale", l, "scl", i);
                            }
                    }
                    return 0 === i.length ? null : new au(r, o, i);
                },
            }),
            Object.assign(au.prototype, {
                resetDuration: function () {
                    for (var e = 0, t = 0, n = this.tracks.length; t !== n; ++t) {
                        var i = this.tracks[t];
                        e = Math.max(e, i.times[i.times.length - 1]);
                    }
                    return (this.duration = e), this;
                },
                trim: function () {
                    for (var e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
                    return this;
                },
                validate: function () {
                    for (var e = !0, t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
                    return e;
                },
                optimize: function () {
                    for (var e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
                    return this;
                },
                clone: function () {
                    for (var e = [], t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
                    return new au(this.name, this.duration, e);
                },
            });
        var cu = {
            enabled: !1,
            files: {},
            add: function (e, t) {
                !1 !== this.enabled && (this.files[e] = t);
            },
            get: function (e) {
                if (!1 !== this.enabled) return this.files[e];
            },
            remove: function (e) {
                delete this.files[e];
            },
            clear: function () {
                this.files = {};
            },
        };
        function lu(e, t, n) {
            var i = this,
                r = !1,
                o = 0,
                a = 0,
                s = void 0,
                c = [];
            (this.onStart = void 0),
                (this.onLoad = e),
                (this.onProgress = t),
                (this.onError = n),
                (this.itemStart = function (e) {
                    a++, !1 === r && void 0 !== i.onStart && i.onStart(e, o, a), (r = !0);
                }),
                (this.itemEnd = function (e) {
                    o++, void 0 !== i.onProgress && i.onProgress(e, o, a), o === a && ((r = !1), void 0 !== i.onLoad && i.onLoad());
                }),
                (this.itemError = function (e) {
                    void 0 !== i.onError && i.onError(e);
                }),
                (this.resolveURL = function (e) {
                    return s ? s(e) : e;
                }),
                (this.setURLModifier = function (e) {
                    return (s = e), this;
                }),
                (this.addHandler = function (e, t) {
                    return c.push(e, t), this;
                }),
                (this.removeHandler = function (e) {
                    var t = c.indexOf(e);
                    return -1 !== t && c.splice(t, 2), this;
                }),
                (this.getHandler = function (e) {
                    for (var t = 0, n = c.length; t < n; t += 2) {
                        var i = c[t],
                            r = c[t + 1];
                        if ((i.global && (i.lastIndex = 0), i.test(e))) return r;
                    }
                    return null;
                });
        }
        var uu = new lu();
        function hu(e) {
            (this.manager = void 0 !== e ? e : uu), (this.crossOrigin = "anonymous"), (this.path = ""), (this.resourcePath = "");
        }
        Object.assign(hu.prototype, {
            load: function () {},
            parse: function () {},
            setCrossOrigin: function (e) {
                return (this.crossOrigin = e), this;
            },
            setPath: function (e) {
                return (this.path = e), this;
            },
            setResourcePath: function (e) {
                return (this.resourcePath = e), this;
            },
        });
        var du = {};
        function pu(e) {
            hu.call(this, e);
        }
        function fu(e) {
            hu.call(this, e);
        }
        function mu(e) {
            hu.call(this, e);
        }
        function vu(e) {
            hu.call(this, e);
        }
        function gu(e) {
            hu.call(this, e);
        }
        function yu(e) {
            hu.call(this, e);
        }
        function xu(e) {
            hu.call(this, e);
        }
        function _u() {
            (this.type = "Curve"), (this.arcLengthDivisions = 200);
        }
        function bu(e, t, n, i, r, o, a, s) {
            _u.call(this),
                (this.type = "EllipseCurve"),
                (this.aX = e || 0),
                (this.aY = t || 0),
                (this.xRadius = n || 1),
                (this.yRadius = i || 1),
                (this.aStartAngle = r || 0),
                (this.aEndAngle = o || 2 * Math.PI),
                (this.aClockwise = a || !1),
                (this.aRotation = s || 0);
        }
        function wu(e, t, n, i, r, o) {
            bu.call(this, e, t, n, n, i, r, o), (this.type = "ArcCurve");
        }
        function Mu() {
            var e = 0,
                t = 0,
                n = 0,
                i = 0;
            function r(r, o, a, s) {
                (e = r), (t = a), (n = -3 * r + 3 * o - 2 * a - s), (i = 2 * r - 2 * o + a + s);
            }
            return {
                initCatmullRom: function (e, t, n, i, o) {
                    r(t, n, o * (n - e), o * (i - t));
                },
                initNonuniformCatmullRom: function (e, t, n, i, o, a, s) {
                    var c = (t - e) / o - (n - e) / (o + a) + (n - t) / a,
                        l = (n - t) / a - (i - t) / (a + s) + (i - n) / s;
                    r(t, n, (c *= a), (l *= a));
                },
                calc: function (r) {
                    var o = r * r;
                    return e + t * r + n * o + i * (o * r);
                },
            };
        }
        (pu.prototype = Object.assign(Object.create(hu.prototype), {
            constructor: pu,
            load: function (e, t, n, i) {
                void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), (e = this.manager.resolveURL(e));
                var r = this,
                    o = cu.get(e);
                if (void 0 !== o)
                    return (
                        r.manager.itemStart(e),
                        setTimeout(function () {
                            t && t(o), r.manager.itemEnd(e);
                        }, 0),
                        o
                    );
                if (void 0 === du[e]) {
                    var a = e.match(/^data:(.*?)(;base64)?,(.*)$/);
                    if (a) {
                        var s = a[1],
                            c = !!a[2],
                            l = a[3];
                        (l = decodeURIComponent(l)), c && (l = atob(l));
                        try {
                            var u,
                                h = (this.responseType || "").toLowerCase();
                            switch (h) {
                                case "arraybuffer":
                                case "blob":
                                    for (var d = new Uint8Array(l.length), p = 0; p < l.length; p++) d[p] = l.charCodeAt(p);
                                    u = "blob" === h ? new Blob([d.buffer], { type: s }) : d.buffer;
                                    break;
                                case "document":
                                    var f = new DOMParser();
                                    u = f.parseFromString(l, s);
                                    break;
                                case "json":
                                    u = JSON.parse(l);
                                    break;
                                default:
                                    u = l;
                            }
                            setTimeout(function () {
                                t && t(u), r.manager.itemEnd(e);
                            }, 0);
                        } catch (t) {
                            setTimeout(function () {
                                i && i(t), r.manager.itemError(e), r.manager.itemEnd(e);
                            }, 0);
                        }
                    } else {
                        (du[e] = []), du[e].push({ onLoad: t, onProgress: n, onError: i });
                        var m = new XMLHttpRequest();
                        for (var v in (m.open("GET", e, !0),
                        m.addEventListener(
                            "load",
                            function (t) {
                                var n = this.response,
                                    i = du[e];
                                if ((delete du[e], 200 === this.status || 0 === this.status)) {
                                    0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), cu.add(e, n);
                                    for (var o = 0, a = i.length; o < a; o++) {
                                        (s = i[o]).onLoad && s.onLoad(n);
                                    }
                                    r.manager.itemEnd(e);
                                } else {
                                    for (o = 0, a = i.length; o < a; o++) {
                                        var s;
                                        (s = i[o]).onError && s.onError(t);
                                    }
                                    r.manager.itemError(e), r.manager.itemEnd(e);
                                }
                            },
                            !1
                        ),
                        m.addEventListener(
                            "progress",
                            function (t) {
                                for (var n = du[e], i = 0, r = n.length; i < r; i++) {
                                    var o = n[i];
                                    o.onProgress && o.onProgress(t);
                                }
                            },
                            !1
                        ),
                        m.addEventListener(
                            "error",
                            function (t) {
                                var n = du[e];
                                delete du[e];
                                for (var i = 0, o = n.length; i < o; i++) {
                                    var a = n[i];
                                    a.onError && a.onError(t);
                                }
                                r.manager.itemError(e), r.manager.itemEnd(e);
                            },
                            !1
                        ),
                        m.addEventListener(
                            "abort",
                            function (t) {
                                var n = du[e];
                                delete du[e];
                                for (var i = 0, o = n.length; i < o; i++) {
                                    var a = n[i];
                                    a.onError && a.onError(t);
                                }
                                r.manager.itemError(e), r.manager.itemEnd(e);
                            },
                            !1
                        ),
                        void 0 !== this.responseType && (m.responseType = this.responseType),
                        void 0 !== this.withCredentials && (m.withCredentials = this.withCredentials),
                        m.overrideMimeType && m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"),
                        this.requestHeader))
                            m.setRequestHeader(v, this.requestHeader[v]);
                        m.send(null);
                    }
                    return r.manager.itemStart(e), m;
                }
                du[e].push({ onLoad: t, onProgress: n, onError: i });
            },
            setResponseType: function (e) {
                return (this.responseType = e), this;
            },
            setWithCredentials: function (e) {
                return (this.withCredentials = e), this;
            },
            setMimeType: function (e) {
                return (this.mimeType = e), this;
            },
            setRequestHeader: function (e) {
                return (this.requestHeader = e), this;
            },
        })),
            (fu.prototype = Object.assign(Object.create(hu.prototype), {
                constructor: fu,
                load: function (e, t, n, i) {
                    var r = this,
                        o = new pu(r.manager);
                    o.setPath(r.path),
                        o.load(
                            e,
                            function (e) {
                                t(r.parse(JSON.parse(e)));
                            },
                            n,
                            i
                        );
                },
                parse: function (e) {
                    for (var t = [], n = 0; n < e.length; n++) {
                        var i = au.parse(e[n]);
                        t.push(i);
                    }
                    return t;
                },
            })),
            (mu.prototype = Object.assign(Object.create(hu.prototype), {
                constructor: mu,
                load: function (e, t, n, i) {
                    var r = this,
                        o = [],
                        a = new _c();
                    a.image = o;
                    var s = new pu(this.manager);
                    function c(c) {
                        s.load(
                            e[c],
                            function (e) {
                                var n = r.parse(e, !0);
                                (o[c] = { width: n.width, height: n.height, format: n.format, mipmaps: n.mipmaps }), 6 === (l += 1) && (1 === n.mipmapCount && (a.minFilter = Ee), (a.format = n.format), (a.needsUpdate = !0), t && t(a));
                            },
                            n,
                            i
                        );
                    }
                    if ((s.setPath(this.path), s.setResponseType("arraybuffer"), Array.isArray(e))) for (var l = 0, u = 0, h = e.length; u < h; ++u) c(u);
                    else
                        s.load(
                            e,
                            function (e) {
                                var n = r.parse(e, !0);
                                if (n.isCubemap)
                                    for (var i = n.mipmaps.length / n.mipmapCount, s = 0; s < i; s++) {
                                        o[s] = { mipmaps: [] };
                                        for (var c = 0; c < n.mipmapCount; c++) o[s].mipmaps.push(n.mipmaps[s * n.mipmapCount + c]), (o[s].format = n.format), (o[s].width = n.width), (o[s].height = n.height);
                                    }
                                else (a.image.width = n.width), (a.image.height = n.height), (a.mipmaps = n.mipmaps);
                                1 === n.mipmapCount && (a.minFilter = Ee), (a.format = n.format), (a.needsUpdate = !0), t && t(a);
                            },
                            n,
                            i
                        );
                    return a;
                },
            })),
            (vu.prototype = Object.assign(Object.create(hu.prototype), {
                constructor: vu,
                load: function (e, t, n, i) {
                    var r = this,
                        o = new lo(),
                        a = new pu(this.manager);
                    return (
                        a.setResponseType("arraybuffer"),
                        a.setPath(this.path),
                        a.load(
                            e,
                            function (e) {
                                var n = r.parse(e);
                                n &&
                                    (void 0 !== n.image ? (o.image = n.image) : void 0 !== n.data && ((o.image.width = n.width), (o.image.height = n.height), (o.image.data = n.data)),
                                    (o.wrapS = void 0 !== n.wrapS ? n.wrapS : ye),
                                    (o.wrapT = void 0 !== n.wrapT ? n.wrapT : ye),
                                    (o.magFilter = void 0 !== n.magFilter ? n.magFilter : Ee),
                                    (o.minFilter = void 0 !== n.minFilter ? n.minFilter : Ee),
                                    (o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1),
                                    void 0 !== n.format && (o.format = n.format),
                                    void 0 !== n.type && (o.type = n.type),
                                    void 0 !== n.mipmaps && ((o.mipmaps = n.mipmaps), (o.minFilter = Le)),
                                    1 === n.mipmapCount && (o.minFilter = Ee),
                                    (o.needsUpdate = !0),
                                    t && t(o, n));
                            },
                            n,
                            i
                        ),
                        o
                    );
                },
            })),
            (gu.prototype = Object.assign(Object.create(hu.prototype), {
                constructor: gu,
                load: function (e, t, n, i) {
                    void 0 !== this.path && (e = this.path + e), (e = this.manager.resolveURL(e));
                    var r = this,
                        o = cu.get(e);
                    if (void 0 !== o)
                        return (
                            r.manager.itemStart(e),
                            setTimeout(function () {
                                t && t(o), r.manager.itemEnd(e);
                            }, 0),
                            o
                        );
                    var a = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
                    function s() {
                        a.removeEventListener("load", s, !1), a.removeEventListener("error", c, !1), cu.add(e, this), t && t(this), r.manager.itemEnd(e);
                    }
                    function c(t) {
                        a.removeEventListener("load", s, !1), a.removeEventListener("error", c, !1), i && i(t), r.manager.itemError(e), r.manager.itemEnd(e);
                    }
                    return a.addEventListener("load", s, !1), a.addEventListener("error", c, !1), "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), r.manager.itemStart(e), (a.src = e), a;
                },
            })),
            (yu.prototype = Object.assign(Object.create(hu.prototype), {
                constructor: yu,
                load: function (e, t, n, i) {
                    var r = new Oo(),
                        o = new gu(this.manager);
                    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
                    var a = 0;
                    function s(n) {
                        o.load(
                            e[n],
                            function (e) {
                                (r.images[n] = e), 6 === ++a && ((r.needsUpdate = !0), t && t(r));
                            },
                            void 0,
                            i
                        );
                    }
                    for (var c = 0; c < e.length; ++c) s(c);
                    return r;
                },
            })),
            (xu.prototype = Object.assign(Object.create(hu.prototype), {
                constructor: xu,
                load: function (e, t, n, i) {
                    var r = new Rn(),
                        o = new gu(this.manager);
                    return (
                        o.setCrossOrigin(this.crossOrigin),
                        o.setPath(this.path),
                        o.load(
                            e,
                            function (n) {
                                r.image = n;
                                var i = e.search(/\.jpe?g($|\?)/i) > 0 || 0 === e.search(/^data\:image\/jpeg/);
                                (r.format = i ? ke : je), (r.needsUpdate = !0), void 0 !== t && t(r);
                            },
                            n,
                            i
                        ),
                        r
                    );
                },
            })),
            Object.assign(_u.prototype, {
                getPoint: function () {
                    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
                },
                getPointAt: function (e, t) {
                    var n = this.getUtoTmapping(e);
                    return this.getPoint(n, t);
                },
                getPoints: function (e) {
                    void 0 === e && (e = 5);
                    for (var t = [], n = 0; n <= e; n++) t.push(this.getPoint(n / e));
                    return t;
                },
                getSpacedPoints: function (e) {
                    void 0 === e && (e = 5);
                    for (var t = [], n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
                    return t;
                },
                getLength: function () {
                    var e = this.getLengths();
                    return e[e.length - 1];
                },
                getLengths: function (e) {
                    if ((void 0 === e && (e = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)) return this.cacheArcLengths;
                    this.needsUpdate = !1;
                    var t,
                        n,
                        i = [],
                        r = this.getPoint(0),
                        o = 0;
                    for (i.push(0), n = 1; n <= e; n++) (o += (t = this.getPoint(n / e)).distanceTo(r)), i.push(o), (r = t);
                    return (this.cacheArcLengths = i), i;
                },
                updateArcLengths: function () {
                    (this.needsUpdate = !0), this.getLengths();
                },
                getUtoTmapping: function (e, t) {
                    var n,
                        i = this.getLengths(),
                        r = 0,
                        o = i.length;
                    n = t || e * i[o - 1];
                    for (var a, s = 0, c = o - 1; s <= c; )
                        if ((a = i[(r = Math.floor(s + (c - s) / 2))] - n) < 0) s = r + 1;
                        else {
                            if (!(a > 0)) {
                                c = r;
                                break;
                            }
                            c = r - 1;
                        }
                    if (i[(r = c)] === n) return r / (o - 1);
                    var l = i[r];
                    return (r + (n - l) / (i[r + 1] - l)) / (o - 1);
                },
                getTangent: function (e) {
                    var t = e - 1e-4,
                        n = e + 1e-4;
                    t < 0 && (t = 0), n > 1 && (n = 1);
                    var i = this.getPoint(t);
                    return this.getPoint(n).clone().sub(i).normalize();
                },
                getTangentAt: function (e) {
                    var t = this.getUtoTmapping(e);
                    return this.getTangent(t);
                },
                computeFrenetFrames: function (e, t) {
                    var n,
                        i,
                        r,
                        o = new Sn(),
                        a = [],
                        s = [],
                        c = [],
                        l = new Sn(),
                        u = new Hn();
                    for (n = 0; n <= e; n++) (i = n / e), (a[n] = this.getTangentAt(i)), a[n].normalize();
                    (s[0] = new Sn()), (c[0] = new Sn());
                    var h = Number.MAX_VALUE,
                        d = Math.abs(a[0].x),
                        p = Math.abs(a[0].y),
                        f = Math.abs(a[0].z);
                    for (d <= h && ((h = d), o.set(1, 0, 0)), p <= h && ((h = p), o.set(0, 1, 0)), f <= h && o.set(0, 0, 1), l.crossVectors(a[0], o).normalize(), s[0].crossVectors(a[0], l), c[0].crossVectors(a[0], s[0]), n = 1; n <= e; n++)
                        (s[n] = s[n - 1].clone()),
                            (c[n] = c[n - 1].clone()),
                            l.crossVectors(a[n - 1], a[n]),
                            l.length() > Number.EPSILON && (l.normalize(), (r = Math.acos(xn.clamp(a[n - 1].dot(a[n]), -1, 1))), s[n].applyMatrix4(u.makeRotationAxis(l, r))),
                            c[n].crossVectors(a[n], s[n]);
                    if (!0 === t)
                        for (r = Math.acos(xn.clamp(s[0].dot(s[e]), -1, 1)), r /= e, a[0].dot(l.crossVectors(s[0], s[e])) > 0 && (r = -r), n = 1; n <= e; n++)
                            s[n].applyMatrix4(u.makeRotationAxis(a[n], r * n)), c[n].crossVectors(a[n], s[n]);
                    return { tangents: a, normals: s, binormals: c };
                },
                clone: function () {
                    return new this.constructor().copy(this);
                },
                copy: function (e) {
                    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
                },
                toJSON: function () {
                    var e = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } };
                    return (e.arcLengthDivisions = this.arcLengthDivisions), (e.type = this.type), e;
                },
                fromJSON: function (e) {
                    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
                },
            }),
            (bu.prototype = Object.create(_u.prototype)),
            (bu.prototype.constructor = bu),
            (bu.prototype.isEllipseCurve = !0),
            (bu.prototype.getPoint = function (e, t) {
                for (var n = t || new _n(), i = 2 * Math.PI, r = this.aEndAngle - this.aStartAngle, o = Math.abs(r) < Number.EPSILON; r < 0; ) r += i;
                for (; r > i; ) r -= i;
                r < Number.EPSILON && (r = o ? 0 : i), !0 !== this.aClockwise || o || (r === i ? (r = -i) : (r -= i));
                var a = this.aStartAngle + e * r,
                    s = this.aX + this.xRadius * Math.cos(a),
                    c = this.aY + this.yRadius * Math.sin(a);
                if (0 !== this.aRotation) {
                    var l = Math.cos(this.aRotation),
                        u = Math.sin(this.aRotation),
                        h = s - this.aX,
                        d = c - this.aY;
                    (s = h * l - d * u + this.aX), (c = h * u + d * l + this.aY);
                }
                return n.set(s, c);
            }),
            (bu.prototype.copy = function (e) {
                return (
                    _u.prototype.copy.call(this, e),
                    (this.aX = e.aX),
                    (this.aY = e.aY),
                    (this.xRadius = e.xRadius),
                    (this.yRadius = e.yRadius),
                    (this.aStartAngle = e.aStartAngle),
                    (this.aEndAngle = e.aEndAngle),
                    (this.aClockwise = e.aClockwise),
                    (this.aRotation = e.aRotation),
                    this
                );
            }),
            (bu.prototype.toJSON = function () {
                var e = _u.prototype.toJSON.call(this);
                return (
                    (e.aX = this.aX),
                    (e.aY = this.aY),
                    (e.xRadius = this.xRadius),
                    (e.yRadius = this.yRadius),
                    (e.aStartAngle = this.aStartAngle),
                    (e.aEndAngle = this.aEndAngle),
                    (e.aClockwise = this.aClockwise),
                    (e.aRotation = this.aRotation),
                    e
                );
            }),
            (bu.prototype.fromJSON = function (e) {
                return (
                    _u.prototype.fromJSON.call(this, e),
                    (this.aX = e.aX),
                    (this.aY = e.aY),
                    (this.xRadius = e.xRadius),
                    (this.yRadius = e.yRadius),
                    (this.aStartAngle = e.aStartAngle),
                    (this.aEndAngle = e.aEndAngle),
                    (this.aClockwise = e.aClockwise),
                    (this.aRotation = e.aRotation),
                    this
                );
            }),
            (wu.prototype = Object.create(bu.prototype)),
            (wu.prototype.constructor = wu),
            (wu.prototype.isArcCurve = !0);
        var Su = new Sn(),
            Eu = new Mu(),
            Tu = new Mu(),
            Au = new Mu();
        function Lu(e, t, n, i) {
            _u.call(this), (this.type = "CatmullRomCurve3"), (this.points = e || []), (this.closed = t || !1), (this.curveType = n || "centripetal"), (this.tension = i || 0.5);
        }
        function Cu(e, t, n, i, r) {
            var o = 0.5 * (i - t),
                a = 0.5 * (r - n),
                s = e * e;
            return (2 * n - 2 * i + o + a) * (e * s) + (-3 * n + 3 * i - 2 * o - a) * s + o * e + n;
        }
        function Ru(e, t, n, i) {
            return (
                (function (e, t) {
                    var n = 1 - e;
                    return n * n * t;
                })(e, t) +
                (function (e, t) {
                    return 2 * (1 - e) * e * t;
                })(e, n) +
                (function (e, t) {
                    return e * e * t;
                })(e, i)
            );
        }
        function Pu(e, t, n, i, r) {
            return (
                (function (e, t) {
                    var n = 1 - e;
                    return n * n * n * t;
                })(e, t) +
                (function (e, t) {
                    var n = 1 - e;
                    return 3 * n * n * e * t;
                })(e, n) +
                (function (e, t) {
                    return 3 * (1 - e) * e * e * t;
                })(e, i) +
                (function (e, t) {
                    return e * e * e * t;
                })(e, r)
            );
        }
        function Ou(e, t, n, i) {
            _u.call(this), (this.type = "CubicBezierCurve"), (this.v0 = e || new _n()), (this.v1 = t || new _n()), (this.v2 = n || new _n()), (this.v3 = i || new _n());
        }
        function Du(e, t, n, i) {
            _u.call(this), (this.type = "CubicBezierCurve3"), (this.v0 = e || new Sn()), (this.v1 = t || new Sn()), (this.v2 = n || new Sn()), (this.v3 = i || new Sn());
        }
        function Iu(e, t) {
            _u.call(this), (this.type = "LineCurve"), (this.v1 = e || new _n()), (this.v2 = t || new _n());
        }
        function Nu(e, t) {
            _u.call(this), (this.type = "LineCurve3"), (this.v1 = e || new Sn()), (this.v2 = t || new Sn());
        }
        function Uu(e, t, n) {
            _u.call(this), (this.type = "QuadraticBezierCurve"), (this.v0 = e || new _n()), (this.v1 = t || new _n()), (this.v2 = n || new _n());
        }
        function Bu(e, t, n) {
            _u.call(this), (this.type = "QuadraticBezierCurve3"), (this.v0 = e || new Sn()), (this.v1 = t || new Sn()), (this.v2 = n || new Sn());
        }
        function zu(e) {
            _u.call(this), (this.type = "SplineCurve"), (this.points = e || []);
        }
        (Lu.prototype = Object.create(_u.prototype)),
            (Lu.prototype.constructor = Lu),
            (Lu.prototype.isCatmullRomCurve3 = !0),
            (Lu.prototype.getPoint = function (e, t) {
                var n,
                    i,
                    r,
                    o,
                    a = t || new Sn(),
                    s = this.points,
                    c = s.length,
                    l = (c - (this.closed ? 0 : 1)) * e,
                    u = Math.floor(l),
                    h = l - u;
                if (
                    (this.closed ? (u += u > 0 ? 0 : (Math.floor(Math.abs(u) / c) + 1) * c) : 0 === h && u === c - 1 && ((u = c - 2), (h = 1)),
                    this.closed || u > 0 ? (n = s[(u - 1) % c]) : (Su.subVectors(s[0], s[1]).add(s[0]), (n = Su)),
                    (i = s[u % c]),
                    (r = s[(u + 1) % c]),
                    this.closed || u + 2 < c ? (o = s[(u + 2) % c]) : (Su.subVectors(s[c - 1], s[c - 2]).add(s[c - 1]), (o = Su)),
                    "centripetal" === this.curveType || "chordal" === this.curveType)
                ) {
                    var d = "chordal" === this.curveType ? 0.5 : 0.25,
                        p = Math.pow(n.distanceToSquared(i), d),
                        f = Math.pow(i.distanceToSquared(r), d),
                        m = Math.pow(r.distanceToSquared(o), d);
                    f < 1e-4 && (f = 1),
                        p < 1e-4 && (p = f),
                        m < 1e-4 && (m = f),
                        Eu.initNonuniformCatmullRom(n.x, i.x, r.x, o.x, p, f, m),
                        Tu.initNonuniformCatmullRom(n.y, i.y, r.y, o.y, p, f, m),
                        Au.initNonuniformCatmullRom(n.z, i.z, r.z, o.z, p, f, m);
                } else "catmullrom" === this.curveType && (Eu.initCatmullRom(n.x, i.x, r.x, o.x, this.tension), Tu.initCatmullRom(n.y, i.y, r.y, o.y, this.tension), Au.initCatmullRom(n.z, i.z, r.z, o.z, this.tension));
                return a.set(Eu.calc(h), Tu.calc(h), Au.calc(h)), a;
            }),
            (Lu.prototype.copy = function (e) {
                _u.prototype.copy.call(this, e), (this.points = []);
                for (var t = 0, n = e.points.length; t < n; t++) {
                    var i = e.points[t];
                    this.points.push(i.clone());
                }
                return (this.closed = e.closed), (this.curveType = e.curveType), (this.tension = e.tension), this;
            }),
            (Lu.prototype.toJSON = function () {
                var e = _u.prototype.toJSON.call(this);
                e.points = [];
                for (var t = 0, n = this.points.length; t < n; t++) {
                    var i = this.points[t];
                    e.points.push(i.toArray());
                }
                return (e.closed = this.closed), (e.curveType = this.curveType), (e.tension = this.tension), e;
            }),
            (Lu.prototype.fromJSON = function (e) {
                _u.prototype.fromJSON.call(this, e), (this.points = []);
                for (var t = 0, n = e.points.length; t < n; t++) {
                    var i = e.points[t];
                    this.points.push(new Sn().fromArray(i));
                }
                return (this.closed = e.closed), (this.curveType = e.curveType), (this.tension = e.tension), this;
            }),
            (Ou.prototype = Object.create(_u.prototype)),
            (Ou.prototype.constructor = Ou),
            (Ou.prototype.isCubicBezierCurve = !0),
            (Ou.prototype.getPoint = function (e, t) {
                var n = t || new _n(),
                    i = this.v0,
                    r = this.v1,
                    o = this.v2,
                    a = this.v3;
                return n.set(Pu(e, i.x, r.x, o.x, a.x), Pu(e, i.y, r.y, o.y, a.y)), n;
            }),
            (Ou.prototype.copy = function (e) {
                return _u.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
            }),
            (Ou.prototype.toJSON = function () {
                var e = _u.prototype.toJSON.call(this);
                return (e.v0 = this.v0.toArray()), (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), (e.v3 = this.v3.toArray()), e;
            }),
            (Ou.prototype.fromJSON = function (e) {
                return _u.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
            }),
            (Du.prototype = Object.create(_u.prototype)),
            (Du.prototype.constructor = Du),
            (Du.prototype.isCubicBezierCurve3 = !0),
            (Du.prototype.getPoint = function (e, t) {
                var n = t || new Sn(),
                    i = this.v0,
                    r = this.v1,
                    o = this.v2,
                    a = this.v3;
                return n.set(Pu(e, i.x, r.x, o.x, a.x), Pu(e, i.y, r.y, o.y, a.y), Pu(e, i.z, r.z, o.z, a.z)), n;
            }),
            (Du.prototype.copy = function (e) {
                return _u.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
            }),
            (Du.prototype.toJSON = function () {
                var e = _u.prototype.toJSON.call(this);
                return (e.v0 = this.v0.toArray()), (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), (e.v3 = this.v3.toArray()), e;
            }),
            (Du.prototype.fromJSON = function (e) {
                return _u.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
            }),
            (Iu.prototype = Object.create(_u.prototype)),
            (Iu.prototype.constructor = Iu),
            (Iu.prototype.isLineCurve = !0),
            (Iu.prototype.getPoint = function (e, t) {
                var n = t || new _n();
                return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
            }),
            (Iu.prototype.getPointAt = function (e, t) {
                return this.getPoint(e, t);
            }),
            (Iu.prototype.getTangent = function () {
                return this.v2.clone().sub(this.v1).normalize();
            }),
            (Iu.prototype.copy = function (e) {
                return _u.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
            }),
            (Iu.prototype.toJSON = function () {
                var e = _u.prototype.toJSON.call(this);
                return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
            }),
            (Iu.prototype.fromJSON = function (e) {
                return _u.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
            }),
            (Nu.prototype = Object.create(_u.prototype)),
            (Nu.prototype.constructor = Nu),
            (Nu.prototype.isLineCurve3 = !0),
            (Nu.prototype.getPoint = function (e, t) {
                var n = t || new Sn();
                return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
            }),
            (Nu.prototype.getPointAt = function (e, t) {
                return this.getPoint(e, t);
            }),
            (Nu.prototype.copy = function (e) {
                return _u.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
            }),
            (Nu.prototype.toJSON = function () {
                var e = _u.prototype.toJSON.call(this);
                return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
            }),
            (Nu.prototype.fromJSON = function (e) {
                return _u.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
            }),
            (Uu.prototype = Object.create(_u.prototype)),
            (Uu.prototype.constructor = Uu),
            (Uu.prototype.isQuadraticBezierCurve = !0),
            (Uu.prototype.getPoint = function (e, t) {
                var n = t || new _n(),
                    i = this.v0,
                    r = this.v1,
                    o = this.v2;
                return n.set(Ru(e, i.x, r.x, o.x), Ru(e, i.y, r.y, o.y)), n;
            }),
            (Uu.prototype.copy = function (e) {
                return _u.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
            }),
            (Uu.prototype.toJSON = function () {
                var e = _u.prototype.toJSON.call(this);
                return (e.v0 = this.v0.toArray()), (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
            }),
            (Uu.prototype.fromJSON = function (e) {
                return _u.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
            }),
            (Bu.prototype = Object.create(_u.prototype)),
            (Bu.prototype.constructor = Bu),
            (Bu.prototype.isQuadraticBezierCurve3 = !0),
            (Bu.prototype.getPoint = function (e, t) {
                var n = t || new Sn(),
                    i = this.v0,
                    r = this.v1,
                    o = this.v2;
                return n.set(Ru(e, i.x, r.x, o.x), Ru(e, i.y, r.y, o.y), Ru(e, i.z, r.z, o.z)), n;
            }),
            (Bu.prototype.copy = function (e) {
                return _u.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
            }),
            (Bu.prototype.toJSON = function () {
                var e = _u.prototype.toJSON.call(this);
                return (e.v0 = this.v0.toArray()), (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
            }),
            (Bu.prototype.fromJSON = function (e) {
                return _u.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
            }),
            (zu.prototype = Object.create(_u.prototype)),
            (zu.prototype.constructor = zu),
            (zu.prototype.isSplineCurve = !0),
            (zu.prototype.getPoint = function (e, t) {
                var n = t || new _n(),
                    i = this.points,
                    r = (i.length - 1) * e,
                    o = Math.floor(r),
                    a = r - o,
                    s = i[0 === o ? o : o - 1],
                    c = i[o],
                    l = i[o > i.length - 2 ? i.length - 1 : o + 1],
                    u = i[o > i.length - 3 ? i.length - 1 : o + 2];
                return n.set(Cu(a, s.x, c.x, l.x, u.x), Cu(a, s.y, c.y, l.y, u.y)), n;
            }),
            (zu.prototype.copy = function (e) {
                _u.prototype.copy.call(this, e), (this.points = []);
                for (var t = 0, n = e.points.length; t < n; t++) {
                    var i = e.points[t];
                    this.points.push(i.clone());
                }
                return this;
            }),
            (zu.prototype.toJSON = function () {
                var e = _u.prototype.toJSON.call(this);
                e.points = [];
                for (var t = 0, n = this.points.length; t < n; t++) {
                    var i = this.points[t];
                    e.points.push(i.toArray());
                }
                return e;
            }),
            (zu.prototype.fromJSON = function (e) {
                _u.prototype.fromJSON.call(this, e), (this.points = []);
                for (var t = 0, n = e.points.length; t < n; t++) {
                    var i = e.points[t];
                    this.points.push(new _n().fromArray(i));
                }
                return this;
            });
        var Fu = Object.freeze({
            __proto__: null,
            ArcCurve: wu,
            CatmullRomCurve3: Lu,
            CubicBezierCurve: Ou,
            CubicBezierCurve3: Du,
            EllipseCurve: bu,
            LineCurve: Iu,
            LineCurve3: Nu,
            QuadraticBezierCurve: Uu,
            QuadraticBezierCurve3: Bu,
            SplineCurve: zu,
        });
        function Gu() {
            _u.call(this), (this.type = "CurvePath"), (this.curves = []), (this.autoClose = !1);
        }
        function Hu(e) {
            Gu.call(this), (this.type = "Path"), (this.currentPoint = new _n()), e && this.setFromPoints(e);
        }
        function Vu(e) {
            Hu.call(this, e), (this.uuid = xn.generateUUID()), (this.type = "Shape"), (this.holes = []);
        }
        function ku(e, t) {
            oi.call(this), (this.type = "Light"), (this.color = new Zi(e)), (this.intensity = void 0 !== t ? t : 1), (this.receiveShadow = void 0);
        }
        function ju(e, t, n) {
            ku.call(this, e, n), (this.type = "HemisphereLight"), (this.castShadow = void 0), this.position.copy(oi.DefaultUp), this.updateMatrix(), (this.groundColor = new Zi(t));
        }
        function Wu(e) {
            (this.camera = e),
                (this.bias = 0),
                (this.radius = 1),
                (this.mapSize = new _n(512, 512)),
                (this.map = null),
                (this.mapPass = null),
                (this.matrix = new Hn()),
                (this._frustum = new po()),
                (this._frameExtents = new _n(1, 1)),
                (this._viewportCount = 1),
                (this._viewports = [new Pn(0, 0, 1, 1)]);
        }
        function qu() {
            Wu.call(this, new ro(50, 1, 0.5, 500));
        }
        function Xu(e, t, n, i, r, o) {
            ku.call(this, e, t),
                (this.type = "SpotLight"),
                this.position.copy(oi.DefaultUp),
                this.updateMatrix(),
                (this.target = new oi()),
                Object.defineProperty(this, "power", {
                    get: function () {
                        return this.intensity * Math.PI;
                    },
                    set: function (e) {
                        this.intensity = e / Math.PI;
                    },
                }),
                (this.distance = void 0 !== n ? n : 0),
                (this.angle = void 0 !== i ? i : Math.PI / 3),
                (this.penumbra = void 0 !== r ? r : 0),
                (this.decay = void 0 !== o ? o : 1),
                (this.shadow = new qu());
        }
        function Yu() {
            Wu.call(this, new ro(90, 1, 0.5, 500)),
                (this._frameExtents = new _n(4, 2)),
                (this._viewportCount = 6),
                (this._viewports = [new Pn(2, 1, 1, 1), new Pn(0, 1, 1, 1), new Pn(3, 1, 1, 1), new Pn(1, 1, 1, 1), new Pn(3, 0, 1, 1), new Pn(1, 0, 1, 1)]),
                (this._cubeDirections = [new Sn(1, 0, 0), new Sn(-1, 0, 0), new Sn(0, 0, 1), new Sn(0, 0, -1), new Sn(0, 1, 0), new Sn(0, -1, 0)]),
                (this._cubeUps = [new Sn(0, 1, 0), new Sn(0, 1, 0), new Sn(0, 1, 0), new Sn(0, 1, 0), new Sn(0, 0, 1), new Sn(0, 0, -1)]);
        }
        function Ju(e, t, n, i) {
            ku.call(this, e, t),
                (this.type = "PointLight"),
                Object.defineProperty(this, "power", {
                    get: function () {
                        return 4 * this.intensity * Math.PI;
                    },
                    set: function (e) {
                        this.intensity = e / (4 * Math.PI);
                    },
                }),
                (this.distance = void 0 !== n ? n : 0),
                (this.decay = void 0 !== i ? i : 1),
                (this.shadow = new Yu());
        }
        function Zu(e, t, n, i, r, o) {
            io.call(this),
                (this.type = "OrthographicCamera"),
                (this.zoom = 1),
                (this.view = null),
                (this.left = void 0 !== e ? e : -1),
                (this.right = void 0 !== t ? t : 1),
                (this.top = void 0 !== n ? n : 1),
                (this.bottom = void 0 !== i ? i : -1),
                (this.near = void 0 !== r ? r : 0.1),
                (this.far = void 0 !== o ? o : 2e3),
                this.updateProjectionMatrix();
        }
        function Ku() {
            Wu.call(this, new Zu(-5, 5, 5, -5, 0.5, 500));
        }
        function Qu(e, t) {
            ku.call(this, e, t), (this.type = "DirectionalLight"), this.position.copy(oi.DefaultUp), this.updateMatrix(), (this.target = new oi()), (this.shadow = new Ku());
        }
        function $u(e, t) {
            ku.call(this, e, t), (this.type = "AmbientLight"), (this.castShadow = void 0);
        }
        function eh(e, t, n, i) {
            ku.call(this, e, t), (this.type = "RectAreaLight"), (this.width = void 0 !== n ? n : 10), (this.height = void 0 !== i ? i : 10);
        }
        function th(e) {
            hu.call(this, e), (this.textures = {});
        }
        (Gu.prototype = Object.assign(Object.create(_u.prototype), {
            constructor: Gu,
            add: function (e) {
                this.curves.push(e);
            },
            closePath: function () {
                var e = this.curves[0].getPoint(0),
                    t = this.curves[this.curves.length - 1].getPoint(1);
                e.equals(t) || this.curves.push(new Iu(t, e));
            },
            getPoint: function (e) {
                for (var t = e * this.getLength(), n = this.getCurveLengths(), i = 0; i < n.length; ) {
                    if (n[i] >= t) {
                        var r = n[i] - t,
                            o = this.curves[i],
                            a = o.getLength(),
                            s = 0 === a ? 0 : 1 - r / a;
                        return o.getPointAt(s);
                    }
                    i++;
                }
                return null;
            },
            getLength: function () {
                var e = this.getCurveLengths();
                return e[e.length - 1];
            },
            updateArcLengths: function () {
                (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
            },
            getCurveLengths: function () {
                if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                for (var e = [], t = 0, n = 0, i = this.curves.length; n < i; n++) (t += this.curves[n].getLength()), e.push(t);
                return (this.cacheLengths = e), e;
            },
            getSpacedPoints: function (e) {
                void 0 === e && (e = 40);
                for (var t = [], n = 0; n <= e; n++) t.push(this.getPoint(n / e));
                return this.autoClose && t.push(t[0]), t;
            },
            getPoints: function (e) {
                e = e || 12;
                for (var t, n = [], i = 0, r = this.curves; i < r.length; i++)
                    for (var o = r[i], a = o && o.isEllipseCurve ? 2 * e : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? e * o.points.length : e, s = o.getPoints(a), c = 0; c < s.length; c++) {
                        var l = s[c];
                        (t && t.equals(l)) || (n.push(l), (t = l));
                    }
                return this.autoClose && n.length > 1 && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n;
            },
            copy: function (e) {
                _u.prototype.copy.call(this, e), (this.curves = []);
                for (var t = 0, n = e.curves.length; t < n; t++) {
                    var i = e.curves[t];
                    this.curves.push(i.clone());
                }
                return (this.autoClose = e.autoClose), this;
            },
            toJSON: function () {
                var e = _u.prototype.toJSON.call(this);
                (e.autoClose = this.autoClose), (e.curves = []);
                for (var t = 0, n = this.curves.length; t < n; t++) {
                    var i = this.curves[t];
                    e.curves.push(i.toJSON());
                }
                return e;
            },
            fromJSON: function (e) {
                _u.prototype.fromJSON.call(this, e), (this.autoClose = e.autoClose), (this.curves = []);
                for (var t = 0, n = e.curves.length; t < n; t++) {
                    var i = e.curves[t];
                    this.curves.push(new Fu[i.type]().fromJSON(i));
                }
                return this;
            },
        })),
            (Hu.prototype = Object.assign(Object.create(Gu.prototype), {
                constructor: Hu,
                setFromPoints: function (e) {
                    this.moveTo(e[0].x, e[0].y);
                    for (var t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
                    return this;
                },
                moveTo: function (e, t) {
                    return this.currentPoint.set(e, t), this;
                },
                lineTo: function (e, t) {
                    var n = new Iu(this.currentPoint.clone(), new _n(e, t));
                    return this.curves.push(n), this.currentPoint.set(e, t), this;
                },
                quadraticCurveTo: function (e, t, n, i) {
                    var r = new Uu(this.currentPoint.clone(), new _n(e, t), new _n(n, i));
                    return this.curves.push(r), this.currentPoint.set(n, i), this;
                },
                bezierCurveTo: function (e, t, n, i, r, o) {
                    var a = new Ou(this.currentPoint.clone(), new _n(e, t), new _n(n, i), new _n(r, o));
                    return this.curves.push(a), this.currentPoint.set(r, o), this;
                },
                splineThru: function (e) {
                    var t = new zu([this.currentPoint.clone()].concat(e));
                    return this.curves.push(t), this.currentPoint.copy(e[e.length - 1]), this;
                },
                arc: function (e, t, n, i, r, o) {
                    var a = this.currentPoint.x,
                        s = this.currentPoint.y;
                    return this.absarc(e + a, t + s, n, i, r, o), this;
                },
                absarc: function (e, t, n, i, r, o) {
                    return this.absellipse(e, t, n, n, i, r, o), this;
                },
                ellipse: function (e, t, n, i, r, o, a, s) {
                    var c = this.currentPoint.x,
                        l = this.currentPoint.y;
                    return this.absellipse(e + c, t + l, n, i, r, o, a, s), this;
                },
                absellipse: function (e, t, n, i, r, o, a, s) {
                    var c = new bu(e, t, n, i, r, o, a, s);
                    if (this.curves.length > 0) {
                        var l = c.getPoint(0);
                        l.equals(this.currentPoint) || this.lineTo(l.x, l.y);
                    }
                    this.curves.push(c);
                    var u = c.getPoint(1);
                    return this.currentPoint.copy(u), this;
                },
                copy: function (e) {
                    return Gu.prototype.copy.call(this, e), this.currentPoint.copy(e.currentPoint), this;
                },
                toJSON: function () {
                    var e = Gu.prototype.toJSON.call(this);
                    return (e.currentPoint = this.currentPoint.toArray()), e;
                },
                fromJSON: function (e) {
                    return Gu.prototype.fromJSON.call(this, e), this.currentPoint.fromArray(e.currentPoint), this;
                },
            })),
            (Vu.prototype = Object.assign(Object.create(Hu.prototype), {
                constructor: Vu,
                getPointsHoles: function (e) {
                    for (var t = [], n = 0, i = this.holes.length; n < i; n++) t[n] = this.holes[n].getPoints(e);
                    return t;
                },
                extractPoints: function (e) {
                    return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
                },
                copy: function (e) {
                    Hu.prototype.copy.call(this, e), (this.holes = []);
                    for (var t = 0, n = e.holes.length; t < n; t++) {
                        var i = e.holes[t];
                        this.holes.push(i.clone());
                    }
                    return this;
                },
                toJSON: function () {
                    var e = Hu.prototype.toJSON.call(this);
                    (e.uuid = this.uuid), (e.holes = []);
                    for (var t = 0, n = this.holes.length; t < n; t++) {
                        var i = this.holes[t];
                        e.holes.push(i.toJSON());
                    }
                    return e;
                },
                fromJSON: function (e) {
                    Hu.prototype.fromJSON.call(this, e), (this.uuid = e.uuid), (this.holes = []);
                    for (var t = 0, n = e.holes.length; t < n; t++) {
                        var i = e.holes[t];
                        this.holes.push(new Hu().fromJSON(i));
                    }
                    return this;
                },
            })),
            (ku.prototype = Object.assign(Object.create(oi.prototype), {
                constructor: ku,
                isLight: !0,
                copy: function (e) {
                    return oi.prototype.copy.call(this, e), this.color.copy(e.color), (this.intensity = e.intensity), this;
                },
                toJSON: function (e) {
                    var t = oi.prototype.toJSON.call(this, e);
                    return (
                        (t.object.color = this.color.getHex()),
                        (t.object.intensity = this.intensity),
                        void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()),
                        void 0 !== this.distance && (t.object.distance = this.distance),
                        void 0 !== this.angle && (t.object.angle = this.angle),
                        void 0 !== this.decay && (t.object.decay = this.decay),
                        void 0 !== this.penumbra && (t.object.penumbra = this.penumbra),
                        void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()),
                        t
                    );
                },
            })),
            (ju.prototype = Object.assign(Object.create(ku.prototype), {
                constructor: ju,
                isHemisphereLight: !0,
                copy: function (e) {
                    return ku.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this;
                },
            })),
            Object.assign(Wu.prototype, {
                _projScreenMatrix: new Hn(),
                _lightPositionWorld: new Sn(),
                _lookTarget: new Sn(),
                getViewportCount: function () {
                    return this._viewportCount;
                },
                getFrustum: function () {
                    return this._frustum;
                },
                updateMatrices: function (e) {
                    var t = this.camera,
                        n = this.matrix,
                        i = this._projScreenMatrix,
                        r = this._lookTarget,
                        o = this._lightPositionWorld;
                    o.setFromMatrixPosition(e.matrixWorld),
                        t.position.copy(o),
                        r.setFromMatrixPosition(e.target.matrixWorld),
                        t.lookAt(r),
                        t.updateMatrixWorld(),
                        i.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
                        this._frustum.setFromMatrix(i),
                        n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
                        n.multiply(t.projectionMatrix),
                        n.multiply(t.matrixWorldInverse);
                },
                getViewport: function (e) {
                    return this._viewports[e];
                },
                getFrameExtents: function () {
                    return this._frameExtents;
                },
                copy: function (e) {
                    return (this.camera = e.camera.clone()), (this.bias = e.bias), (this.radius = e.radius), this.mapSize.copy(e.mapSize), this;
                },
                clone: function () {
                    return new this.constructor().copy(this);
                },
                toJSON: function () {
                    var e = {};
                    return (
                        0 !== this.bias && (e.bias = this.bias),
                        1 !== this.radius && (e.radius = this.radius),
                        (512 === this.mapSize.x && 512 === this.mapSize.y) || (e.mapSize = this.mapSize.toArray()),
                        (e.camera = this.camera.toJSON(!1).object),
                        delete e.camera.matrix,
                        e
                    );
                },
            }),
            (qu.prototype = Object.assign(Object.create(Wu.prototype), {
                constructor: qu,
                isSpotLightShadow: !0,
                updateMatrices: function (e) {
                    var t = this.camera,
                        n = 2 * xn.RAD2DEG * e.angle,
                        i = this.mapSize.width / this.mapSize.height,
                        r = e.distance || t.far;
                    (n === t.fov && i === t.aspect && r === t.far) || ((t.fov = n), (t.aspect = i), (t.far = r), t.updateProjectionMatrix()), Wu.prototype.updateMatrices.call(this, e);
                },
            })),
            (Xu.prototype = Object.assign(Object.create(ku.prototype), {
                constructor: Xu,
                isSpotLight: !0,
                copy: function (e) {
                    return (
                        ku.prototype.copy.call(this, e), (this.distance = e.distance), (this.angle = e.angle), (this.penumbra = e.penumbra), (this.decay = e.decay), (this.target = e.target.clone()), (this.shadow = e.shadow.clone()), this
                    );
                },
            })),
            (Yu.prototype = Object.assign(Object.create(Wu.prototype), {
                constructor: Yu,
                isPointLightShadow: !0,
                updateMatrices: function (e, t) {
                    void 0 === t && (t = 0);
                    var n = this.camera,
                        i = this.matrix,
                        r = this._lightPositionWorld,
                        o = this._lookTarget,
                        a = this._projScreenMatrix;
                    r.setFromMatrixPosition(e.matrixWorld),
                        n.position.copy(r),
                        o.copy(n.position),
                        o.add(this._cubeDirections[t]),
                        n.up.copy(this._cubeUps[t]),
                        n.lookAt(o),
                        n.updateMatrixWorld(),
                        i.makeTranslation(-r.x, -r.y, -r.z),
                        a.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
                        this._frustum.setFromMatrix(a);
                },
            })),
            (Ju.prototype = Object.assign(Object.create(ku.prototype), {
                constructor: Ju,
                isPointLight: !0,
                copy: function (e) {
                    return ku.prototype.copy.call(this, e), (this.distance = e.distance), (this.decay = e.decay), (this.shadow = e.shadow.clone()), this;
                },
            })),
            (Zu.prototype = Object.assign(Object.create(io.prototype), {
                constructor: Zu,
                isOrthographicCamera: !0,
                copy: function (e, t) {
                    return (
                        io.prototype.copy.call(this, e, t),
                        (this.left = e.left),
                        (this.right = e.right),
                        (this.top = e.top),
                        (this.bottom = e.bottom),
                        (this.near = e.near),
                        (this.far = e.far),
                        (this.zoom = e.zoom),
                        (this.view = null === e.view ? null : Object.assign({}, e.view)),
                        this
                    );
                },
                setViewOffset: function (e, t, n, i, r, o) {
                    null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }),
                        (this.view.enabled = !0),
                        (this.view.fullWidth = e),
                        (this.view.fullHeight = t),
                        (this.view.offsetX = n),
                        (this.view.offsetY = i),
                        (this.view.width = r),
                        (this.view.height = o),
                        this.updateProjectionMatrix();
                },
                clearViewOffset: function () {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
                },
                updateProjectionMatrix: function () {
                    var e = (this.right - this.left) / (2 * this.zoom),
                        t = (this.top - this.bottom) / (2 * this.zoom),
                        n = (this.right + this.left) / 2,
                        i = (this.top + this.bottom) / 2,
                        r = n - e,
                        o = n + e,
                        a = i + t,
                        s = i - t;
                    if (null !== this.view && this.view.enabled) {
                        var c = this.zoom / (this.view.width / this.view.fullWidth),
                            l = this.zoom / (this.view.height / this.view.fullHeight),
                            u = (this.right - this.left) / this.view.width,
                            h = (this.top - this.bottom) / this.view.height;
                        (o = (r += u * (this.view.offsetX / c)) + u * (this.view.width / c)), (s = (a -= h * (this.view.offsetY / l)) - h * (this.view.height / l));
                    }
                    this.projectionMatrix.makeOrthographic(r, o, a, s, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix);
                },
                toJSON: function (e) {
                    var t = oi.prototype.toJSON.call(this, e);
                    return (
                        (t.object.zoom = this.zoom),
                        (t.object.left = this.left),
                        (t.object.right = this.right),
                        (t.object.top = this.top),
                        (t.object.bottom = this.bottom),
                        (t.object.near = this.near),
                        (t.object.far = this.far),
                        null !== this.view && (t.object.view = Object.assign({}, this.view)),
                        t
                    );
                },
            })),
            (Ku.prototype = Object.assign(Object.create(Wu.prototype), {
                constructor: Ku,
                isDirectionalLightShadow: !0,
                updateMatrices: function (e) {
                    Wu.prototype.updateMatrices.call(this, e);
                },
            })),
            (Qu.prototype = Object.assign(Object.create(ku.prototype), {
                constructor: Qu,
                isDirectionalLight: !0,
                copy: function (e) {
                    return ku.prototype.copy.call(this, e), (this.target = e.target.clone()), (this.shadow = e.shadow.clone()), this;
                },
            })),
            ($u.prototype = Object.assign(Object.create(ku.prototype), { constructor: $u, isAmbientLight: !0 })),
            (eh.prototype = Object.assign(Object.create(ku.prototype), {
                constructor: eh,
                isRectAreaLight: !0,
                copy: function (e) {
                    return ku.prototype.copy.call(this, e), (this.width = e.width), (this.height = e.height), this;
                },
                toJSON: function (e) {
                    var t = ku.prototype.toJSON.call(this, e);
                    return (t.object.width = this.width), (t.object.height = this.height), t;
                },
            })),
            (th.prototype = Object.assign(Object.create(hu.prototype), {
                constructor: th,
                load: function (e, t, n, i) {
                    var r = this,
                        o = new pu(r.manager);
                    o.setPath(r.path),
                        o.load(
                            e,
                            function (e) {
                                t(r.parse(JSON.parse(e)));
                            },
                            n,
                            i
                        );
                },
                parse: function (e) {
                    var t = this.textures;
                    function n(e) {
                        return void 0 === t[e] && console.warn("THREE.MaterialLoader: Undefined texture", e), t[e];
                    }
                    var i = new ql[e.type]();
                    if (
                        (void 0 !== e.uuid && (i.uuid = e.uuid),
                        void 0 !== e.name && (i.name = e.name),
                        void 0 !== e.color && i.color.setHex(e.color),
                        void 0 !== e.roughness && (i.roughness = e.roughness),
                        void 0 !== e.metalness && (i.metalness = e.metalness),
                        void 0 !== e.sheen && (i.sheen = new Zi().setHex(e.sheen)),
                        void 0 !== e.emissive && i.emissive.setHex(e.emissive),
                        void 0 !== e.specular && i.specular.setHex(e.specular),
                        void 0 !== e.shininess && (i.shininess = e.shininess),
                        void 0 !== e.clearcoat && (i.clearcoat = e.clearcoat),
                        void 0 !== e.clearcoatRoughness && (i.clearcoatRoughness = e.clearcoatRoughness),
                        void 0 !== e.vertexColors && (i.vertexColors = e.vertexColors),
                        void 0 !== e.fog && (i.fog = e.fog),
                        void 0 !== e.flatShading && (i.flatShading = e.flatShading),
                        void 0 !== e.blending && (i.blending = e.blending),
                        void 0 !== e.combine && (i.combine = e.combine),
                        void 0 !== e.side && (i.side = e.side),
                        void 0 !== e.opacity && (i.opacity = e.opacity),
                        void 0 !== e.transparent && (i.transparent = e.transparent),
                        void 0 !== e.alphaTest && (i.alphaTest = e.alphaTest),
                        void 0 !== e.depthTest && (i.depthTest = e.depthTest),
                        void 0 !== e.depthWrite && (i.depthWrite = e.depthWrite),
                        void 0 !== e.colorWrite && (i.colorWrite = e.colorWrite),
                        void 0 !== e.stencilWrite && (i.stencilWrite = e.stencilWrite),
                        void 0 !== e.stencilWriteMask && (i.stencilWriteMask = e.stencilWriteMask),
                        void 0 !== e.stencilFunc && (i.stencilFunc = e.stencilFunc),
                        void 0 !== e.stencilRef && (i.stencilRef = e.stencilRef),
                        void 0 !== e.stencilFuncMask && (i.stencilFuncMask = e.stencilFuncMask),
                        void 0 !== e.stencilFail && (i.stencilFail = e.stencilFail),
                        void 0 !== e.stencilZFail && (i.stencilZFail = e.stencilZFail),
                        void 0 !== e.stencilZPass && (i.stencilZPass = e.stencilZPass),
                        void 0 !== e.wireframe && (i.wireframe = e.wireframe),
                        void 0 !== e.wireframeLinewidth && (i.wireframeLinewidth = e.wireframeLinewidth),
                        void 0 !== e.wireframeLinecap && (i.wireframeLinecap = e.wireframeLinecap),
                        void 0 !== e.wireframeLinejoin && (i.wireframeLinejoin = e.wireframeLinejoin),
                        void 0 !== e.rotation && (i.rotation = e.rotation),
                        1 !== e.linewidth && (i.linewidth = e.linewidth),
                        void 0 !== e.dashSize && (i.dashSize = e.dashSize),
                        void 0 !== e.gapSize && (i.gapSize = e.gapSize),
                        void 0 !== e.scale && (i.scale = e.scale),
                        void 0 !== e.polygonOffset && (i.polygonOffset = e.polygonOffset),
                        void 0 !== e.polygonOffsetFactor && (i.polygonOffsetFactor = e.polygonOffsetFactor),
                        void 0 !== e.polygonOffsetUnits && (i.polygonOffsetUnits = e.polygonOffsetUnits),
                        void 0 !== e.skinning && (i.skinning = e.skinning),
                        void 0 !== e.morphTargets && (i.morphTargets = e.morphTargets),
                        void 0 !== e.morphNormals && (i.morphNormals = e.morphNormals),
                        void 0 !== e.dithering && (i.dithering = e.dithering),
                        void 0 !== e.visible && (i.visible = e.visible),
                        void 0 !== e.toneMapped && (i.toneMapped = e.toneMapped),
                        void 0 !== e.userData && (i.userData = e.userData),
                        void 0 !== e.uniforms)
                    )
                        for (var r in e.uniforms) {
                            var o = e.uniforms[r];
                            switch (((i.uniforms[r] = {}), o.type)) {
                                case "t":
                                    i.uniforms[r].value = n(o.value);
                                    break;
                                case "c":
                                    i.uniforms[r].value = new Zi().setHex(o.value);
                                    break;
                                case "v2":
                                    i.uniforms[r].value = new _n().fromArray(o.value);
                                    break;
                                case "v3":
                                    i.uniforms[r].value = new Sn().fromArray(o.value);
                                    break;
                                case "v4":
                                    i.uniforms[r].value = new Pn().fromArray(o.value);
                                    break;
                                case "m3":
                                    i.uniforms[r].value = new An().fromArray(o.value);
                                case "m4":
                                    i.uniforms[r].value = new Hn().fromArray(o.value);
                                    break;
                                default:
                                    i.uniforms[r].value = o.value;
                            }
                        }
                    if ((void 0 !== e.defines && (i.defines = e.defines), void 0 !== e.vertexShader && (i.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (i.fragmentShader = e.fragmentShader), void 0 !== e.extensions))
                        for (var a in e.extensions) i.extensions[a] = e.extensions[a];
                    if (
                        (void 0 !== e.shading && (i.flatShading = 1 === e.shading),
                        void 0 !== e.size && (i.size = e.size),
                        void 0 !== e.sizeAttenuation && (i.sizeAttenuation = e.sizeAttenuation),
                        void 0 !== e.map && (i.map = n(e.map)),
                        void 0 !== e.matcap && (i.matcap = n(e.matcap)),
                        void 0 !== e.alphaMap && ((i.alphaMap = n(e.alphaMap)), (i.transparent = !0)),
                        void 0 !== e.bumpMap && (i.bumpMap = n(e.bumpMap)),
                        void 0 !== e.bumpScale && (i.bumpScale = e.bumpScale),
                        void 0 !== e.normalMap && (i.normalMap = n(e.normalMap)),
                        void 0 !== e.normalMapType && (i.normalMapType = e.normalMapType),
                        void 0 !== e.normalScale)
                    ) {
                        var s = e.normalScale;
                        !1 === Array.isArray(s) && (s = [s, s]), (i.normalScale = new _n().fromArray(s));
                    }
                    return (
                        void 0 !== e.displacementMap && (i.displacementMap = n(e.displacementMap)),
                        void 0 !== e.displacementScale && (i.displacementScale = e.displacementScale),
                        void 0 !== e.displacementBias && (i.displacementBias = e.displacementBias),
                        void 0 !== e.roughnessMap && (i.roughnessMap = n(e.roughnessMap)),
                        void 0 !== e.metalnessMap && (i.metalnessMap = n(e.metalnessMap)),
                        void 0 !== e.emissiveMap && (i.emissiveMap = n(e.emissiveMap)),
                        void 0 !== e.emissiveIntensity && (i.emissiveIntensity = e.emissiveIntensity),
                        void 0 !== e.specularMap && (i.specularMap = n(e.specularMap)),
                        void 0 !== e.envMap && (i.envMap = n(e.envMap)),
                        void 0 !== e.envMapIntensity && (i.envMapIntensity = e.envMapIntensity),
                        void 0 !== e.reflectivity && (i.reflectivity = e.reflectivity),
                        void 0 !== e.refractionRatio && (i.refractionRatio = e.refractionRatio),
                        void 0 !== e.lightMap && (i.lightMap = n(e.lightMap)),
                        void 0 !== e.lightMapIntensity && (i.lightMapIntensity = e.lightMapIntensity),
                        void 0 !== e.aoMap && (i.aoMap = n(e.aoMap)),
                        void 0 !== e.aoMapIntensity && (i.aoMapIntensity = e.aoMapIntensity),
                        void 0 !== e.gradientMap && (i.gradientMap = n(e.gradientMap)),
                        void 0 !== e.clearcoatNormalMap && (i.clearcoatNormalMap = n(e.clearcoatNormalMap)),
                        void 0 !== e.clearcoatNormalScale && (i.clearcoatNormalScale = new _n().fromArray(e.clearcoatNormalScale)),
                        i
                    );
                },
                setTextures: function (e) {
                    return (this.textures = e), this;
                },
            }));
        var nh = {
            decodeText: function (e) {
                if ("undefined" != typeof TextDecoder) return new TextDecoder().decode(e);
                for (var t = "", n = 0, i = e.length; n < i; n++) t += String.fromCharCode(e[n]);
                try {
                    return decodeURIComponent(escape(t));
                } catch (e) {
                    return t;
                }
            },
            extractUrlBase: function (e) {
                var t = e.lastIndexOf("/");
                return -1 === t ? "./" : e.substr(0, t + 1);
            },
        };
        function ih() {
            Mr.call(this), (this.type = "InstancedBufferGeometry"), (this.maxInstancedCount = void 0);
        }
        function rh(e, t, n, i) {
            "number" == typeof n && ((i = n), (n = !1), console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), rr.call(this, e, t, n), (this.meshPerAttribute = i || 1);
        }
        function oh(e) {
            hu.call(this, e);
        }
        (ih.prototype = Object.assign(Object.create(Mr.prototype), {
            constructor: ih,
            isInstancedBufferGeometry: !0,
            copy: function (e) {
                return Mr.prototype.copy.call(this, e), (this.maxInstancedCount = e.maxInstancedCount), this;
            },
            clone: function () {
                return new this.constructor().copy(this);
            },
            toJSON: function () {
                var e = Mr.prototype.toJSON.call(this);
                return (e.maxInstancedCount = this.maxInstancedCount), (e.isInstancedBufferGeometry = !0), e;
            },
        })),
            (rh.prototype = Object.assign(Object.create(rr.prototype), {
                constructor: rh,
                isInstancedBufferAttribute: !0,
                copy: function (e) {
                    return rr.prototype.copy.call(this, e), (this.meshPerAttribute = e.meshPerAttribute), this;
                },
                toJSON: function () {
                    var e = rr.prototype.toJSON.call(this);
                    return (e.meshPerAttribute = this.meshPerAttribute), (e.isInstancedBufferAttribute = !0), e;
                },
            })),
            (oh.prototype = Object.assign(Object.create(hu.prototype), {
                constructor: oh,
                load: function (e, t, n, i) {
                    var r = this,
                        o = new pu(r.manager);
                    o.setPath(r.path),
                        o.load(
                            e,
                            function (e) {
                                t(r.parse(JSON.parse(e)));
                            },
                            n,
                            i
                        );
                },
                parse: function (e) {
                    var t = e.isInstancedBufferGeometry ? new ih() : new Mr(),
                        n = e.data.index;
                    if (void 0 !== n) {
                        var i = new ah[n.type](n.array);
                        t.setIndex(new rr(i, 1));
                    }
                    var r = e.data.attributes;
                    for (var o in r) {
                        var a = r[o],
                            s = ((i = new ah[a.type](a.array)), new (a.isInstancedBufferAttribute ? rh : rr)(i, a.itemSize, a.normalized));
                        void 0 !== a.name && (s.name = a.name), t.setAttribute(o, s);
                    }
                    var c = e.data.morphAttributes;
                    if (c)
                        for (var o in c) {
                            for (var l = c[o], u = [], h = 0, d = l.length; h < d; h++) {
                                (a = l[h]), (s = new rr((i = new ah[a.type](a.array)), a.itemSize, a.normalized));
                                void 0 !== a.name && (s.name = a.name), u.push(s);
                            }
                            t.morphAttributes[o] = u;
                        }
                    e.data.morphTargetsRelative && (t.morphTargetsRelative = !0);
                    var p = e.data.groups || e.data.drawcalls || e.data.offsets;
                    if (void 0 !== p) {
                        h = 0;
                        for (var f = p.length; h !== f; ++h) {
                            var m = p[h];
                            t.addGroup(m.start, m.count, m.materialIndex);
                        }
                    }
                    var v = e.data.boundingSphere;
                    if (void 0 !== v) {
                        var g = new Sn();
                        void 0 !== v.center && g.fromArray(v.center), (t.boundingSphere = new Mi(g, v.radius));
                    }
                    return e.name && (t.name = e.name), e.userData && (t.userData = e.userData), t;
                },
            }));
        var ah = {
            Int8Array: Int8Array,
            Uint8Array: Uint8Array,
            Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
            Int16Array: Int16Array,
            Uint16Array: Uint16Array,
            Int32Array: Int32Array,
            Uint32Array: Uint32Array,
            Float32Array: Float32Array,
            Float64Array: Float64Array,
        };
        function sh(e) {
            hu.call(this, e);
        }
        sh.prototype = Object.assign(Object.create(hu.prototype), {
            constructor: sh,
            load: function (e, t, n, i) {
                var r = this,
                    o = "" === this.path ? nh.extractUrlBase(e) : this.path;
                this.resourcePath = this.resourcePath || o;
                var a = new pu(r.manager);
                a.setPath(this.path),
                    a.load(
                        e,
                        function (n) {
                            var o = null;
                            try {
                                o = JSON.parse(n);
                            } catch (t) {
                                return void 0 !== i && i(t), void console.error("THREE:ObjectLoader: Can't parse " + e + ".", t.message);
                            }
                            var a = o.metadata;
                            void 0 !== a && void 0 !== a.type && "geometry" !== a.type.toLowerCase() ? r.parse(o, t) : console.error("THREE.ObjectLoader: Can't load " + e);
                        },
                        n,
                        i
                    );
            },
            parse: function (e, t) {
                var n = this.parseShape(e.shapes),
                    i = this.parseGeometries(e.geometries, n),
                    r = this.parseImages(e.images, function () {
                        void 0 !== t && t(s);
                    }),
                    o = this.parseTextures(e.textures, r),
                    a = this.parseMaterials(e.materials, o),
                    s = this.parseObject(e.object, i, a);
                return e.animations && (s.animations = this.parseAnimations(e.animations)), (void 0 !== e.images && 0 !== e.images.length) || (void 0 !== t && t(s)), s;
            },
            parseShape: function (e) {
                var t = {};
                if (void 0 !== e)
                    for (var n = 0, i = e.length; n < i; n++) {
                        var r = new Vu().fromJSON(e[n]);
                        t[r.uuid] = r;
                    }
                return t;
            },
            parseGeometries: function (e, t) {
                var n = {};
                if (void 0 !== e)
                    for (var i = new oh(), r = 0, o = e.length; r < o; r++) {
                        var a,
                            s = e[r];
                        switch (s.type) {
                            case "PlaneGeometry":
                            case "PlaneBufferGeometry":
                                a = new Nl[s.type](s.width, s.height, s.widthSegments, s.heightSegments);
                                break;
                            case "BoxGeometry":
                            case "BoxBufferGeometry":
                            case "CubeGeometry":
                                a = new Nl[s.type](s.width, s.height, s.depth, s.widthSegments, s.heightSegments, s.depthSegments);
                                break;
                            case "CircleGeometry":
                            case "CircleBufferGeometry":
                                a = new Nl[s.type](s.radius, s.segments, s.thetaStart, s.thetaLength);
                                break;
                            case "CylinderGeometry":
                            case "CylinderBufferGeometry":
                                a = new Nl[s.type](s.radiusTop, s.radiusBottom, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
                                break;
                            case "ConeGeometry":
                            case "ConeBufferGeometry":
                                a = new Nl[s.type](s.radius, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
                                break;
                            case "SphereGeometry":
                            case "SphereBufferGeometry":
                                a = new Nl[s.type](s.radius, s.widthSegments, s.heightSegments, s.phiStart, s.phiLength, s.thetaStart, s.thetaLength);
                                break;
                            case "DodecahedronGeometry":
                            case "DodecahedronBufferGeometry":
                            case "IcosahedronGeometry":
                            case "IcosahedronBufferGeometry":
                            case "OctahedronGeometry":
                            case "OctahedronBufferGeometry":
                            case "TetrahedronGeometry":
                            case "TetrahedronBufferGeometry":
                                a = new Nl[s.type](s.radius, s.detail);
                                break;
                            case "RingGeometry":
                            case "RingBufferGeometry":
                                a = new Nl[s.type](s.innerRadius, s.outerRadius, s.thetaSegments, s.phiSegments, s.thetaStart, s.thetaLength);
                                break;
                            case "TorusGeometry":
                            case "TorusBufferGeometry":
                                a = new Nl[s.type](s.radius, s.tube, s.radialSegments, s.tubularSegments, s.arc);
                                break;
                            case "TorusKnotGeometry":
                            case "TorusKnotBufferGeometry":
                                a = new Nl[s.type](s.radius, s.tube, s.tubularSegments, s.radialSegments, s.p, s.q);
                                break;
                            case "TubeGeometry":
                            case "TubeBufferGeometry":
                                a = new Nl[s.type](new Fu[s.path.type]().fromJSON(s.path), s.tubularSegments, s.radius, s.radialSegments, s.closed);
                                break;
                            case "LatheGeometry":
                            case "LatheBufferGeometry":
                                a = new Nl[s.type](s.points, s.segments, s.phiStart, s.phiLength);
                                break;
                            case "PolyhedronGeometry":
                            case "PolyhedronBufferGeometry":
                                a = new Nl[s.type](s.vertices, s.indices, s.radius, s.details);
                                break;
                            case "ShapeGeometry":
                            case "ShapeBufferGeometry":
                                for (var c = [], l = 0, u = s.shapes.length; l < u; l++) {
                                    var h = t[s.shapes[l]];
                                    c.push(h);
                                }
                                a = new Nl[s.type](c, s.curveSegments);
                                break;
                            case "ExtrudeGeometry":
                            case "ExtrudeBufferGeometry":
                                for (c = [], l = 0, u = s.shapes.length; l < u; l++) {
                                    h = t[s.shapes[l]];
                                    c.push(h);
                                }
                                var d = s.options.extrudePath;
                                void 0 !== d && (s.options.extrudePath = new Fu[d.type]().fromJSON(d)), (a = new Nl[s.type](c, s.options));
                                break;
                            case "BufferGeometry":
                            case "InstancedBufferGeometry":
                                a = i.parse(s);
                                break;
                            case "Geometry":
                                if ("THREE" in window && "LegacyJSONLoader" in THREE) a = new THREE.LegacyJSONLoader().parse(s, this.resourcePath).geometry;
                                else console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
                                break;
                            default:
                                console.warn('THREE.ObjectLoader: Unsupported geometry type "' + s.type + '"');
                                continue;
                        }
                        (a.uuid = s.uuid), void 0 !== s.name && (a.name = s.name), !0 === a.isBufferGeometry && void 0 !== s.userData && (a.userData = s.userData), (n[s.uuid] = a);
                    }
                return n;
            },
            parseMaterials: function (e, t) {
                var n = {},
                    i = {};
                if (void 0 !== e) {
                    var r = new th();
                    r.setTextures(t);
                    for (var o = 0, a = e.length; o < a; o++) {
                        var s = e[o];
                        if ("MultiMaterial" === s.type) {
                            for (var c = [], l = 0; l < s.materials.length; l++) {
                                var u = s.materials[l];
                                void 0 === n[u.uuid] && (n[u.uuid] = r.parse(u)), c.push(n[u.uuid]);
                            }
                            i[s.uuid] = c;
                        } else void 0 === n[s.uuid] && (n[s.uuid] = r.parse(s)), (i[s.uuid] = n[s.uuid]);
                    }
                }
                return i;
            },
            parseAnimations: function (e) {
                for (var t = [], n = 0; n < e.length; n++) {
                    var i = e[n],
                        r = au.parse(i);
                    void 0 !== i.uuid && (r.uuid = i.uuid), t.push(r);
                }
                return t;
            },
            parseImages: function (e, t) {
                var n = this,
                    i = {};
                function r(e) {
                    return (
                        n.manager.itemStart(e),
                        o.load(
                            e,
                            function () {
                                n.manager.itemEnd(e);
                            },
                            void 0,
                            function () {
                                n.manager.itemError(e), n.manager.itemEnd(e);
                            }
                        )
                    );
                }
                if (void 0 !== e && e.length > 0) {
                    var o = new gu(new lu(t));
                    o.setCrossOrigin(this.crossOrigin);
                    for (var a = 0, s = e.length; a < s; a++) {
                        var c = e[a],
                            l = c.url;
                        if (Array.isArray(l)) {
                            i[c.uuid] = [];
                            for (var u = 0, h = l.length; u < h; u++) {
                                var d = l[u],
                                    p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(d) ? d : n.resourcePath + d;
                                i[c.uuid].push(r(p));
                            }
                        } else {
                            p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c.url) ? c.url : n.resourcePath + c.url;
                            i[c.uuid] = r(p);
                        }
                    }
                }
                return i;
            },
            parseTextures: function (e, t) {
                function n(e, t) {
                    return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e), t[e]);
                }
                var i = {};
                if (void 0 !== e)
                    for (var r = 0, o = e.length; r < o; r++) {
                        var a,
                            s = e[r];
                        void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid),
                            void 0 === t[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image),
                            ((a = Array.isArray(t[s.image]) ? new Oo(t[s.image]) : new Rn(t[s.image])).needsUpdate = !0),
                            (a.uuid = s.uuid),
                            void 0 !== s.name && (a.name = s.name),
                            void 0 !== s.mapping && (a.mapping = n(s.mapping, lh)),
                            void 0 !== s.offset && a.offset.fromArray(s.offset),
                            void 0 !== s.repeat && a.repeat.fromArray(s.repeat),
                            void 0 !== s.center && a.center.fromArray(s.center),
                            void 0 !== s.rotation && (a.rotation = s.rotation),
                            void 0 !== s.wrap && ((a.wrapS = n(s.wrap[0], uh)), (a.wrapT = n(s.wrap[1], uh))),
                            void 0 !== s.format && (a.format = s.format),
                            void 0 !== s.type && (a.type = s.type),
                            void 0 !== s.encoding && (a.encoding = s.encoding),
                            void 0 !== s.minFilter && (a.minFilter = n(s.minFilter, hh)),
                            void 0 !== s.magFilter && (a.magFilter = n(s.magFilter, hh)),
                            void 0 !== s.anisotropy && (a.anisotropy = s.anisotropy),
                            void 0 !== s.flipY && (a.flipY = s.flipY),
                            void 0 !== s.premultiplyAlpha && (a.premultiplyAlpha = s.premultiplyAlpha),
                            void 0 !== s.unpackAlignment && (a.unpackAlignment = s.unpackAlignment),
                            (i[s.uuid] = a);
                    }
                return i;
            },
            parseObject: function (e, t, n) {
                var i;
                function r(e) {
                    return void 0 === t[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e), t[e];
                }
                function o(e) {
                    if (void 0 !== e) {
                        if (Array.isArray(e)) {
                            for (var t = [], i = 0, r = e.length; i < r; i++) {
                                var o = e[i];
                                void 0 === n[o] && console.warn("THREE.ObjectLoader: Undefined material", o), t.push(n[o]);
                            }
                            return t;
                        }
                        return void 0 === n[e] && console.warn("THREE.ObjectLoader: Undefined material", e), n[e];
                    }
                }
                switch (e.type) {
                    case "Scene":
                        (i = new ai()),
                            void 0 !== e.background && Number.isInteger(e.background) && (i.background = new Zi(e.background)),
                            void 0 !== e.fog && ("Fog" === e.fog.type ? (i.fog = new Ss(e.fog.color, e.fog.near, e.fog.far)) : "FogExp2" === e.fog.type && (i.fog = new Ms(e.fog.color, e.fog.density)));
                        break;
                    case "PerspectiveCamera":
                        (i = new ro(e.fov, e.aspect, e.near, e.far)),
                            void 0 !== e.focus && (i.focus = e.focus),
                            void 0 !== e.zoom && (i.zoom = e.zoom),
                            void 0 !== e.filmGauge && (i.filmGauge = e.filmGauge),
                            void 0 !== e.filmOffset && (i.filmOffset = e.filmOffset),
                            void 0 !== e.view && (i.view = Object.assign({}, e.view));
                        break;
                    case "OrthographicCamera":
                        (i = new Zu(e.left, e.right, e.top, e.bottom, e.near, e.far)), void 0 !== e.zoom && (i.zoom = e.zoom), void 0 !== e.view && (i.view = Object.assign({}, e.view));
                        break;
                    case "AmbientLight":
                        i = new $u(e.color, e.intensity);
                        break;
                    case "DirectionalLight":
                        i = new Qu(e.color, e.intensity);
                        break;
                    case "PointLight":
                        i = new Ju(e.color, e.intensity, e.distance, e.decay);
                        break;
                    case "RectAreaLight":
                        i = new eh(e.color, e.intensity, e.width, e.height);
                        break;
                    case "SpotLight":
                        i = new Xu(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
                        break;
                    case "HemisphereLight":
                        i = new ju(e.color, e.groundColor, e.intensity);
                        break;
                    case "SkinnedMesh":
                        console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                    case "Mesh":
                        var a = r(e.geometry),
                            s = o(e.material);
                        i = a.bones && a.bones.length > 0 ? new Ws(a, s) : new Hr(a, s);
                        break;
                    case "InstancedMesh":
                        (a = r(e.geometry)), (s = o(e.material));
                        var c = e.count,
                            l = e.instanceMatrix;
                        (i = new ec(a, s, c)).instanceMatrix = new rr(new Float32Array(l.array), 16);
                        break;
                    case "LOD":
                        i = new js();
                        break;
                    case "Line":
                        i = new sc(r(e.geometry), o(e.material), e.mode);
                        break;
                    case "LineLoop":
                        i = new hc(r(e.geometry), o(e.material));
                        break;
                    case "LineSegments":
                        i = new uc(r(e.geometry), o(e.material));
                        break;
                    case "PointCloud":
                    case "Points":
                        i = new gc(r(e.geometry), o(e.material));
                        break;
                    case "Sprite":
                        i = new Gs(o(e.material));
                        break;
                    case "Group":
                        i = new fs();
                        break;
                    default:
                        i = new oi();
                }
                if (
                    ((i.uuid = e.uuid),
                    void 0 !== e.name && (i.name = e.name),
                    void 0 !== e.matrix
                        ? (i.matrix.fromArray(e.matrix), void 0 !== e.matrixAutoUpdate && (i.matrixAutoUpdate = e.matrixAutoUpdate), i.matrixAutoUpdate && i.matrix.decompose(i.position, i.quaternion, i.scale))
                        : (void 0 !== e.position && i.position.fromArray(e.position),
                          void 0 !== e.rotation && i.rotation.fromArray(e.rotation),
                          void 0 !== e.quaternion && i.quaternion.fromArray(e.quaternion),
                          void 0 !== e.scale && i.scale.fromArray(e.scale)),
                    void 0 !== e.castShadow && (i.castShadow = e.castShadow),
                    void 0 !== e.receiveShadow && (i.receiveShadow = e.receiveShadow),
                    e.shadow &&
                        (void 0 !== e.shadow.bias && (i.shadow.bias = e.shadow.bias),
                        void 0 !== e.shadow.radius && (i.shadow.radius = e.shadow.radius),
                        void 0 !== e.shadow.mapSize && i.shadow.mapSize.fromArray(e.shadow.mapSize),
                        void 0 !== e.shadow.camera && (i.shadow.camera = this.parseObject(e.shadow.camera))),
                    void 0 !== e.visible && (i.visible = e.visible),
                    void 0 !== e.frustumCulled && (i.frustumCulled = e.frustumCulled),
                    void 0 !== e.renderOrder && (i.renderOrder = e.renderOrder),
                    void 0 !== e.userData && (i.userData = e.userData),
                    void 0 !== e.layers && (i.layers.mask = e.layers),
                    void 0 !== e.drawMode && i.setDrawMode(e.drawMode),
                    void 0 !== e.children)
                )
                    for (var u = e.children, h = 0; h < u.length; h++) i.add(this.parseObject(u[h], t, n));
                if ("LOD" === e.type) {
                    void 0 !== e.autoUpdate && (i.autoUpdate = e.autoUpdate);
                    for (var d = e.levels, p = 0; p < d.length; p++) {
                        var f = d[p],
                            m = i.getObjectByProperty("uuid", f.object);
                        void 0 !== m && i.addLevel(m, f.distance);
                    }
                }
                return i;
            },
        });
        var ch,
            lh = {
                UVMapping: le,
                CubeReflectionMapping: ue,
                CubeRefractionMapping: he,
                EquirectangularReflectionMapping: de,
                EquirectangularRefractionMapping: pe,
                SphericalReflectionMapping: fe,
                CubeUVReflectionMapping: me,
                CubeUVRefractionMapping: ve,
            },
            uh = { RepeatWrapping: ge, ClampToEdgeWrapping: ye, MirroredRepeatWrapping: xe },
            hh = { NearestFilter: _e, NearestMipmapNearestFilter: be, NearestMipmapLinearFilter: Me, LinearFilter: Ee, LinearMipmapNearestFilter: Te, LinearMipmapLinearFilter: Le };
        function dh(e) {
            "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
                "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
                hu.call(this, e),
                (this.options = void 0);
        }
        function ph() {
            (this.type = "ShapePath"), (this.color = new Zi()), (this.subPaths = []), (this.currentPath = null);
        }
        function fh(e) {
            (this.type = "Font"), (this.data = e);
        }
        function mh(e, t, n, i, r) {
            var o = r.glyphs[e] || r.glyphs["?"];
            if (o) {
                var a,
                    s,
                    c,
                    l,
                    u,
                    h,
                    d,
                    p,
                    f = new ph();
                if (o.o)
                    for (var m = o._cachedOutline || (o._cachedOutline = o.o.split(" ")), v = 0, g = m.length; v < g; ) {
                        switch (m[v++]) {
                            case "m":
                                (a = m[v++] * t + n), (s = m[v++] * t + i), f.moveTo(a, s);
                                break;
                            case "l":
                                (a = m[v++] * t + n), (s = m[v++] * t + i), f.lineTo(a, s);
                                break;
                            case "q":
                                (c = m[v++] * t + n), (l = m[v++] * t + i), (u = m[v++] * t + n), (h = m[v++] * t + i), f.quadraticCurveTo(u, h, c, l);
                                break;
                            case "b":
                                (c = m[v++] * t + n), (l = m[v++] * t + i), (u = m[v++] * t + n), (h = m[v++] * t + i), (d = m[v++] * t + n), (p = m[v++] * t + i), f.bezierCurveTo(u, h, d, p, c, l);
                        }
                    }
                return { offsetX: o.ha * t, path: f };
            }
            console.error('THREE.Font: character "' + e + '" does not exists in font family ' + r.familyName + ".");
        }
        function vh(e) {
            hu.call(this, e);
        }
        (dh.prototype = Object.assign(Object.create(hu.prototype), {
            constructor: dh,
            setOptions: function (e) {
                return (this.options = e), this;
            },
            load: function (e, t, n, i) {
                void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), (e = this.manager.resolveURL(e));
                var r = this,
                    o = cu.get(e);
                if (void 0 !== o)
                    return (
                        r.manager.itemStart(e),
                        setTimeout(function () {
                            t && t(o), r.manager.itemEnd(e);
                        }, 0),
                        o
                    );
                fetch(e)
                    .then(function (e) {
                        return e.blob();
                    })
                    .then(function (e) {
                        return void 0 === r.options ? createImageBitmap(e) : createImageBitmap(e, r.options);
                    })
                    .then(function (n) {
                        cu.add(e, n), t && t(n), r.manager.itemEnd(e);
                    })
                    .catch(function (t) {
                        i && i(t), r.manager.itemError(e), r.manager.itemEnd(e);
                    }),
                    r.manager.itemStart(e);
            },
        })),
            Object.assign(ph.prototype, {
                moveTo: function (e, t) {
                    return (this.currentPath = new Hu()), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
                },
                lineTo: function (e, t) {
                    return this.currentPath.lineTo(e, t), this;
                },
                quadraticCurveTo: function (e, t, n, i) {
                    return this.currentPath.quadraticCurveTo(e, t, n, i), this;
                },
                bezierCurveTo: function (e, t, n, i, r, o) {
                    return this.currentPath.bezierCurveTo(e, t, n, i, r, o), this;
                },
                splineThru: function (e) {
                    return this.currentPath.splineThru(e), this;
                },
                toShapes: function (e, t) {
                    function n(e) {
                        for (var t = [], n = 0, i = e.length; n < i; n++) {
                            var r = e[n],
                                o = new Vu();
                            (o.curves = r.curves), t.push(o);
                        }
                        return t;
                    }
                    function i(e, t) {
                        for (var n = t.length, i = !1, r = n - 1, o = 0; o < n; r = o++) {
                            var a = t[r],
                                s = t[o],
                                c = s.x - a.x,
                                l = s.y - a.y;
                            if (Math.abs(l) > Number.EPSILON) {
                                if ((l < 0 && ((a = t[o]), (c = -c), (s = t[r]), (l = -l)), e.y < a.y || e.y > s.y)) continue;
                                if (e.y === a.y) {
                                    if (e.x === a.x) return !0;
                                } else {
                                    var u = l * (e.x - a.x) - c * (e.y - a.y);
                                    if (0 === u) return !0;
                                    if (u < 0) continue;
                                    i = !i;
                                }
                            } else {
                                if (e.y !== a.y) continue;
                                if ((s.x <= e.x && e.x <= a.x) || (a.x <= e.x && e.x <= s.x)) return !0;
                            }
                        }
                        return i;
                    }
                    var r = ul.isClockWise,
                        o = this.subPaths;
                    if (0 === o.length) return [];
                    if (!0 === t) return n(o);
                    var a,
                        s,
                        c,
                        l = [];
                    if (1 === o.length) return (s = o[0]), ((c = new Vu()).curves = s.curves), l.push(c), l;
                    var u = !r(o[0].getPoints());
                    u = e ? !u : u;
                    var h,
                        d,
                        p = [],
                        f = [],
                        m = [],
                        v = 0;
                    (f[v] = void 0), (m[v] = []);
                    for (var g = 0, y = o.length; g < y; g++)
                        (a = r((h = (s = o[g]).getPoints()))), (a = e ? !a : a) ? (!u && f[v] && v++, (f[v] = { s: new Vu(), p: h }), (f[v].s.curves = s.curves), u && v++, (m[v] = [])) : m[v].push({ h: s, p: h[0] });
                    if (!f[0]) return n(o);
                    if (f.length > 1) {
                        for (var x = !1, _ = [], b = 0, w = f.length; b < w; b++) p[b] = [];
                        for (b = 0, w = f.length; b < w; b++)
                            for (var M = m[b], S = 0; S < M.length; S++) {
                                for (var E = M[S], T = !0, A = 0; A < f.length; A++) i(E.p, f[A].p) && (b !== A && _.push({ froms: b, tos: A, hole: S }), T ? ((T = !1), p[A].push(E)) : (x = !0));
                                T && p[b].push(E);
                            }
                        _.length > 0 && (x || (m = p));
                    }
                    g = 0;
                    for (var L = f.length; g < L; g++) {
                        (c = f[g].s), l.push(c);
                        for (var C = 0, R = (d = m[g]).length; C < R; C++) c.holes.push(d[C].h);
                    }
                    return l;
                },
            }),
            Object.assign(fh.prototype, {
                isFont: !0,
                generateShapes: function (e, t) {
                    void 0 === t && (t = 100);
                    for (
                        var n = [],
                            i = (function (e, t, n) {
                                for (var i = Array.from ? Array.from(e) : String(e).split(""), r = t / n.resolution, o = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * r, a = [], s = 0, c = 0, l = 0; l < i.length; l++) {
                                    var u = i[l];
                                    if ("\n" === u) (s = 0), (c -= o);
                                    else {
                                        var h = mh(u, r, s, c, n);
                                        (s += h.offsetX), a.push(h.path);
                                    }
                                }
                                return a;
                            })(e, t, this.data),
                            r = 0,
                            o = i.length;
                        r < o;
                        r++
                    )
                        Array.prototype.push.apply(n, i[r].toShapes());
                    return n;
                },
            }),
            (vh.prototype = Object.assign(Object.create(hu.prototype), {
                constructor: vh,
                load: function (e, t, n, i) {
                    var r = this,
                        o = new pu(this.manager);
                    o.setPath(this.path),
                        o.load(
                            e,
                            function (e) {
                                var n;
                                try {
                                    n = JSON.parse(e);
                                } catch (t) {
                                    console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), (n = JSON.parse(e.substring(65, e.length - 2)));
                                }
                                var i = r.parse(n);
                                t && t(i);
                            },
                            n,
                            i
                        );
                },
                parse: function (e) {
                    return new fh(e);
                },
            }));
        var gh = {
            getContext: function () {
                return void 0 === ch && (ch = new (window.AudioContext || window.webkitAudioContext)()), ch;
            },
            setContext: function (e) {
                ch = e;
            },
        };
        function yh(e) {
            hu.call(this, e);
        }
        function xh() {
            this.coefficients = [];
            for (var e = 0; e < 9; e++) this.coefficients.push(new Sn());
        }
        function _h(e, t) {
            ku.call(this, void 0, t), (this.sh = void 0 !== e ? e : new xh());
        }
        function bh(e, t, n) {
            _h.call(this, void 0, n);
            var i = new Zi().set(e),
                r = new Zi().set(t),
                o = new Sn(i.r, i.g, i.b),
                a = new Sn(r.r, r.g, r.b),
                s = Math.sqrt(Math.PI),
                c = s * Math.sqrt(0.75);
            this.sh.coefficients[0].copy(o).add(a).multiplyScalar(s), this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(c);
        }
        function wh(e, t) {
            _h.call(this, void 0, t);
            var n = new Zi().set(e);
            this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI));
        }
        (yh.prototype = Object.assign(Object.create(hu.prototype), {
            constructor: yh,
            load: function (e, t, n, i) {
                var r = new pu(this.manager);
                r.setResponseType("arraybuffer"),
                    r.setPath(this.path),
                    r.load(
                        e,
                        function (e) {
                            var n = e.slice(0);
                            gh.getContext().decodeAudioData(n, function (e) {
                                t(e);
                            });
                        },
                        n,
                        i
                    );
            },
        })),
            Object.assign(xh.prototype, {
                isSphericalHarmonics3: !0,
                set: function (e) {
                    for (var t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
                    return this;
                },
                zero: function () {
                    for (var e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
                    return this;
                },
                getAt: function (e, t) {
                    var n = e.x,
                        i = e.y,
                        r = e.z,
                        o = this.coefficients;
                    return (
                        t.copy(o[0]).multiplyScalar(0.282095),
                        t.addScale(o[1], 0.488603 * i),
                        t.addScale(o[2], 0.488603 * r),
                        t.addScale(o[3], 0.488603 * n),
                        t.addScale(o[4], n * i * 1.092548),
                        t.addScale(o[5], i * r * 1.092548),
                        t.addScale(o[6], 0.315392 * (3 * r * r - 1)),
                        t.addScale(o[7], n * r * 1.092548),
                        t.addScale(o[8], 0.546274 * (n * n - i * i)),
                        t
                    );
                },
                getIrradianceAt: function (e, t) {
                    var n = e.x,
                        i = e.y,
                        r = e.z,
                        o = this.coefficients;
                    return (
                        t.copy(o[0]).multiplyScalar(0.886227),
                        t.addScale(o[1], 1.023328 * i),
                        t.addScale(o[2], 1.023328 * r),
                        t.addScale(o[3], 1.023328 * n),
                        t.addScale(o[4], 0.858086 * n * i),
                        t.addScale(o[5], 0.858086 * i * r),
                        t.addScale(o[6], 0.743125 * r * r - 0.247708),
                        t.addScale(o[7], 0.858086 * n * r),
                        t.addScale(o[8], 0.429043 * (n * n - i * i)),
                        t
                    );
                },
                add: function (e) {
                    for (var t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
                    return this;
                },
                scale: function (e) {
                    for (var t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
                    return this;
                },
                lerp: function (e, t) {
                    for (var n = 0; n < 9; n++) this.coefficients[n].lerp(e.coefficients[n], t);
                    return this;
                },
                equals: function (e) {
                    for (var t = 0; t < 9; t++) if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
                    return !0;
                },
                copy: function (e) {
                    return this.set(e.coefficients);
                },
                clone: function () {
                    return new this.constructor().copy(this);
                },
                fromArray: function (e, t) {
                    void 0 === t && (t = 0);
                    for (var n = this.coefficients, i = 0; i < 9; i++) n[i].fromArray(e, t + 3 * i);
                    return this;
                },
                toArray: function (e, t) {
                    void 0 === e && (e = []), void 0 === t && (t = 0);
                    for (var n = this.coefficients, i = 0; i < 9; i++) n[i].toArray(e, t + 3 * i);
                    return e;
                },
            }),
            Object.assign(xh, {
                getBasisAt: function (e, t) {
                    var n = e.x,
                        i = e.y,
                        r = e.z;
                    (t[0] = 0.282095),
                        (t[1] = 0.488603 * i),
                        (t[2] = 0.488603 * r),
                        (t[3] = 0.488603 * n),
                        (t[4] = 1.092548 * n * i),
                        (t[5] = 1.092548 * i * r),
                        (t[6] = 0.315392 * (3 * r * r - 1)),
                        (t[7] = 1.092548 * n * r),
                        (t[8] = 0.546274 * (n * n - i * i));
                },
            }),
            (_h.prototype = Object.assign(Object.create(ku.prototype), {
                constructor: _h,
                isLightProbe: !0,
                copy: function (e) {
                    return ku.prototype.copy.call(this, e), this.sh.copy(e.sh), (this.intensity = e.intensity), this;
                },
                toJSON: function (e) {
                    return ku.prototype.toJSON.call(this, e);
                },
            })),
            (bh.prototype = Object.assign(Object.create(_h.prototype), {
                constructor: bh,
                isHemisphereLightProbe: !0,
                copy: function (e) {
                    return _h.prototype.copy.call(this, e), this;
                },
                toJSON: function (e) {
                    return _h.prototype.toJSON.call(this, e);
                },
            })),
            (wh.prototype = Object.assign(Object.create(_h.prototype), {
                constructor: wh,
                isAmbientLightProbe: !0,
                copy: function (e) {
                    return _h.prototype.copy.call(this, e), this;
                },
                toJSON: function (e) {
                    return _h.prototype.toJSON.call(this, e);
                },
            }));
        var Mh = new Hn(),
            Sh = new Hn();
        function Eh() {
            (this.type = "StereoCamera"),
                (this.aspect = 1),
                (this.eyeSep = 0.064),
                (this.cameraL = new ro()),
                this.cameraL.layers.enable(1),
                (this.cameraL.matrixAutoUpdate = !1),
                (this.cameraR = new ro()),
                this.cameraR.layers.enable(2),
                (this.cameraR.matrixAutoUpdate = !1),
                (this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null });
        }
        function Th(e) {
            (this.autoStart = void 0 === e || e), (this.startTime = 0), (this.oldTime = 0), (this.elapsedTime = 0), (this.running = !1);
        }
        Object.assign(Eh.prototype, {
            update: function (e) {
                var t = this._cache;
                if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
                    (t.focus = e.focus), (t.fov = e.fov), (t.aspect = e.aspect * this.aspect), (t.near = e.near), (t.far = e.far), (t.zoom = e.zoom), (t.eyeSep = this.eyeSep);
                    var n,
                        i,
                        r = e.projectionMatrix.clone(),
                        o = t.eyeSep / 2,
                        a = (o * t.near) / t.focus,
                        s = (t.near * Math.tan(xn.DEG2RAD * t.fov * 0.5)) / t.zoom;
                    (Sh.elements[12] = -o),
                        (Mh.elements[12] = o),
                        (n = -s * t.aspect + a),
                        (i = s * t.aspect + a),
                        (r.elements[0] = (2 * t.near) / (i - n)),
                        (r.elements[8] = (i + n) / (i - n)),
                        this.cameraL.projectionMatrix.copy(r),
                        (n = -s * t.aspect - a),
                        (i = s * t.aspect - a),
                        (r.elements[0] = (2 * t.near) / (i - n)),
                        (r.elements[8] = (i + n) / (i - n)),
                        this.cameraR.projectionMatrix.copy(r);
                }
                this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(Sh), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Mh);
            },
        }),
            Object.assign(Th.prototype, {
                start: function () {
                    (this.startTime = ("undefined" == typeof performance ? Date : performance).now()), (this.oldTime = this.startTime), (this.elapsedTime = 0), (this.running = !0);
                },
                stop: function () {
                    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
                },
                getElapsedTime: function () {
                    return this.getDelta(), this.elapsedTime;
                },
                getDelta: function () {
                    var e = 0;
                    if (this.autoStart && !this.running) return this.start(), 0;
                    if (this.running) {
                        var t = ("undefined" == typeof performance ? Date : performance).now();
                        (e = (t - this.oldTime) / 1e3), (this.oldTime = t), (this.elapsedTime += e);
                    }
                    return e;
                },
            });
        var Ah = new Sn(),
            Lh = new bn(),
            Ch = new Sn(),
            Rh = new Sn();
        function Ph() {
            oi.call(this),
                (this.type = "AudioListener"),
                (this.context = gh.getContext()),
                (this.gain = this.context.createGain()),
                this.gain.connect(this.context.destination),
                (this.filter = null),
                (this.timeDelta = 0),
                (this._clock = new Th());
        }
        function Oh(e) {
            oi.call(this),
                (this.type = "Audio"),
                (this.listener = e),
                (this.context = e.context),
                (this.gain = this.context.createGain()),
                this.gain.connect(e.getInput()),
                (this.autoplay = !1),
                (this.buffer = null),
                (this.detune = 0),
                (this.loop = !1),
                (this.loopStart = 0),
                (this.loopEnd = 0),
                (this.offset = 0),
                (this.duration = void 0),
                (this.playbackRate = 1),
                (this.isPlaying = !1),
                (this.hasPlaybackControl = !0),
                (this.sourceType = "empty"),
                (this._startedAt = 0),
                (this._pausedAt = 0),
                (this.filters = []);
        }
        (Ph.prototype = Object.assign(Object.create(oi.prototype), {
            constructor: Ph,
            getInput: function () {
                return this.gain;
            },
            removeFilter: function () {
                return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), (this.filter = null)), this;
            },
            getFilter: function () {
                return this.filter;
            },
            setFilter: function (e) {
                return (
                    null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
                    (this.filter = e),
                    this.gain.connect(this.filter),
                    this.filter.connect(this.context.destination),
                    this
                );
            },
            getMasterVolume: function () {
                return this.gain.gain.value;
            },
            setMasterVolume: function (e) {
                return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
            },
            updateMatrixWorld: function (e) {
                oi.prototype.updateMatrixWorld.call(this, e);
                var t = this.context.listener,
                    n = this.up;
                if (((this.timeDelta = this._clock.getDelta()), this.matrixWorld.decompose(Ah, Lh, Ch), Rh.set(0, 0, -1).applyQuaternion(Lh), t.positionX)) {
                    var i = this.context.currentTime + this.timeDelta;
                    t.positionX.linearRampToValueAtTime(Ah.x, i),
                        t.positionY.linearRampToValueAtTime(Ah.y, i),
                        t.positionZ.linearRampToValueAtTime(Ah.z, i),
                        t.forwardX.linearRampToValueAtTime(Rh.x, i),
                        t.forwardY.linearRampToValueAtTime(Rh.y, i),
                        t.forwardZ.linearRampToValueAtTime(Rh.z, i),
                        t.upX.linearRampToValueAtTime(n.x, i),
                        t.upY.linearRampToValueAtTime(n.y, i),
                        t.upZ.linearRampToValueAtTime(n.z, i);
                } else t.setPosition(Ah.x, Ah.y, Ah.z), t.setOrientation(Rh.x, Rh.y, Rh.z, n.x, n.y, n.z);
            },
        })),
            (Oh.prototype = Object.assign(Object.create(oi.prototype), {
                constructor: Oh,
                getOutput: function () {
                    return this.gain;
                },
                setNodeSource: function (e) {
                    return (this.hasPlaybackControl = !1), (this.sourceType = "audioNode"), (this.source = e), this.connect(), this;
                },
                setMediaElementSource: function (e) {
                    return (this.hasPlaybackControl = !1), (this.sourceType = "mediaNode"), (this.source = this.context.createMediaElementSource(e)), this.connect(), this;
                },
                setMediaStreamSource: function (e) {
                    return (this.hasPlaybackControl = !1), (this.sourceType = "mediaStreamNode"), (this.source = this.context.createMediaStreamSource(e)), this.connect(), this;
                },
                setBuffer: function (e) {
                    return (this.buffer = e), (this.sourceType = "buffer"), this.autoplay && this.play(), this;
                },
                play: function (e) {
                    if ((void 0 === e && (e = 0), !0 !== this.isPlaying)) {
                        if (!1 !== this.hasPlaybackControl) {
                            this._startedAt = this.context.currentTime + e;
                            var t = this.context.createBufferSource();
                            return (
                                (t.buffer = this.buffer),
                                (t.loop = this.loop),
                                (t.loopStart = this.loopStart),
                                (t.loopEnd = this.loopEnd),
                                (t.onended = this.onEnded.bind(this)),
                                t.start(this._startedAt, this._pausedAt + this.offset, this.duration),
                                (this.isPlaying = !0),
                                (this.source = t),
                                this.setDetune(this.detune),
                                this.setPlaybackRate(this.playbackRate),
                                this.connect()
                            );
                        }
                        console.warn("THREE.Audio: this Audio has no playback control.");
                    } else console.warn("THREE.Audio: Audio is already playing.");
                },
                pause: function () {
                    if (!1 !== this.hasPlaybackControl)
                        return !0 === this.isPlaying && ((this._pausedAt = (this.context.currentTime - this._startedAt) * this.playbackRate), this.source.stop(), (this.source.onended = null), (this.isPlaying = !1)), this;
                    console.warn("THREE.Audio: this Audio has no playback control.");
                },
                stop: function () {
                    if (!1 !== this.hasPlaybackControl) return (this._pausedAt = 0), this.source.stop(), (this.source.onended = null), (this.isPlaying = !1), this;
                    console.warn("THREE.Audio: this Audio has no playback control.");
                },
                connect: function () {
                    if (this.filters.length > 0) {
                        this.source.connect(this.filters[0]);
                        for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
                        this.filters[this.filters.length - 1].connect(this.getOutput());
                    } else this.source.connect(this.getOutput());
                    return this;
                },
                disconnect: function () {
                    if (this.filters.length > 0) {
                        this.source.disconnect(this.filters[0]);
                        for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
                        this.filters[this.filters.length - 1].disconnect(this.getOutput());
                    } else this.source.disconnect(this.getOutput());
                    return this;
                },
                getFilters: function () {
                    return this.filters;
                },
                setFilters: function (e) {
                    return e || (e = []), !0 === this.isPlaying ? (this.disconnect(), (this.filters = e), this.connect()) : (this.filters = e), this;
                },
                setDetune: function (e) {
                    if (((this.detune = e), void 0 !== this.source.detune)) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
                },
                getDetune: function () {
                    return this.detune;
                },
                getFilter: function () {
                    return this.getFilters()[0];
                },
                setFilter: function (e) {
                    return this.setFilters(e ? [e] : []);
                },
                setPlaybackRate: function (e) {
                    if (!1 !== this.hasPlaybackControl) return (this.playbackRate = e), !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
                    console.warn("THREE.Audio: this Audio has no playback control.");
                },
                getPlaybackRate: function () {
                    return this.playbackRate;
                },
                onEnded: function () {
                    this.isPlaying = !1;
                },
                getLoop: function () {
                    return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
                },
                setLoop: function (e) {
                    if (!1 !== this.hasPlaybackControl) return (this.loop = e), !0 === this.isPlaying && (this.source.loop = this.loop), this;
                    console.warn("THREE.Audio: this Audio has no playback control.");
                },
                setLoopStart: function (e) {
                    return (this.loopStart = e), this;
                },
                setLoopEnd: function (e) {
                    return (this.loopEnd = e), this;
                },
                getVolume: function () {
                    return this.gain.gain.value;
                },
                setVolume: function (e) {
                    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
                },
            }));
        var Dh = new Sn(),
            Ih = new bn(),
            Nh = new Sn(),
            Uh = new Sn();
        function Bh(e) {
            Oh.call(this, e), (this.panner = this.context.createPanner()), (this.panner.panningModel = "HRTF"), this.panner.connect(this.gain);
        }
        function zh(e, t) {
            (this.analyser = e.context.createAnalyser()), (this.analyser.fftSize = void 0 !== t ? t : 2048), (this.data = new Uint8Array(this.analyser.frequencyBinCount)), e.getOutput().connect(this.analyser);
        }
        function Fh(e, t, n) {
            (this.binding = e), (this.valueSize = n);
            var i,
                r = Float64Array;
            switch (t) {
                case "quaternion":
                    i = this._slerp;
                    break;
                case "string":
                case "bool":
                    (r = Array), (i = this._select);
                    break;
                default:
                    i = this._lerp;
            }
            (this.buffer = new r(4 * n)), (this._mixBufferRegion = i), (this.cumulativeWeight = 0), (this.useCount = 0), (this.referenceCount = 0);
        }
        (Bh.prototype = Object.assign(Object.create(Oh.prototype), {
            constructor: Bh,
            getOutput: function () {
                return this.panner;
            },
            getRefDistance: function () {
                return this.panner.refDistance;
            },
            setRefDistance: function (e) {
                return (this.panner.refDistance = e), this;
            },
            getRolloffFactor: function () {
                return this.panner.rolloffFactor;
            },
            setRolloffFactor: function (e) {
                return (this.panner.rolloffFactor = e), this;
            },
            getDistanceModel: function () {
                return this.panner.distanceModel;
            },
            setDistanceModel: function (e) {
                return (this.panner.distanceModel = e), this;
            },
            getMaxDistance: function () {
                return this.panner.maxDistance;
            },
            setMaxDistance: function (e) {
                return (this.panner.maxDistance = e), this;
            },
            setDirectionalCone: function (e, t, n) {
                return (this.panner.coneInnerAngle = e), (this.panner.coneOuterAngle = t), (this.panner.coneOuterGain = n), this;
            },
            updateMatrixWorld: function (e) {
                if ((oi.prototype.updateMatrixWorld.call(this, e), !0 !== this.hasPlaybackControl || !1 !== this.isPlaying)) {
                    this.matrixWorld.decompose(Dh, Ih, Nh), Uh.set(0, 0, 1).applyQuaternion(Ih);
                    var t = this.panner;
                    if (t.positionX) {
                        var n = this.context.currentTime + this.listener.timeDelta;
                        t.positionX.linearRampToValueAtTime(Dh.x, n),
                            t.positionY.linearRampToValueAtTime(Dh.y, n),
                            t.positionZ.linearRampToValueAtTime(Dh.z, n),
                            t.orientationX.linearRampToValueAtTime(Uh.x, n),
                            t.orientationY.linearRampToValueAtTime(Uh.y, n),
                            t.orientationZ.linearRampToValueAtTime(Uh.z, n);
                    } else t.setPosition(Dh.x, Dh.y, Dh.z), t.setOrientation(Uh.x, Uh.y, Uh.z);
                }
            },
        })),
            Object.assign(zh.prototype, {
                getFrequencyData: function () {
                    return this.analyser.getByteFrequencyData(this.data), this.data;
                },
                getAverageFrequency: function () {
                    for (var e = 0, t = this.getFrequencyData(), n = 0; n < t.length; n++) e += t[n];
                    return e / t.length;
                },
            }),
            Object.assign(Fh.prototype, {
                accumulate: function (e, t) {
                    var n = this.buffer,
                        i = this.valueSize,
                        r = e * i + i,
                        o = this.cumulativeWeight;
                    if (0 === o) {
                        for (var a = 0; a !== i; ++a) n[r + a] = n[a];
                        o = t;
                    } else {
                        var s = t / (o += t);
                        this._mixBufferRegion(n, r, 0, s, i);
                    }
                    this.cumulativeWeight = o;
                },
                apply: function (e) {
                    var t = this.valueSize,
                        n = this.buffer,
                        i = e * t + t,
                        r = this.cumulativeWeight,
                        o = this.binding;
                    if (((this.cumulativeWeight = 0), r < 1)) {
                        var a = 3 * t;
                        this._mixBufferRegion(n, i, a, 1 - r, t);
                    }
                    for (var s = t, c = t + t; s !== c; ++s)
                        if (n[s] !== n[s + t]) {
                            o.setValue(n, i);
                            break;
                        }
                },
                saveOriginalState: function () {
                    var e = this.binding,
                        t = this.buffer,
                        n = this.valueSize,
                        i = 3 * n;
                    e.getValue(t, i);
                    for (var r = n, o = i; r !== o; ++r) t[r] = t[i + (r % n)];
                    this.cumulativeWeight = 0;
                },
                restoreOriginalState: function () {
                    var e = 3 * this.valueSize;
                    this.binding.setValue(this.buffer, e);
                },
                _select: function (e, t, n, i, r) {
                    if (i >= 0.5) for (var o = 0; o !== r; ++o) e[t + o] = e[n + o];
                },
                _slerp: function (e, t, n, i) {
                    bn.slerpFlat(e, t, e, t, e, n, i);
                },
                _lerp: function (e, t, n, i, r) {
                    for (var o = 1 - i, a = 0; a !== r; ++a) {
                        var s = t + a;
                        e[s] = e[s] * o + e[n + a] * i;
                    }
                },
            });
        var Gh = new RegExp("[\\[\\]\\.:\\/]", "g"),
            Hh = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
            Vh = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
            kh = /(WCOD+)?/.source.replace("WCOD", Hh),
            jh = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
            Wh = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
            qh = new RegExp("^" + Vh + kh + jh + Wh + "$"),
            Xh = ["material", "materials", "bones"];
        function Yh(e, t, n) {
            var i = n || Jh.parseTrackName(t);
            (this._targetGroup = e), (this._bindings = e.subscribe_(t, i));
        }
        function Jh(e, t, n) {
            (this.path = t), (this.parsedPath = n || Jh.parseTrackName(t)), (this.node = Jh.findNode(e, this.parsedPath.nodeName) || e), (this.rootNode = e);
        }
        function Zh() {
            (this.uuid = xn.generateUUID()), (this._objects = Array.prototype.slice.call(arguments)), (this.nCachedObjects_ = 0);
            var e = {};
            this._indicesByUUID = e;
            for (var t = 0, n = arguments.length; t !== n; ++t) e[arguments[t].uuid] = t;
            (this._paths = []), (this._parsedPaths = []), (this._bindings = []), (this._bindingsIndicesByPath = {});
            var i = this;
            this.stats = {
                objects: {
                    get total() {
                        return i._objects.length;
                    },
                    get inUse() {
                        return this.total - i.nCachedObjects_;
                    },
                },
                get bindingsPerObject() {
                    return i._bindings.length;
                },
            };
        }
        function Kh(e, t, n) {
            (this._mixer = e), (this._clip = t), (this._localRoot = n || null);
            for (var i = t.tracks, r = i.length, o = new Array(r), a = { endingStart: Tt, endingEnd: Tt }, s = 0; s !== r; ++s) {
                var c = i[s].createInterpolant(null);
                (o[s] = c), (c.settings = a);
            }
            (this._interpolantSettings = a),
                (this._interpolants = o),
                (this._propertyBindings = new Array(r)),
                (this._cacheIndex = null),
                (this._byClipCacheIndex = null),
                (this._timeScaleInterpolant = null),
                (this._weightInterpolant = null),
                (this.loop = bt),
                (this._loopCount = -1),
                (this._startTime = null),
                (this.time = 0),
                (this.timeScale = 1),
                (this._effectiveTimeScale = 1),
                (this.weight = 1),
                (this._effectiveWeight = 1),
                (this.repetitions = 1 / 0),
                (this.paused = !1),
                (this.enabled = !0),
                (this.clampWhenFinished = !1),
                (this.zeroSlopeAtStart = !0),
                (this.zeroSlopeAtEnd = !0);
        }
        function Qh(e) {
            (this._root = e), this._initMemoryManager(), (this._accuIndex = 0), (this.time = 0), (this.timeScale = 1);
        }
        function $h(e) {
            "string" == typeof e && (console.warn("THREE.Uniform: Type parameter is no longer needed."), (e = arguments[1])), (this.value = e);
        }
        function ed(e, t, n) {
            Es.call(this, e, t), (this.meshPerAttribute = n || 1);
        }
        function td(e, t, n, i) {
            (this.ray = new Pi(e, t)),
                (this.near = n || 0),
                (this.far = i || 1 / 0),
                (this.camera = null),
                (this.params = { Mesh: {}, Line: {}, LOD: {}, Points: { threshold: 1 }, Sprite: {} }),
                Object.defineProperties(this.params, {
                    PointCloud: {
                        get: function () {
                            return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points;
                        },
                    },
                });
        }
        function nd(e, t) {
            return e.distance - t.distance;
        }
        function id(e, t, n, i) {
            if (!1 !== e.visible && (e.raycast(t, n), !0 === i)) for (var r = e.children, o = 0, a = r.length; o < a; o++) id(r[o], t, n, !0);
        }
        function rd(e, t, n) {
            return (this.radius = void 0 !== e ? e : 1), (this.phi = void 0 !== t ? t : 0), (this.theta = void 0 !== n ? n : 0), this;
        }
        function od(e, t, n) {
            return (this.radius = void 0 !== e ? e : 1), (this.theta = void 0 !== t ? t : 0), (this.y = void 0 !== n ? n : 0), this;
        }
        Object.assign(Yh.prototype, {
            getValue: function (e, t) {
                this.bind();
                var n = this._targetGroup.nCachedObjects_,
                    i = this._bindings[n];
                void 0 !== i && i.getValue(e, t);
            },
            setValue: function (e, t) {
                for (var n = this._bindings, i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(e, t);
            },
            bind: function () {
                for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind();
            },
            unbind: function () {
                for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind();
            },
        }),
            Object.assign(Jh, {
                Composite: Yh,
                create: function (e, t, n) {
                    return e && e.isAnimationObjectGroup ? new Jh.Composite(e, t, n) : new Jh(e, t, n);
                },
                sanitizeNodeName: function (e) {
                    return e.replace(/\s/g, "_").replace(Gh, "");
                },
                parseTrackName: function (e) {
                    var t = qh.exec(e);
                    if (!t) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
                    var n = { nodeName: t[2], objectName: t[3], objectIndex: t[4], propertyName: t[5], propertyIndex: t[6] },
                        i = n.nodeName && n.nodeName.lastIndexOf(".");
                    if (void 0 !== i && -1 !== i) {
                        var r = n.nodeName.substring(i + 1);
                        -1 !== Xh.indexOf(r) && ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = r));
                    }
                    if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                    return n;
                },
                findNode: function (e, t) {
                    if (!t || "" === t || "root" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e;
                    if (e.skeleton) {
                        var n = e.skeleton.getBoneByName(t);
                        if (void 0 !== n) return n;
                    }
                    if (e.children) {
                        var i = function (e) {
                                for (var n = 0; n < e.length; n++) {
                                    var r = e[n];
                                    if (r.name === t || r.uuid === t) return r;
                                    var o = i(r.children);
                                    if (o) return o;
                                }
                                return null;
                            },
                            r = i(e.children);
                        if (r) return r;
                    }
                    return null;
                },
            }),
            Object.assign(Jh.prototype, {
                _getValue_unavailable: function () {},
                _setValue_unavailable: function () {},
                BindingType: { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 },
                Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 },
                GetterByBindingType: [
                    function (e, t) {
                        e[t] = this.node[this.propertyName];
                    },
                    function (e, t) {
                        for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) e[t++] = n[i];
                    },
                    function (e, t) {
                        e[t] = this.resolvedProperty[this.propertyIndex];
                    },
                    function (e, t) {
                        this.resolvedProperty.toArray(e, t);
                    },
                ],
                SetterByBindingTypeAndVersioning: [
                    [
                        function (e, t) {
                            this.targetObject[this.propertyName] = e[t];
                        },
                        function (e, t) {
                            (this.targetObject[this.propertyName] = e[t]), (this.targetObject.needsUpdate = !0);
                        },
                        function (e, t) {
                            (this.targetObject[this.propertyName] = e[t]), (this.targetObject.matrixWorldNeedsUpdate = !0);
                        },
                    ],
                    [
                        function (e, t) {
                            for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
                        },
                        function (e, t) {
                            for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
                            this.targetObject.needsUpdate = !0;
                        },
                        function (e, t) {
                            for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
                            this.targetObject.matrixWorldNeedsUpdate = !0;
                        },
                    ],
                    [
                        function (e, t) {
                            this.resolvedProperty[this.propertyIndex] = e[t];
                        },
                        function (e, t) {
                            (this.resolvedProperty[this.propertyIndex] = e[t]), (this.targetObject.needsUpdate = !0);
                        },
                        function (e, t) {
                            (this.resolvedProperty[this.propertyIndex] = e[t]), (this.targetObject.matrixWorldNeedsUpdate = !0);
                        },
                    ],
                    [
                        function (e, t) {
                            this.resolvedProperty.fromArray(e, t);
                        },
                        function (e, t) {
                            this.resolvedProperty.fromArray(e, t), (this.targetObject.needsUpdate = !0);
                        },
                        function (e, t) {
                            this.resolvedProperty.fromArray(e, t), (this.targetObject.matrixWorldNeedsUpdate = !0);
                        },
                    ],
                ],
                getValue: function (e, t) {
                    this.bind(), this.getValue(e, t);
                },
                setValue: function (e, t) {
                    this.bind(), this.setValue(e, t);
                },
                bind: function () {
                    var e = this.node,
                        t = this.parsedPath,
                        n = t.objectName,
                        i = t.propertyName,
                        r = t.propertyIndex;
                    if ((e || ((e = Jh.findNode(this.rootNode, t.nodeName) || this.rootNode), (this.node = e)), (this.getValue = this._getValue_unavailable), (this.setValue = this._setValue_unavailable), e)) {
                        if (n) {
                            var o = t.objectIndex;
                            switch (n) {
                                case "materials":
                                    if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                    if (!e.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                    e = e.material.materials;
                                    break;
                                case "bones":
                                    if (!e.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                    e = e.skeleton.bones;
                                    for (var a = 0; a < e.length; a++)
                                        if (e[a].name === o) {
                                            o = a;
                                            break;
                                        }
                                    break;
                                default:
                                    if (void 0 === e[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                    e = e[n];
                            }
                            if (void 0 !== o) {
                                if (void 0 === e[o]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                                e = e[o];
                            }
                        }
                        var s = e[i];
                        if (void 0 !== s) {
                            var c = this.Versioning.None;
                            (this.targetObject = e), void 0 !== e.needsUpdate ? (c = this.Versioning.NeedsUpdate) : void 0 !== e.matrixWorldNeedsUpdate && (c = this.Versioning.MatrixWorldNeedsUpdate);
                            var l = this.BindingType.Direct;
                            if (void 0 !== r) {
                                if ("morphTargetInfluences" === i) {
                                    if (!e.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                    if (e.geometry.isBufferGeometry) {
                                        if (!e.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                        for (a = 0; a < this.node.geometry.morphAttributes.position.length; a++)
                                            if (e.geometry.morphAttributes.position[a].name === r) {
                                                r = a;
                                                break;
                                            }
                                    } else {
                                        if (!e.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                                        for (a = 0; a < this.node.geometry.morphTargets.length; a++)
                                            if (e.geometry.morphTargets[a].name === r) {
                                                r = a;
                                                break;
                                            }
                                    }
                                }
                                (l = this.BindingType.ArrayElement), (this.resolvedProperty = s), (this.propertyIndex = r);
                            } else
                                void 0 !== s.fromArray && void 0 !== s.toArray
                                    ? ((l = this.BindingType.HasFromToArray), (this.resolvedProperty = s))
                                    : Array.isArray(s)
                                    ? ((l = this.BindingType.EntireArray), (this.resolvedProperty = s))
                                    : (this.propertyName = i);
                            (this.getValue = this.GetterByBindingType[l]), (this.setValue = this.SetterByBindingTypeAndVersioning[l][c]);
                        } else {
                            var u = t.nodeName;
                            console.error("THREE.PropertyBinding: Trying to update property for track: " + u + "." + i + " but it wasn't found.", e);
                        }
                    } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                },
                unbind: function () {
                    (this.node = null), (this.getValue = this._getValue_unbound), (this.setValue = this._setValue_unbound);
                },
            }),
            //!\ DECLARE ALIAS AFTER assign prototype !
            Object.assign(Jh.prototype, { _getValue_unbound: Jh.prototype.getValue, _setValue_unbound: Jh.prototype.setValue }),
            Object.assign(Zh.prototype, {
                isAnimationObjectGroup: !0,
                add: function () {
                    for (
                        var e = this._objects, t = e.length, n = this.nCachedObjects_, i = this._indicesByUUID, r = this._paths, o = this._parsedPaths, a = this._bindings, s = a.length, c = void 0, l = 0, u = arguments.length;
                        l !== u;
                        ++l
                    ) {
                        var h = arguments[l],
                            d = h.uuid,
                            p = i[d];
                        if (void 0 === p) {
                            (p = t++), (i[d] = p), e.push(h);
                            for (var f = 0, m = s; f !== m; ++f) a[f].push(new Jh(h, r[f], o[f]));
                        } else if (p < n) {
                            c = e[p];
                            var v = --n,
                                g = e[v];
                            (i[g.uuid] = p), (e[p] = g), (i[d] = v), (e[v] = h);
                            for (f = 0, m = s; f !== m; ++f) {
                                var y = a[f],
                                    x = y[v],
                                    _ = y[p];
                                (y[p] = x), void 0 === _ && (_ = new Jh(h, r[f], o[f])), (y[v] = _);
                            }
                        } else e[p] !== c && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
                    }
                    this.nCachedObjects_ = n;
                },
                remove: function () {
                    for (var e = this._objects, t = this.nCachedObjects_, n = this._indicesByUUID, i = this._bindings, r = i.length, o = 0, a = arguments.length; o !== a; ++o) {
                        var s = arguments[o],
                            c = s.uuid,
                            l = n[c];
                        if (void 0 !== l && l >= t) {
                            var u = t++,
                                h = e[u];
                            (n[h.uuid] = l), (e[l] = h), (n[c] = u), (e[u] = s);
                            for (var d = 0, p = r; d !== p; ++d) {
                                var f = i[d],
                                    m = f[u],
                                    v = f[l];
                                (f[l] = m), (f[u] = v);
                            }
                        }
                    }
                    this.nCachedObjects_ = t;
                },
                uncache: function () {
                    for (var e = this._objects, t = e.length, n = this.nCachedObjects_, i = this._indicesByUUID, r = this._bindings, o = r.length, a = 0, s = arguments.length; a !== s; ++a) {
                        var c = arguments[a],
                            l = c.uuid,
                            u = i[l];
                        if (void 0 !== u)
                            if ((delete i[l], u < n)) {
                                var h = --n,
                                    d = e[h],
                                    p = e[(y = --t)];
                                (i[d.uuid] = u), (e[u] = d), (i[p.uuid] = h), (e[h] = p), e.pop();
                                for (var f = 0, m = o; f !== m; ++f) {
                                    var v = (x = r[f])[h],
                                        g = x[y];
                                    (x[u] = v), (x[h] = g), x.pop();
                                }
                            } else {
                                var y;
                                (i[(p = e[(y = --t)]).uuid] = u), (e[u] = p), e.pop();
                                for (f = 0, m = o; f !== m; ++f) {
                                    var x;
                                    ((x = r[f])[u] = x[y]), x.pop();
                                }
                            }
                    }
                    this.nCachedObjects_ = n;
                },
                subscribe_: function (e, t) {
                    var n = this._bindingsIndicesByPath,
                        i = n[e],
                        r = this._bindings;
                    if (void 0 !== i) return r[i];
                    var o = this._paths,
                        a = this._parsedPaths,
                        s = this._objects,
                        c = s.length,
                        l = this.nCachedObjects_,
                        u = new Array(c);
                    (i = r.length), (n[e] = i), o.push(e), a.push(t), r.push(u);
                    for (var h = l, d = s.length; h !== d; ++h) {
                        var p = s[h];
                        u[h] = new Jh(p, e, t);
                    }
                    return u;
                },
                unsubscribe_: function (e) {
                    var t = this._bindingsIndicesByPath,
                        n = t[e];
                    if (void 0 !== n) {
                        var i = this._paths,
                            r = this._parsedPaths,
                            o = this._bindings,
                            a = o.length - 1,
                            s = o[a];
                        (t[e[a]] = n), (o[n] = s), o.pop(), (r[n] = r[a]), r.pop(), (i[n] = i[a]), i.pop();
                    }
                },
            }),
            Object.assign(Kh.prototype, {
                play: function () {
                    return this._mixer._activateAction(this), this;
                },
                stop: function () {
                    return this._mixer._deactivateAction(this), this.reset();
                },
                reset: function () {
                    return (this.paused = !1), (this.enabled = !0), (this.time = 0), (this._loopCount = -1), (this._startTime = null), this.stopFading().stopWarping();
                },
                isRunning: function () {
                    return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this);
                },
                isScheduled: function () {
                    return this._mixer._isActiveAction(this);
                },
                startAt: function (e) {
                    return (this._startTime = e), this;
                },
                setLoop: function (e, t) {
                    return (this.loop = e), (this.repetitions = t), this;
                },
                setEffectiveWeight: function (e) {
                    return (this.weight = e), (this._effectiveWeight = this.enabled ? e : 0), this.stopFading();
                },
                getEffectiveWeight: function () {
                    return this._effectiveWeight;
                },
                fadeIn: function (e) {
                    return this._scheduleFading(e, 0, 1);
                },
                fadeOut: function (e) {
                    return this._scheduleFading(e, 1, 0);
                },
                crossFadeFrom: function (e, t, n) {
                    if ((e.fadeOut(t), this.fadeIn(t), n)) {
                        var i = this._clip.duration,
                            r = e._clip.duration,
                            o = r / i,
                            a = i / r;
                        e.warp(1, o, t), this.warp(a, 1, t);
                    }
                    return this;
                },
                crossFadeTo: function (e, t, n) {
                    return e.crossFadeFrom(this, t, n);
                },
                stopFading: function () {
                    var e = this._weightInterpolant;
                    return null !== e && ((this._weightInterpolant = null), this._mixer._takeBackControlInterpolant(e)), this;
                },
                setEffectiveTimeScale: function (e) {
                    return (this.timeScale = e), (this._effectiveTimeScale = this.paused ? 0 : e), this.stopWarping();
                },
                getEffectiveTimeScale: function () {
                    return this._effectiveTimeScale;
                },
                setDuration: function (e) {
                    return (this.timeScale = this._clip.duration / e), this.stopWarping();
                },
                syncWith: function (e) {
                    return (this.time = e.time), (this.timeScale = e.timeScale), this.stopWarping();
                },
                halt: function (e) {
                    return this.warp(this._effectiveTimeScale, 0, e);
                },
                warp: function (e, t, n) {
                    var i = this._mixer,
                        r = i.time,
                        o = this._timeScaleInterpolant,
                        a = this.timeScale;
                    null === o && ((o = i._lendControlInterpolant()), (this._timeScaleInterpolant = o));
                    var s = o.parameterPositions,
                        c = o.sampleValues;
                    return (s[0] = r), (s[1] = r + n), (c[0] = e / a), (c[1] = t / a), this;
                },
                stopWarping: function () {
                    var e = this._timeScaleInterpolant;
                    return null !== e && ((this._timeScaleInterpolant = null), this._mixer._takeBackControlInterpolant(e)), this;
                },
                getMixer: function () {
                    return this._mixer;
                },
                getClip: function () {
                    return this._clip;
                },
                getRoot: function () {
                    return this._localRoot || this._mixer._root;
                },
                _update: function (e, t, n, i) {
                    if (this.enabled) {
                        var r = this._startTime;
                        if (null !== r) {
                            var o = (e - r) * n;
                            if (o < 0 || 0 === n) return;
                            (this._startTime = null), (t = n * o);
                        }
                        t *= this._updateTimeScale(e);
                        var a = this._updateTime(t),
                            s = this._updateWeight(e);
                        if (s > 0) for (var c = this._interpolants, l = this._propertyBindings, u = 0, h = c.length; u !== h; ++u) c[u].evaluate(a), l[u].accumulate(i, s);
                    } else this._updateWeight(e);
                },
                _updateWeight: function (e) {
                    var t = 0;
                    if (this.enabled) {
                        t = this.weight;
                        var n = this._weightInterpolant;
                        if (null !== n) {
                            var i = n.evaluate(e)[0];
                            (t *= i), e > n.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = !1));
                        }
                    }
                    return (this._effectiveWeight = t), t;
                },
                _updateTimeScale: function (e) {
                    var t = 0;
                    if (!this.paused) {
                        t = this.timeScale;
                        var n = this._timeScaleInterpolant;
                        if (null !== n) (t *= n.evaluate(e)[0]), e > n.parameterPositions[1] && (this.stopWarping(), 0 === t ? (this.paused = !0) : (this.timeScale = t));
                    }
                    return (this._effectiveTimeScale = t), t;
                },
                _updateTime: function (e) {
                    var t = this.time + e,
                        n = this._clip.duration,
                        i = this.loop,
                        r = this._loopCount,
                        o = i === wt;
                    if (0 === e) return -1 === r ? t : o && 1 == (1 & r) ? n - t : t;
                    if (i === _t) {
                        -1 === r && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
                        e: {
                            if (t >= n) t = n;
                            else {
                                if (!(t < 0)) {
                                    this.time = t;
                                    break e;
                                }
                                t = 0;
                            }
                            this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1), (this.time = t), this._mixer.dispatchEvent({ type: "finished", action: this, direction: e < 0 ? -1 : 1 });
                        }
                    } else {
                        if ((-1 === r && (e >= 0 ? ((r = 0), this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), t >= n || t < 0)) {
                            var a = Math.floor(t / n);
                            (t -= n * a), (r += Math.abs(a));
                            var s = this.repetitions - r;
                            if (s <= 0) this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1), (t = e > 0 ? n : 0), (this.time = t), this._mixer.dispatchEvent({ type: "finished", action: this, direction: e > 0 ? 1 : -1 });
                            else {
                                if (1 === s) {
                                    var c = e < 0;
                                    this._setEndings(c, !c, o);
                                } else this._setEndings(!1, !1, o);
                                (this._loopCount = r), (this.time = t), this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: a });
                            }
                        } else this.time = t;
                        if (o && 1 == (1 & r)) return n - t;
                    }
                    return t;
                },
                _setEndings: function (e, t, n) {
                    var i = this._interpolantSettings;
                    n ? ((i.endingStart = At), (i.endingEnd = At)) : ((i.endingStart = e ? (this.zeroSlopeAtStart ? At : Tt) : Lt), (i.endingEnd = t ? (this.zeroSlopeAtEnd ? At : Tt) : Lt));
                },
                _scheduleFading: function (e, t, n) {
                    var i = this._mixer,
                        r = i.time,
                        o = this._weightInterpolant;
                    null === o && ((o = i._lendControlInterpolant()), (this._weightInterpolant = o));
                    var a = o.parameterPositions,
                        s = o.sampleValues;
                    return (a[0] = r), (s[0] = t), (a[1] = r + e), (s[1] = n), this;
                },
            }),
            (Qh.prototype = Object.assign(Object.create(vn.prototype), {
                constructor: Qh,
                _bindAction: function (e, t) {
                    var n = e._localRoot || this._root,
                        i = e._clip.tracks,
                        r = i.length,
                        o = e._propertyBindings,
                        a = e._interpolants,
                        s = n.uuid,
                        c = this._bindingsByRootAndName,
                        l = c[s];
                    void 0 === l && ((l = {}), (c[s] = l));
                    for (var u = 0; u !== r; ++u) {
                        var h = i[u],
                            d = h.name,
                            p = l[d];
                        if (void 0 !== p) o[u] = p;
                        else {
                            if (void 0 !== (p = o[u])) {
                                null === p._cacheIndex && (++p.referenceCount, this._addInactiveBinding(p, s, d));
                                continue;
                            }
                            var f = t && t._propertyBindings[u].binding.parsedPath;
                            ++(p = new Fh(Jh.create(n, d, f), h.ValueTypeName, h.getValueSize())).referenceCount, this._addInactiveBinding(p, s, d), (o[u] = p);
                        }
                        a[u].resultBuffer = p.buffer;
                    }
                },
                _activateAction: function (e) {
                    if (!this._isActiveAction(e)) {
                        if (null === e._cacheIndex) {
                            var t = (e._localRoot || this._root).uuid,
                                n = e._clip.uuid,
                                i = this._actionsByClip[n];
                            this._bindAction(e, i && i.knownActions[0]), this._addInactiveAction(e, n, t);
                        }
                        for (var r = e._propertyBindings, o = 0, a = r.length; o !== a; ++o) {
                            var s = r[o];
                            0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState());
                        }
                        this._lendAction(e);
                    }
                },
                _deactivateAction: function (e) {
                    if (this._isActiveAction(e)) {
                        for (var t = e._propertyBindings, n = 0, i = t.length; n !== i; ++n) {
                            var r = t[n];
                            0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r));
                        }
                        this._takeBackAction(e);
                    }
                },
                _initMemoryManager: function () {
                    (this._actions = []),
                        (this._nActiveActions = 0),
                        (this._actionsByClip = {}),
                        (this._bindings = []),
                        (this._nActiveBindings = 0),
                        (this._bindingsByRootAndName = {}),
                        (this._controlInterpolants = []),
                        (this._nActiveControlInterpolants = 0);
                    var e = this;
                    this.stats = {
                        actions: {
                            get total() {
                                return e._actions.length;
                            },
                            get inUse() {
                                return e._nActiveActions;
                            },
                        },
                        bindings: {
                            get total() {
                                return e._bindings.length;
                            },
                            get inUse() {
                                return e._nActiveBindings;
                            },
                        },
                        controlInterpolants: {
                            get total() {
                                return e._controlInterpolants.length;
                            },
                            get inUse() {
                                return e._nActiveControlInterpolants;
                            },
                        },
                    };
                },
                _isActiveAction: function (e) {
                    var t = e._cacheIndex;
                    return null !== t && t < this._nActiveActions;
                },
                _addInactiveAction: function (e, t, n) {
                    var i = this._actions,
                        r = this._actionsByClip,
                        o = r[t];
                    if (void 0 === o) (o = { knownActions: [e], actionByRoot: {} }), (e._byClipCacheIndex = 0), (r[t] = o);
                    else {
                        var a = o.knownActions;
                        (e._byClipCacheIndex = a.length), a.push(e);
                    }
                    (e._cacheIndex = i.length), i.push(e), (o.actionByRoot[n] = e);
                },
                _removeInactiveAction: function (e) {
                    var t = this._actions,
                        n = t[t.length - 1],
                        i = e._cacheIndex;
                    (n._cacheIndex = i), (t[i] = n), t.pop(), (e._cacheIndex = null);
                    var r = e._clip.uuid,
                        o = this._actionsByClip,
                        a = o[r],
                        s = a.knownActions,
                        c = s[s.length - 1],
                        l = e._byClipCacheIndex;
                    (c._byClipCacheIndex = l), (s[l] = c), s.pop(), (e._byClipCacheIndex = null), delete a.actionByRoot[(e._localRoot || this._root).uuid], 0 === s.length && delete o[r], this._removeInactiveBindingsForAction(e);
                },
                _removeInactiveBindingsForAction: function (e) {
                    for (var t = e._propertyBindings, n = 0, i = t.length; n !== i; ++n) {
                        var r = t[n];
                        0 == --r.referenceCount && this._removeInactiveBinding(r);
                    }
                },
                _lendAction: function (e) {
                    var t = this._actions,
                        n = e._cacheIndex,
                        i = this._nActiveActions++,
                        r = t[i];
                    (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
                },
                _takeBackAction: function (e) {
                    var t = this._actions,
                        n = e._cacheIndex,
                        i = --this._nActiveActions,
                        r = t[i];
                    (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
                },
                _addInactiveBinding: function (e, t, n) {
                    var i = this._bindingsByRootAndName,
                        r = i[t],
                        o = this._bindings;
                    void 0 === r && ((r = {}), (i[t] = r)), (r[n] = e), (e._cacheIndex = o.length), o.push(e);
                },
                _removeInactiveBinding: function (e) {
                    var t = this._bindings,
                        n = e.binding,
                        i = n.rootNode.uuid,
                        r = n.path,
                        o = this._bindingsByRootAndName,
                        a = o[i],
                        s = t[t.length - 1],
                        c = e._cacheIndex;
                    (s._cacheIndex = c), (t[c] = s), t.pop(), delete a[r], 0 === Object.keys(a).length && delete o[i];
                },
                _lendBinding: function (e) {
                    var t = this._bindings,
                        n = e._cacheIndex,
                        i = this._nActiveBindings++,
                        r = t[i];
                    (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
                },
                _takeBackBinding: function (e) {
                    var t = this._bindings,
                        n = e._cacheIndex,
                        i = --this._nActiveBindings,
                        r = t[i];
                    (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
                },
                _lendControlInterpolant: function () {
                    var e = this._controlInterpolants,
                        t = this._nActiveControlInterpolants++,
                        n = e[t];
                    return void 0 === n && (((n = new Zl(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = t), (e[t] = n)), n;
                },
                _takeBackControlInterpolant: function (e) {
                    var t = this._controlInterpolants,
                        n = e.__cacheIndex,
                        i = --this._nActiveControlInterpolants,
                        r = t[i];
                    (e.__cacheIndex = i), (t[i] = e), (r.__cacheIndex = n), (t[n] = r);
                },
                _controlInterpolantsResultBuffer: new Float32Array(1),
                clipAction: function (e, t) {
                    var n = t || this._root,
                        i = n.uuid,
                        r = "string" == typeof e ? au.findByName(n, e) : e,
                        o = null !== r ? r.uuid : e,
                        a = this._actionsByClip[o],
                        s = null;
                    if (void 0 !== a) {
                        var c = a.actionByRoot[i];
                        if (void 0 !== c) return c;
                        (s = a.knownActions[0]), null === r && (r = s._clip);
                    }
                    if (null === r) return null;
                    var l = new Kh(this, r, t);
                    return this._bindAction(l, s), this._addInactiveAction(l, o, i), l;
                },
                existingAction: function (e, t) {
                    var n = t || this._root,
                        i = n.uuid,
                        r = "string" == typeof e ? au.findByName(n, e) : e,
                        o = r ? r.uuid : e,
                        a = this._actionsByClip[o];
                    return (void 0 !== a && a.actionByRoot[i]) || null;
                },
                stopAllAction: function () {
                    var e = this._actions,
                        t = this._nActiveActions,
                        n = this._bindings,
                        i = this._nActiveBindings;
                    (this._nActiveActions = 0), (this._nActiveBindings = 0);
                    for (var r = 0; r !== t; ++r) e[r].reset();
                    for (r = 0; r !== i; ++r) n[r].useCount = 0;
                    return this;
                },
                update: function (e) {
                    e *= this.timeScale;
                    for (var t = this._actions, n = this._nActiveActions, i = (this.time += e), r = Math.sign(e), o = (this._accuIndex ^= 1), a = 0; a !== n; ++a) {
                        t[a]._update(i, e, r, o);
                    }
                    var s = this._bindings,
                        c = this._nActiveBindings;
                    for (a = 0; a !== c; ++a) s[a].apply(o);
                    return this;
                },
                setTime: function (e) {
                    this.time = 0;
                    for (var t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
                    return this.update(e);
                },
                getRoot: function () {
                    return this._root;
                },
                uncacheClip: function (e) {
                    var t = this._actions,
                        n = e.uuid,
                        i = this._actionsByClip,
                        r = i[n];
                    if (void 0 !== r) {
                        for (var o = r.knownActions, a = 0, s = o.length; a !== s; ++a) {
                            var c = o[a];
                            this._deactivateAction(c);
                            var l = c._cacheIndex,
                                u = t[t.length - 1];
                            (c._cacheIndex = null), (c._byClipCacheIndex = null), (u._cacheIndex = l), (t[l] = u), t.pop(), this._removeInactiveBindingsForAction(c);
                        }
                        delete i[n];
                    }
                },
                uncacheRoot: function (e) {
                    var t = e.uuid,
                        n = this._actionsByClip;
                    for (var i in n) {
                        var r = n[i].actionByRoot[t];
                        void 0 !== r && (this._deactivateAction(r), this._removeInactiveAction(r));
                    }
                    var o = this._bindingsByRootAndName[t];
                    if (void 0 !== o)
                        for (var a in o) {
                            var s = o[a];
                            s.restoreOriginalState(), this._removeInactiveBinding(s);
                        }
                },
                uncacheAction: function (e, t) {
                    var n = this.existingAction(e, t);
                    null !== n && (this._deactivateAction(n), this._removeInactiveAction(n));
                },
            })),
            ($h.prototype.clone = function () {
                return new $h(void 0 === this.value.clone ? this.value : this.value.clone());
            }),
            (ed.prototype = Object.assign(Object.create(Es.prototype), {
                constructor: ed,
                isInstancedInterleavedBuffer: !0,
                copy: function (e) {
                    return Es.prototype.copy.call(this, e), (this.meshPerAttribute = e.meshPerAttribute), this;
                },
            })),
            Object.assign(td.prototype, {
                linePrecision: 1,
                set: function (e, t) {
                    this.ray.set(e, t);
                },
                setFromCamera: function (e, t) {
                    t && t.isPerspectiveCamera
                        ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), (this.camera = t))
                        : t && t.isOrthographicCamera
                        ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), (this.camera = t))
                        : console.error("THREE.Raycaster: Unsupported camera type.");
                },
                intersectObject: function (e, t, n) {
                    var i = n || [];
                    return id(e, this, i, t), i.sort(nd), i;
                },
                intersectObjects: function (e, t, n) {
                    var i = n || [];
                    if (!1 === Array.isArray(e)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), i;
                    for (var r = 0, o = e.length; r < o; r++) id(e[r], this, i, t);
                    return i.sort(nd), i;
                },
            }),
            Object.assign(rd.prototype, {
                set: function (e, t, n) {
                    return (this.radius = e), (this.phi = t), (this.theta = n), this;
                },
                clone: function () {
                    return new this.constructor().copy(this);
                },
                copy: function (e) {
                    return (this.radius = e.radius), (this.phi = e.phi), (this.theta = e.theta), this;
                },
                makeSafe: function () {
                    return (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this;
                },
                setFromVector3: function (e) {
                    return this.setFromCartesianCoords(e.x, e.y, e.z);
                },
                setFromCartesianCoords: function (e, t, n) {
                    return (this.radius = Math.sqrt(e * e + t * t + n * n)), 0 === this.radius ? ((this.theta = 0), (this.phi = 0)) : ((this.theta = Math.atan2(e, n)), (this.phi = Math.acos(xn.clamp(t / this.radius, -1, 1)))), this;
                },
            }),
            Object.assign(od.prototype, {
                set: function (e, t, n) {
                    return (this.radius = e), (this.theta = t), (this.y = n), this;
                },
                clone: function () {
                    return new this.constructor().copy(this);
                },
                copy: function (e) {
                    return (this.radius = e.radius), (this.theta = e.theta), (this.y = e.y), this;
                },
                setFromVector3: function (e) {
                    return this.setFromCartesianCoords(e.x, e.y, e.z);
                },
                setFromCartesianCoords: function (e, t, n) {
                    return (this.radius = Math.sqrt(e * e + n * n)), (this.theta = Math.atan2(e, n)), (this.y = t), this;
                },
            });
        var ad = new _n();
        function sd(e, t) {
            (this.min = void 0 !== e ? e : new _n(1 / 0, 1 / 0)), (this.max = void 0 !== t ? t : new _n(-1 / 0, -1 / 0));
        }
        Object.assign(sd.prototype, {
            set: function (e, t) {
                return this.min.copy(e), this.max.copy(t), this;
            },
            setFromPoints: function (e) {
                this.makeEmpty();
                for (var t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
                return this;
            },
            setFromCenterAndSize: function (e, t) {
                var n = ad.copy(t).multiplyScalar(0.5);
                return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
            },
            clone: function () {
                return new this.constructor().copy(this);
            },
            copy: function (e) {
                return this.min.copy(e.min), this.max.copy(e.max), this;
            },
            makeEmpty: function () {
                return (this.min.x = this.min.y = 1 / 0), (this.max.x = this.max.y = -1 / 0), this;
            },
            isEmpty: function () {
                return this.max.x < this.min.x || this.max.y < this.min.y;
            },
            getCenter: function (e) {
                return void 0 === e && (console.warn("THREE.Box2: .getCenter() target is now required"), (e = new _n())), this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
            },
            getSize: function (e) {
                return void 0 === e && (console.warn("THREE.Box2: .getSize() target is now required"), (e = new _n())), this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
            },
            expandByPoint: function (e) {
                return this.min.min(e), this.max.max(e), this;
            },
            expandByVector: function (e) {
                return this.min.sub(e), this.max.add(e), this;
            },
            expandByScalar: function (e) {
                return this.min.addScalar(-e), this.max.addScalar(e), this;
            },
            containsPoint: function (e) {
                return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y);
            },
            containsBox: function (e) {
                return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
            },
            getParameter: function (e, t) {
                return void 0 === t && (console.warn("THREE.Box2: .getParameter() target is now required"), (t = new _n())), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y));
            },
            intersectsBox: function (e) {
                return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y);
            },
            clampPoint: function (e, t) {
                return void 0 === t && (console.warn("THREE.Box2: .clampPoint() target is now required"), (t = new _n())), t.copy(e).clamp(this.min, this.max);
            },
            distanceToPoint: function (e) {
                return ad.copy(e).clamp(this.min, this.max).sub(e).length();
            },
            intersect: function (e) {
                return this.min.max(e.min), this.max.min(e.max), this;
            },
            union: function (e) {
                return this.min.min(e.min), this.max.max(e.max), this;
            },
            translate: function (e) {
                return this.min.add(e), this.max.add(e), this;
            },
            equals: function (e) {
                return e.min.equals(this.min) && e.max.equals(this.max);
            },
        });
        var cd = new Sn(),
            ld = new Sn();
        function ud(e, t) {
            (this.start = void 0 !== e ? e : new Sn()), (this.end = void 0 !== t ? t : new Sn());
        }
        function hd(e) {
            oi.call(this), (this.material = e), (this.render = function () {});
        }
        Object.assign(ud.prototype, {
            set: function (e, t) {
                return this.start.copy(e), this.end.copy(t), this;
            },
            clone: function () {
                return new this.constructor().copy(this);
            },
            copy: function (e) {
                return this.start.copy(e.start), this.end.copy(e.end), this;
            },
            getCenter: function (e) {
                return void 0 === e && (console.warn("THREE.Line3: .getCenter() target is now required"), (e = new Sn())), e.addVectors(this.start, this.end).multiplyScalar(0.5);
            },
            delta: function (e) {
                return void 0 === e && (console.warn("THREE.Line3: .delta() target is now required"), (e = new Sn())), e.subVectors(this.end, this.start);
            },
            distanceSq: function () {
                return this.start.distanceToSquared(this.end);
            },
            distance: function () {
                return this.start.distanceTo(this.end);
            },
            at: function (e, t) {
                return void 0 === t && (console.warn("THREE.Line3: .at() target is now required"), (t = new Sn())), this.delta(t).multiplyScalar(e).add(this.start);
            },
            closestPointToPointParameter: function (e, t) {
                cd.subVectors(e, this.start), ld.subVectors(this.end, this.start);
                var n = ld.dot(ld),
                    i = ld.dot(cd) / n;
                return t && (i = xn.clamp(i, 0, 1)), i;
            },
            closestPointToPoint: function (e, t, n) {
                var i = this.closestPointToPointParameter(e, t);
                return void 0 === n && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), (n = new Sn())), this.delta(n).multiplyScalar(i).add(this.start);
            },
            applyMatrix4: function (e) {
                return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
            },
            equals: function (e) {
                return e.start.equals(this.start) && e.end.equals(this.end);
            },
        }),
            (hd.prototype = Object.create(oi.prototype)),
            (hd.prototype.constructor = hd),
            (hd.prototype.isImmediateRenderObject = !0);
        var dd = new Sn(),
            pd = new Sn(),
            fd = new An(),
            md = ["a", "b", "c"];
        function vd(e, t, n, i) {
            (this.object = e), (this.size = void 0 !== t ? t : 1);
            var r = void 0 !== n ? n : 16711680,
                o = void 0 !== i ? i : 1,
                a = 0,
                s = this.object.geometry;
            s && s.isGeometry ? (a = 3 * s.faces.length) : s && s.isBufferGeometry && (a = s.attributes.normal.count);
            var c = new Mr(),
                l = new dr(2 * a * 3, 3);
            c.setAttribute("position", l), uc.call(this, c, new tc({ color: r, linewidth: o })), (this.matrixAutoUpdate = !1), this.update();
        }
        (vd.prototype = Object.create(uc.prototype)),
            (vd.prototype.constructor = vd),
            (vd.prototype.update = function () {
                this.object.updateMatrixWorld(!0), fd.getNormalMatrix(this.object.matrixWorld);
                var e = this.object.matrixWorld,
                    t = this.geometry.attributes.position,
                    n = this.object.geometry;
                if (n && n.isGeometry)
                    for (var i = n.vertices, r = n.faces, o = 0, a = 0, s = r.length; a < s; a++)
                        for (var c = r[a], l = 0, u = c.vertexNormals.length; l < u; l++) {
                            var h = i[c[md[l]]],
                                d = c.vertexNormals[l];
                            dd.copy(h).applyMatrix4(e), pd.copy(d).applyMatrix3(fd).normalize().multiplyScalar(this.size).add(dd), t.setXYZ(o, dd.x, dd.y, dd.z), (o += 1), t.setXYZ(o, pd.x, pd.y, pd.z), (o += 1);
                        }
                else if (n && n.isBufferGeometry) {
                    var p = n.attributes.position,
                        f = n.attributes.normal;
                    for (o = 0, l = 0, u = p.count; l < u; l++)
                        dd.set(p.getX(l), p.getY(l), p.getZ(l)).applyMatrix4(e),
                            pd.set(f.getX(l), f.getY(l), f.getZ(l)),
                            pd.applyMatrix3(fd).normalize().multiplyScalar(this.size).add(dd),
                            t.setXYZ(o, dd.x, dd.y, dd.z),
                            (o += 1),
                            t.setXYZ(o, pd.x, pd.y, pd.z),
                            (o += 1);
                }
                t.needsUpdate = !0;
            });
        var gd = new Sn();
        function yd(e, t) {
            oi.call(this), (this.light = e), this.light.updateMatrixWorld(), (this.matrix = e.matrixWorld), (this.matrixAutoUpdate = !1), (this.color = t);
            for (var n = new Mr(), i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], r = 0, o = 1; r < 32; r++, o++) {
                var a = (r / 32) * Math.PI * 2,
                    s = (o / 32) * Math.PI * 2;
                i.push(Math.cos(a), Math.sin(a), 1, Math.cos(s), Math.sin(s), 1);
            }
            n.setAttribute("position", new dr(i, 3));
            var c = new tc({ fog: !1 });
            (this.cone = new uc(n, c)), this.add(this.cone), this.update();
        }
        (yd.prototype = Object.create(oi.prototype)),
            (yd.prototype.constructor = yd),
            (yd.prototype.dispose = function () {
                this.cone.geometry.dispose(), this.cone.material.dispose();
            }),
            (yd.prototype.update = function () {
                this.light.updateMatrixWorld();
                var e = this.light.distance ? this.light.distance : 1e3,
                    t = e * Math.tan(this.light.angle);
                this.cone.scale.set(t, t, e), gd.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(gd), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
            });
        var xd = new Sn(),
            _d = new Hn(),
            bd = new Hn();
        function wd(e) {
            for (
                var t = (function e(t) {
                        var n = [];
                        t && t.isBone && n.push(t);
                        for (var i = 0; i < t.children.length; i++) n.push.apply(n, e(t.children[i]));
                        return n;
                    })(e),
                    n = new Mr(),
                    i = [],
                    r = [],
                    o = new Zi(0, 0, 1),
                    a = new Zi(0, 1, 0),
                    s = 0;
                s < t.length;
                s++
            ) {
                var c = t[s];
                c.parent && c.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(o.r, o.g, o.b), r.push(a.r, a.g, a.b));
            }
            n.setAttribute("position", new dr(i, 3)), n.setAttribute("color", new dr(r, 3));
            var l = new tc({ vertexColors: M, depthTest: !1, depthWrite: !1, transparent: !0 });
            uc.call(this, n, l), (this.root = e), (this.bones = t), (this.matrix = e.matrixWorld), (this.matrixAutoUpdate = !1);
        }
        function Md(e, t, n) {
            (this.light = e), this.light.updateMatrixWorld(), (this.color = n);
            var i = new _l(t, 4, 2),
                r = new ir({ wireframe: !0, fog: !1 });
            Hr.call(this, i, r), (this.matrix = this.light.matrixWorld), (this.matrixAutoUpdate = !1), this.update();
        }
        function Sd(e, t) {
            (this.type = "RectAreaLightHelper"), (this.light = e), (this.color = t);
            var n = new Mr();
            n.setAttribute("position", new dr([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)), n.computeBoundingSphere();
            var i = new tc({ fog: !1 });
            sc.call(this, n, i);
            var r = new Mr();
            r.setAttribute("position", new dr([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)), r.computeBoundingSphere(), this.add(new Hr(r, new ir({ side: g, fog: !1 }))), this.update();
        }
        (wd.prototype = Object.create(uc.prototype)),
            (wd.prototype.constructor = wd),
            (wd.prototype.updateMatrixWorld = function (e) {
                var t = this.bones,
                    n = this.geometry,
                    i = n.getAttribute("position");
                bd.getInverse(this.root.matrixWorld);
                for (var r = 0, o = 0; r < t.length; r++) {
                    var a = t[r];
                    a.parent &&
                        a.parent.isBone &&
                        (_d.multiplyMatrices(bd, a.matrixWorld),
                        xd.setFromMatrixPosition(_d),
                        i.setXYZ(o, xd.x, xd.y, xd.z),
                        _d.multiplyMatrices(bd, a.parent.matrixWorld),
                        xd.setFromMatrixPosition(_d),
                        i.setXYZ(o + 1, xd.x, xd.y, xd.z),
                        (o += 2));
                }
                (n.getAttribute("position").needsUpdate = !0), oi.prototype.updateMatrixWorld.call(this, e);
            }),
            (Md.prototype = Object.create(Hr.prototype)),
            (Md.prototype.constructor = Md),
            (Md.prototype.dispose = function () {
                this.geometry.dispose(), this.material.dispose();
            }),
            (Md.prototype.update = function () {
                void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
            }),
            (Sd.prototype = Object.create(sc.prototype)),
            (Sd.prototype.constructor = Sd),
            (Sd.prototype.update = function () {
                if ((this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1), void 0 !== this.color)) this.material.color.set(this.color), this.children[0].material.color.set(this.color);
                else {
                    this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
                    var e = this.material.color,
                        t = Math.max(e.r, e.g, e.b);
                    t > 1 && e.multiplyScalar(1 / t), this.children[0].material.color.copy(this.material.color);
                }
            }),
            (Sd.prototype.dispose = function () {
                this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
            });
        var Ed = new Sn(),
            Td = new Zi(),
            Ad = new Zi();
        function Ld(e, t, n) {
            oi.call(this), (this.light = e), this.light.updateMatrixWorld(), (this.matrix = e.matrixWorld), (this.matrixAutoUpdate = !1), (this.color = n);
            var i = new Pc(t);
            i.rotateY(0.5 * Math.PI), (this.material = new ir({ wireframe: !0, fog: !1 })), void 0 === this.color && (this.material.vertexColors = M);
            var r = i.getAttribute("position"),
                o = new Float32Array(3 * r.count);
            i.setAttribute("color", new rr(o, 3)), this.add(new Hr(i, this.material)), this.update();
        }
        function Cd(e, t) {
            (this.lightProbe = e), (this.size = t);
            var n = { GAMMA_OUTPUT: "" },
                i = new no({
                    defines: n,
                    uniforms: { sh: { value: this.lightProbe.sh.coefficients }, intensity: { value: this.lightProbe.intensity } },
                    vertexShader: ["varying vec3 vNormal;", "void main() {", "\tvNormal = normalize( normalMatrix * normal );", "\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
                    fragmentShader: [
                        "#define RECIPROCAL_PI 0.318309886",
                        "vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {",
                        "\t// matrix is assumed to be orthogonal",
                        "\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );",
                        "}",
                        "vec3 linearToOutput( in vec3 a ) {",
                        "\t#ifdef GAMMA_OUTPUT",
                        "\t\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );",
                        "\t#else",
                        "\t\treturn a;",
                        "\t#endif",
                        "}",
                        "// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf",
                        "vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {",
                        "\t// normal is assumed to have unit length",
                        "\tfloat x = normal.x, y = normal.y, z = normal.z;",
                        "\t// band 0",
                        "\tvec3 result = shCoefficients[ 0 ] * 0.886227;",
                        "\t// band 1",
                        "\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;",
                        "\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;",
                        "\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;",
                        "\t// band 2",
                        "\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;",
                        "\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;",
                        "\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );",
                        "\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;",
                        "\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );",
                        "\treturn result;",
                        "}",
                        "uniform vec3 sh[ 9 ]; // sh coefficients",
                        "uniform float intensity; // light probe intensity",
                        "varying vec3 vNormal;",
                        "void main() {",
                        "\tvec3 normal = normalize( vNormal );",
                        "\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );",
                        "\tvec3 irradiance = shGetIrradianceAt( worldNormal, sh );",
                        "\tvec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;",
                        "\toutgoingLight = linearToOutput( outgoingLight );",
                        "\tgl_FragColor = vec4( outgoingLight, 1.0 );",
                        "}",
                    ].join("\n"),
                }),
                r = new _l(1, 32, 16);
            Hr.call(this, r, i), this.onBeforeRender();
        }
        function Rd(e, t, n, i) {
            (e = e || 10), (t = t || 10), (n = new Zi(void 0 !== n ? n : 4473924)), (i = new Zi(void 0 !== i ? i : 8947848));
            for (var r = t / 2, o = e / t, a = e / 2, s = [], c = [], l = 0, u = 0, h = -a; l <= t; l++, h += o) {
                s.push(-a, 0, h, a, 0, h), s.push(h, 0, -a, h, 0, a);
                var d = l === r ? n : i;
                d.toArray(c, u), (u += 3), d.toArray(c, u), (u += 3), d.toArray(c, u), (u += 3), d.toArray(c, u), (u += 3);
            }
            var p = new Mr();
            p.setAttribute("position", new dr(s, 3)), p.setAttribute("color", new dr(c, 3));
            var f = new tc({ vertexColors: M });
            uc.call(this, p, f);
        }
        function Pd(e, t, n, i, r, o) {
            (e = e || 10), (t = t || 16), (n = n || 8), (i = i || 64), (r = new Zi(void 0 !== r ? r : 4473924)), (o = new Zi(void 0 !== o ? o : 8947848));
            var a,
                s,
                c,
                l,
                u,
                h,
                d,
                p = [],
                f = [];
            for (l = 0; l <= t; l++) (c = (l / t) * (2 * Math.PI)), (a = Math.sin(c) * e), (s = Math.cos(c) * e), p.push(0, 0, 0), p.push(a, 0, s), (d = 1 & l ? r : o), f.push(d.r, d.g, d.b), f.push(d.r, d.g, d.b);
            for (l = 0; l <= n; l++)
                for (d = 1 & l ? r : o, h = e - (e / n) * l, u = 0; u < i; u++)
                    (c = (u / i) * (2 * Math.PI)),
                        (a = Math.sin(c) * h),
                        (s = Math.cos(c) * h),
                        p.push(a, 0, s),
                        f.push(d.r, d.g, d.b),
                        (c = ((u + 1) / i) * (2 * Math.PI)),
                        (a = Math.sin(c) * h),
                        (s = Math.cos(c) * h),
                        p.push(a, 0, s),
                        f.push(d.r, d.g, d.b);
            var m = new Mr();
            m.setAttribute("position", new dr(p, 3)), m.setAttribute("color", new dr(f, 3));
            var v = new tc({ vertexColors: M });
            uc.call(this, m, v);
        }
        function Od(e, t, n, i) {
            (this.audio = e), (this.range = t || 1), (this.divisionsInnerAngle = n || 16), (this.divisionsOuterAngle = i || 2);
            var r = new Mr(),
                o = this.divisionsInnerAngle + 2 * this.divisionsOuterAngle,
                a = new Float32Array(3 * (3 * o + 3));
            r.setAttribute("position", new rr(a, 3));
            var s = new tc({ color: 65280 }),
                c = new tc({ color: 16776960 });
            sc.call(this, r, [c, s]), this.update();
        }
        (Ld.prototype = Object.create(oi.prototype)),
            (Ld.prototype.constructor = Ld),
            (Ld.prototype.dispose = function () {
                this.children[0].geometry.dispose(), this.children[0].material.dispose();
            }),
            (Ld.prototype.update = function () {
                var e = this.children[0];
                if (void 0 !== this.color) this.material.color.set(this.color);
                else {
                    var t = e.geometry.getAttribute("color");
                    Td.copy(this.light.color), Ad.copy(this.light.groundColor);
                    for (var n = 0, i = t.count; n < i; n++) {
                        var r = n < i / 2 ? Td : Ad;
                        t.setXYZ(n, r.r, r.g, r.b);
                    }
                    t.needsUpdate = !0;
                }
                e.lookAt(Ed.setFromMatrixPosition(this.light.matrixWorld).negate());
            }),
            (Cd.prototype = Object.create(Hr.prototype)),
            (Cd.prototype.constructor = Cd),
            (Cd.prototype.dispose = function () {
                this.geometry.dispose(), this.material.dispose();
            }),
            (Cd.prototype.onBeforeRender = function () {
                this.position.copy(this.lightProbe.position), this.scale.set(1, 1, 1).multiplyScalar(this.size), (this.material.uniforms.intensity.value = this.lightProbe.intensity);
            }),
            (Rd.prototype = Object.assign(Object.create(uc.prototype), {
                constructor: Rd,
                copy: function (e) {
                    return uc.prototype.copy.call(this, e), this.geometry.copy(e.geometry), this.material.copy(e.material), this;
                },
                clone: function () {
                    return new this.constructor().copy(this);
                },
            })),
            (Pd.prototype = Object.create(uc.prototype)),
            (Pd.prototype.constructor = Pd),
            (Od.prototype = Object.create(sc.prototype)),
            (Od.prototype.constructor = Od),
            (Od.prototype.update = function () {
                var e,
                    t,
                    n = this.audio,
                    i = this.range,
                    r = this.divisionsInnerAngle,
                    o = this.divisionsOuterAngle,
                    a = xn.degToRad(n.panner.coneInnerAngle),
                    s = xn.degToRad(n.panner.coneOuterAngle),
                    c = a / 2,
                    l = s / 2,
                    u = 0,
                    h = 0,
                    d = this.geometry,
                    p = d.attributes.position;
                function f(n, r, o, a) {
                    var s = (r - n) / o;
                    for (p.setXYZ(u, 0, 0, 0), h++, e = n; e < r; e += s)
                        (t = u + h), p.setXYZ(t, Math.sin(e) * i, 0, Math.cos(e) * i), p.setXYZ(t + 1, Math.sin(Math.min(e + s, r)) * i, 0, Math.cos(Math.min(e + s, r)) * i), p.setXYZ(t + 2, 0, 0, 0), (h += 3);
                    d.addGroup(u, h, a), (u += h), (h = 0);
                }
                d.clearGroups(), f(-l, -c, o, 0), f(-c, c, r, 1), f(c, l, o, 0), (p.needsUpdate = !0), a === s && (this.material[0].visible = !1);
            }),
            (Od.prototype.dispose = function () {
                this.geometry.dispose(), this.material[0].dispose(), this.material[1].dispose();
            });
        var Dd = new Sn(),
            Id = new Sn(),
            Nd = new An();
        function Ud(e, t, n, i) {
            (this.object = e), (this.size = void 0 !== t ? t : 1);
            var r = void 0 !== n ? n : 16776960,
                o = void 0 !== i ? i : 1,
                a = 0,
                s = this.object.geometry;
            s && s.isGeometry ? (a = s.faces.length) : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
            var c = new Mr(),
                l = new dr(2 * a * 3, 3);
            c.setAttribute("position", l), uc.call(this, c, new tc({ color: r, linewidth: o })), (this.matrixAutoUpdate = !1), this.update();
        }
        (Ud.prototype = Object.create(uc.prototype)),
            (Ud.prototype.constructor = Ud),
            (Ud.prototype.update = function () {
                this.object.updateMatrixWorld(!0), Nd.getNormalMatrix(this.object.matrixWorld);
                for (var e = this.object.matrixWorld, t = this.geometry.attributes.position, n = this.object.geometry, i = n.vertices, r = n.faces, o = 0, a = 0, s = r.length; a < s; a++) {
                    var c = r[a],
                        l = c.normal;
                    Dd.copy(i[c.a]).add(i[c.b]).add(i[c.c]).divideScalar(3).applyMatrix4(e),
                        Id.copy(l).applyMatrix3(Nd).normalize().multiplyScalar(this.size).add(Dd),
                        t.setXYZ(o, Dd.x, Dd.y, Dd.z),
                        (o += 1),
                        t.setXYZ(o, Id.x, Id.y, Id.z),
                        (o += 1);
                }
                t.needsUpdate = !0;
            });
        var Bd = new Sn(),
            zd = new Sn(),
            Fd = new Sn();
        function Gd(e, t, n) {
            oi.call(this), (this.light = e), this.light.updateMatrixWorld(), (this.matrix = e.matrixWorld), (this.matrixAutoUpdate = !1), (this.color = n), void 0 === t && (t = 1);
            var i = new Mr();
            i.setAttribute("position", new dr([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3));
            var r = new tc({ fog: !1 });
            (this.lightPlane = new sc(i, r)), this.add(this.lightPlane), (i = new Mr()).setAttribute("position", new dr([0, 0, 0, 0, 0, 1], 3)), (this.targetLine = new sc(i, r)), this.add(this.targetLine), this.update();
        }
        (Gd.prototype = Object.create(oi.prototype)),
            (Gd.prototype.constructor = Gd),
            (Gd.prototype.dispose = function () {
                this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
            }),
            (Gd.prototype.update = function () {
                Bd.setFromMatrixPosition(this.light.matrixWorld),
                    zd.setFromMatrixPosition(this.light.target.matrixWorld),
                    Fd.subVectors(zd, Bd),
                    this.lightPlane.lookAt(zd),
                    void 0 !== this.color
                        ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color))
                        : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)),
                    this.targetLine.lookAt(zd),
                    (this.targetLine.scale.z = Fd.length());
            });
        var Hd = new Sn(),
            Vd = new io();
        function kd(e) {
            var t = new Mr(),
                n = new tc({ color: 16777215, vertexColors: w }),
                i = [],
                r = [],
                o = {},
                a = new Zi(16755200),
                s = new Zi(16711680),
                c = new Zi(43775),
                l = new Zi(16777215),
                u = new Zi(3355443);
            function h(e, t, n) {
                d(e, n), d(t, n);
            }
            function d(e, t) {
                i.push(0, 0, 0), r.push(t.r, t.g, t.b), void 0 === o[e] && (o[e] = []), o[e].push(i.length / 3 - 1);
            }
            h("n1", "n2", a),
                h("n2", "n4", a),
                h("n4", "n3", a),
                h("n3", "n1", a),
                h("f1", "f2", a),
                h("f2", "f4", a),
                h("f4", "f3", a),
                h("f3", "f1", a),
                h("n1", "f1", a),
                h("n2", "f2", a),
                h("n3", "f3", a),
                h("n4", "f4", a),
                h("p", "n1", s),
                h("p", "n2", s),
                h("p", "n3", s),
                h("p", "n4", s),
                h("u1", "u2", c),
                h("u2", "u3", c),
                h("u3", "u1", c),
                h("c", "t", l),
                h("p", "c", u),
                h("cn1", "cn2", u),
                h("cn3", "cn4", u),
                h("cf1", "cf2", u),
                h("cf3", "cf4", u),
                t.setAttribute("position", new dr(i, 3)),
                t.setAttribute("color", new dr(r, 3)),
                uc.call(this, t, n),
                (this.camera = e),
                this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
                (this.matrix = e.matrixWorld),
                (this.matrixAutoUpdate = !1),
                (this.pointMap = o),
                this.update();
        }
        function jd(e, t, n, i, r, o, a) {
            Hd.set(r, o, a).unproject(i);
            var s = t[e];
            if (void 0 !== s) for (var c = n.getAttribute("position"), l = 0, u = s.length; l < u; l++) c.setXYZ(s[l], Hd.x, Hd.y, Hd.z);
        }
        (kd.prototype = Object.create(uc.prototype)),
            (kd.prototype.constructor = kd),
            (kd.prototype.update = function () {
                var e = this.geometry,
                    t = this.pointMap;
                Vd.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
                    jd("c", t, e, Vd, 0, 0, -1),
                    jd("t", t, e, Vd, 0, 0, 1),
                    jd("n1", t, e, Vd, -1, -1, -1),
                    jd("n2", t, e, Vd, 1, -1, -1),
                    jd("n3", t, e, Vd, -1, 1, -1),
                    jd("n4", t, e, Vd, 1, 1, -1),
                    jd("f1", t, e, Vd, -1, -1, 1),
                    jd("f2", t, e, Vd, 1, -1, 1),
                    jd("f3", t, e, Vd, -1, 1, 1),
                    jd("f4", t, e, Vd, 1, 1, 1),
                    jd("u1", t, e, Vd, 0.7, 1.1, -1),
                    jd("u2", t, e, Vd, -0.7, 1.1, -1),
                    jd("u3", t, e, Vd, 0, 2, -1),
                    jd("cf1", t, e, Vd, -1, 0, 1),
                    jd("cf2", t, e, Vd, 1, 0, 1),
                    jd("cf3", t, e, Vd, 0, -1, 1),
                    jd("cf4", t, e, Vd, 0, 1, 1),
                    jd("cn1", t, e, Vd, -1, 0, -1),
                    jd("cn2", t, e, Vd, 1, 0, -1),
                    jd("cn3", t, e, Vd, 0, -1, -1),
                    jd("cn4", t, e, Vd, 0, 1, -1),
                    (e.getAttribute("position").needsUpdate = !0);
            });
        var Wd = new _i();
        function qd(e, t) {
            (this.object = e), void 0 === t && (t = 16776960);
            var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                i = new Float32Array(24),
                r = new Mr();
            r.setIndex(new rr(n, 1)), r.setAttribute("position", new rr(i, 3)), uc.call(this, r, new tc({ color: t })), (this.matrixAutoUpdate = !1), this.update();
        }
        function Xd(e, t) {
            (this.type = "Box3Helper"), (this.box = e), (t = t || 16776960);
            var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                i = new Mr();
            i.setIndex(new rr(n, 1)),
                i.setAttribute("position", new dr([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)),
                uc.call(this, i, new tc({ color: t })),
                this.geometry.computeBoundingSphere();
        }
        function Yd(e, t, n) {
            (this.type = "PlaneHelper"), (this.plane = e), (this.size = void 0 === t ? 1 : t);
            var i = void 0 !== n ? n : 16776960,
                r = new Mr();
            r.setAttribute("position", new dr([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), r.computeBoundingSphere(), sc.call(this, r, new tc({ color: i }));
            var o = new Mr();
            o.setAttribute("position", new dr([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), o.computeBoundingSphere(), this.add(new Hr(o, new ir({ color: i, opacity: 0.2, transparent: !0, depthWrite: !1 })));
        }
        (qd.prototype = Object.create(uc.prototype)),
            (qd.prototype.constructor = qd),
            (qd.prototype.update = function (e) {
                if ((void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && Wd.setFromObject(this.object), !Wd.isEmpty())) {
                    var t = Wd.min,
                        n = Wd.max,
                        i = this.geometry.attributes.position,
                        r = i.array;
                    (r[0] = n.x),
                        (r[1] = n.y),
                        (r[2] = n.z),
                        (r[3] = t.x),
                        (r[4] = n.y),
                        (r[5] = n.z),
                        (r[6] = t.x),
                        (r[7] = t.y),
                        (r[8] = n.z),
                        (r[9] = n.x),
                        (r[10] = t.y),
                        (r[11] = n.z),
                        (r[12] = n.x),
                        (r[13] = n.y),
                        (r[14] = t.z),
                        (r[15] = t.x),
                        (r[16] = n.y),
                        (r[17] = t.z),
                        (r[18] = t.x),
                        (r[19] = t.y),
                        (r[20] = t.z),
                        (r[21] = n.x),
                        (r[22] = t.y),
                        (r[23] = t.z),
                        (i.needsUpdate = !0),
                        this.geometry.computeBoundingSphere();
                }
            }),
            (qd.prototype.setFromObject = function (e) {
                return (this.object = e), this.update(), this;
            }),
            (qd.prototype.copy = function (e) {
                return uc.prototype.copy.call(this, e), (this.object = e.object), this;
            }),
            (qd.prototype.clone = function () {
                return new this.constructor().copy(this);
            }),
            (Xd.prototype = Object.create(uc.prototype)),
            (Xd.prototype.constructor = Xd),
            (Xd.prototype.updateMatrixWorld = function (e) {
                var t = this.box;
                t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(0.5), oi.prototype.updateMatrixWorld.call(this, e));
            }),
            (Yd.prototype = Object.create(sc.prototype)),
            (Yd.prototype.constructor = Yd),
            (Yd.prototype.updateMatrixWorld = function (e) {
                var t = -this.plane.constant;
                Math.abs(t) < 1e-8 && (t = 1e-8), this.scale.set(0.5 * this.size, 0.5 * this.size, t), (this.children[0].material.side = t < 0 ? g : v), this.lookAt(this.plane.normal), oi.prototype.updateMatrixWorld.call(this, e);
            });
        var Jd,
            Zd,
            Kd = new Sn();
        function Qd(e, t, n, i, r, o) {
            oi.call(this),
                void 0 === e && (e = new Sn(0, 0, 1)),
                void 0 === t && (t = new Sn(0, 0, 0)),
                void 0 === n && (n = 1),
                void 0 === i && (i = 16776960),
                void 0 === r && (r = 0.2 * n),
                void 0 === o && (o = 0.2 * r),
                void 0 === Jd && ((Jd = new Mr()).setAttribute("position", new dr([0, 0, 0, 0, 1, 0], 3)), (Zd = new Rl(0, 0.5, 1, 5, 1)).translate(0, -0.5, 0)),
                this.position.copy(t),
                (this.line = new sc(Jd, new tc({ color: i }))),
                (this.line.matrixAutoUpdate = !1),
                this.add(this.line),
                (this.cone = new Hr(Zd, new ir({ color: i }))),
                (this.cone.matrixAutoUpdate = !1),
                this.add(this.cone),
                this.setDirection(e),
                this.setLength(n, r, o);
        }
        function $d(e) {
            var t = [0, 0, 0, (e = e || 1), 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
                n = new Mr();
            n.setAttribute("position", new dr(t, 3)), n.setAttribute("color", new dr([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1], 3));
            var i = new tc({ vertexColors: M });
            uc.call(this, n, i);
        }
        function ep(e, t, n, i, r, o, a) {
            return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new er(e, t, n, r, o, a);
        }
        (Qd.prototype = Object.create(oi.prototype)),
            (Qd.prototype.constructor = Qd),
            (Qd.prototype.setDirection = function (e) {
                if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
                else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
                else {
                    Kd.set(e.z, 0, -e.x).normalize();
                    var t = Math.acos(e.y);
                    this.quaternion.setFromAxisAngle(Kd, t);
                }
            }),
            (Qd.prototype.setLength = function (e, t, n) {
                void 0 === t && (t = 0.2 * e), void 0 === n && (n = 0.2 * t), this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), (this.cone.position.y = e), this.cone.updateMatrix();
            }),
            (Qd.prototype.setColor = function (e) {
                this.line.material.color.set(e), this.cone.material.color.set(e);
            }),
            (Qd.prototype.copy = function (e) {
                return oi.prototype.copy.call(this, e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this;
            }),
            (Qd.prototype.clone = function () {
                return new this.constructor().copy(this);
            }),
            ($d.prototype = Object.create(uc.prototype)),
            ($d.prototype.constructor = $d);
        var tp = 0,
            np = 1;
        function ip(e) {
            return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), e;
        }
        function rp(e) {
            return (
                void 0 === e && (e = []),
                console.warn("THREE.MultiMaterial has been removed. Use an Array instead."),
                (e.isMultiMaterial = !0),
                (e.materials = e),
                (e.clone = function () {
                    return e.slice();
                }),
                e
            );
        }
        function op(e, t) {
            return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new gc(e, t);
        }
        function ap(e) {
            return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Gs(e);
        }
        function sp(e, t) {
            return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new gc(e, t);
        }
        function cp(e) {
            return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new dc(e);
        }
        function lp(e) {
            return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new dc(e);
        }
        function up(e) {
            return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new dc(e);
        }
        function hp(e, t, n) {
            return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new Sn(e, t, n);
        }
        function dp(e, t) {
            return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new rr(e, t).setDynamic(!0);
        }
        function pp(e, t) {
            return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new or(e, t);
        }
        function fp(e, t) {
            return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new ar(e, t);
        }
        function mp(e, t) {
            return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new sr(e, t);
        }
        function vp(e, t) {
            return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new cr(e, t);
        }
        function gp(e, t) {
            return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new lr(e, t);
        }
        function yp(e, t) {
            return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new ur(e, t);
        }
        function xp(e, t) {
            return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new hr(e, t);
        }
        function _p(e, t) {
            return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new dr(e, t);
        }
        function bp(e, t) {
            return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new pr(e, t);
        }
        function wp(e) {
            console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Lu.call(this, e), (this.type = "catmullrom"), (this.closed = !0);
        }
        function Mp(e) {
            console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Lu.call(this, e), (this.type = "catmullrom");
        }
        function Sp(e) {
            console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), Lu.call(this, e), (this.type = "catmullrom");
        }
        function Ep(e) {
            return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new $d(e);
        }
        function Tp(e, t) {
            return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new qd(e, t);
        }
        function Ap(e, t) {
            return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new uc(new Ll(e.geometry), new tc({ color: void 0 !== t ? t : 16777215 }));
        }
        function Lp(e, t) {
            return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new uc(new Mc(e.geometry), new tc({ color: void 0 !== t ? t : 16777215 }));
        }
        function Cp(e) {
            return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new pu(e);
        }
        function Rp(e) {
            return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new vu(e);
        }
        (_u.create = function (e, t) {
            return console.log("THREE.Curve.create() has been deprecated"), (e.prototype = Object.create(_u.prototype)), (e.prototype.constructor = e), (e.prototype.getPoint = t), e;
        }),
            Object.assign(Gu.prototype, {
                createPointsGeometry: function (e) {
                    console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    var t = this.getPoints(e);
                    return this.createGeometry(t);
                },
                createSpacedPointsGeometry: function (e) {
                    console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    var t = this.getSpacedPoints(e);
                    return this.createGeometry(t);
                },
                createGeometry: function (e) {
                    console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    for (var t = new Yr(), n = 0, i = e.length; n < i; n++) {
                        var r = e[n];
                        t.vertices.push(new Sn(r.x, r.y, r.z || 0));
                    }
                    return t;
                },
            }),
            Object.assign(Hu.prototype, {
                fromPoints: function (e) {
                    return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(e);
                },
            }),
            (wp.prototype = Object.create(Lu.prototype)),
            (Mp.prototype = Object.create(Lu.prototype)),
            (Sp.prototype = Object.create(Lu.prototype)),
            Object.assign(Sp.prototype, {
                initFromArray: function () {
                    console.error("THREE.Spline: .initFromArray() has been removed.");
                },
                getControlPointsArray: function () {
                    console.error("THREE.Spline: .getControlPointsArray() has been removed.");
                },
                reparametrizeByArcLength: function () {
                    console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.");
                },
            }),
            (Rd.prototype.setColors = function () {
                console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
            }),
            (wd.prototype.update = function () {
                console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
            }),
            Object.assign(hu.prototype, {
                extractUrlBase: function (e) {
                    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), nh.extractUrlBase(e);
                },
            }),
            (hu.Handlers = {
                add: function () {
                    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
                },
                get: function () {
                    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
                },
            }),
            Object.assign(sh.prototype, {
                setTexturePath: function (e) {
                    return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(e);
                },
            }),
            Object.assign(sd.prototype, {
                center: function (e) {
                    return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(e);
                },
                empty: function () {
                    return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty();
                },
                isIntersectionBox: function (e) {
                    return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e);
                },
                size: function (e) {
                    return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(e);
                },
            }),
            Object.assign(_i.prototype, {
                center: function (e) {
                    return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e);
                },
                empty: function () {
                    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
                },
                isIntersectionBox: function (e) {
                    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e);
                },
                isIntersectionSphere: function (e) {
                    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e);
                },
                size: function (e) {
                    return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(e);
                },
            }),
            (ud.prototype.center = function (e) {
                return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(e);
            }),
            Object.assign(xn, {
                random16: function () {
                    return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random();
                },
                nearestPowerOfTwo: function (e) {
                    return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), xn.floorPowerOfTwo(e);
                },
                nextPowerOfTwo: function (e) {
                    return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), xn.ceilPowerOfTwo(e);
                },
            }),
            Object.assign(An.prototype, {
                flattenToArrayOffset: function (e, t) {
                    return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t);
                },
                multiplyVector3: function (e) {
                    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this);
                },
                multiplyVector3Array: function () {
                    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
                },
                applyToBuffer: function (e) {
                    return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e);
                },
                applyToVector3Array: function () {
                    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
                },
            }),
            Object.assign(Hn.prototype, {
                extractPosition: function (e) {
                    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e);
                },
                flattenToArrayOffset: function (e, t) {
                    return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t);
                },
                getPosition: function () {
                    return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), new Sn().setFromMatrixColumn(this, 3);
                },
                setRotationFromQuaternion: function (e) {
                    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e);
                },
                multiplyToArray: function () {
                    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
                },
                multiplyVector3: function (e) {
                    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this);
                },
                multiplyVector4: function (e) {
                    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this);
                },
                multiplyVector3Array: function () {
                    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
                },
                rotateAxis: function (e) {
                    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this);
                },
                crossVector: function (e) {
                    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this);
                },
                translate: function () {
                    console.error("THREE.Matrix4: .translate() has been removed.");
                },
                rotateX: function () {
                    console.error("THREE.Matrix4: .rotateX() has been removed.");
                },
                rotateY: function () {
                    console.error("THREE.Matrix4: .rotateY() has been removed.");
                },
                rotateZ: function () {
                    console.error("THREE.Matrix4: .rotateZ() has been removed.");
                },
                rotateByAxis: function () {
                    console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
                },
                applyToBuffer: function (e) {
                    return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e);
                },
                applyToVector3Array: function () {
                    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
                },
                makeFrustum: function (e, t, n, i, r, o) {
                    return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(e, t, i, n, r, o);
                },
            }),
            (Ni.prototype.isIntersectionLine = function (e) {
                return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e);
            }),
            (bn.prototype.multiplyVector3 = function (e) {
                return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this);
            }),
            Object.assign(Pi.prototype, {
                isIntersectionBox: function (e) {
                    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e);
                },
                isIntersectionPlane: function (e) {
                    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e);
                },
                isIntersectionSphere: function (e) {
                    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e);
                },
            }),
            Object.assign(qi.prototype, {
                area: function () {
                    return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea();
                },
                barycoordFromPoint: function (e, t) {
                    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(e, t);
                },
                midpoint: function (e) {
                    return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(e);
                },
                normal: function (e) {
                    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(e);
                },
                plane: function (e) {
                    return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(e);
                },
            }),
            Object.assign(qi, {
                barycoordFromPoint: function (e, t, n, i, r) {
                    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), qi.getBarycoord(e, t, n, i, r);
                },
                normal: function (e, t, n, i) {
                    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), qi.getNormal(e, t, n, i);
                },
            }),
            Object.assign(Vu.prototype, {
                extractAllPoints: function (e) {
                    return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(e);
                },
                extrude: function (e) {
                    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new pl(this, e);
                },
                makeGeometry: function (e) {
                    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new El(this, e);
                },
            }),
            Object.assign(_n.prototype, {
                fromAttribute: function (e, t, n) {
                    return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n);
                },
                distanceToManhattan: function (e) {
                    return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e);
                },
                lengthManhattan: function () {
                    return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
                },
            }),
            Object.assign(Sn.prototype, {
                setEulerFromRotationMatrix: function () {
                    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
                },
                setEulerFromQuaternion: function () {
                    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
                },
                getPositionFromMatrix: function (e) {
                    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e);
                },
                getScaleFromMatrix: function (e) {
                    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e);
                },
                getColumnFromMatrix: function (e, t) {
                    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e);
                },
                applyProjection: function (e) {
                    return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(e);
                },
                fromAttribute: function (e, t, n) {
                    return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n);
                },
                distanceToManhattan: function (e) {
                    return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e);
                },
                lengthManhattan: function () {
                    return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
                },
            }),
            Object.assign(Pn.prototype, {
                fromAttribute: function (e, t, n) {
                    return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n);
                },
                lengthManhattan: function () {
                    return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
                },
            }),
            Object.assign(Yr.prototype, {
                computeTangents: function () {
                    console.error("THREE.Geometry: .computeTangents() has been removed.");
                },
                computeLineDistances: function () {
                    console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.");
                },
            }),
            Object.assign(oi.prototype, {
                getChildByName: function (e) {
                    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e);
                },
                renderDepth: function () {
                    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
                },
                translate: function (e, t) {
                    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e);
                },
                getWorldRotation: function () {
                    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
                },
            }),
            Object.defineProperties(oi.prototype, {
                eulerOrder: {
                    get: function () {
                        return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
                    },
                    set: function (e) {
                        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), (this.rotation.order = e);
                    },
                },
                useQuaternion: {
                    get: function () {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
                    },
                    set: function () {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
                    },
                },
            }),
            Object.defineProperties(js.prototype, {
                objects: {
                    get: function () {
                        return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels;
                    },
                },
            }),
            Object.defineProperty(Ys.prototype, "useVertexTexture", {
                get: function () {
                    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
                },
                set: function () {
                    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
                },
            }),
            (Ws.prototype.initBones = function () {
                console.error("THREE.SkinnedMesh: initBones() has been removed.");
            }),
            Object.defineProperty(_u.prototype, "__arcLengthDivisions", {
                get: function () {
                    return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions;
                },
                set: function (e) {
                    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), (this.arcLengthDivisions = e);
                },
            }),
            (ro.prototype.setLens = function (e, t) {
                console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== t && (this.filmGauge = t), this.setFocalLength(e);
            }),
            Object.defineProperties(ku.prototype, {
                onlyShadow: {
                    set: function () {
                        console.warn("THREE.Light: .onlyShadow has been removed.");
                    },
                },
                shadowCameraFov: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), (this.shadow.camera.fov = e);
                    },
                },
                shadowCameraLeft: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), (this.shadow.camera.left = e);
                    },
                },
                shadowCameraRight: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), (this.shadow.camera.right = e);
                    },
                },
                shadowCameraTop: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), (this.shadow.camera.top = e);
                    },
                },
                shadowCameraBottom: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), (this.shadow.camera.bottom = e);
                    },
                },
                shadowCameraNear: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), (this.shadow.camera.near = e);
                    },
                },
                shadowCameraFar: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), (this.shadow.camera.far = e);
                    },
                },
                shadowCameraVisible: {
                    set: function () {
                        console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
                    },
                },
                shadowBias: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowBias is now .shadow.bias."), (this.shadow.bias = e);
                    },
                },
                shadowDarkness: {
                    set: function () {
                        console.warn("THREE.Light: .shadowDarkness has been removed.");
                    },
                },
                shadowMapWidth: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), (this.shadow.mapSize.width = e);
                    },
                },
                shadowMapHeight: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), (this.shadow.mapSize.height = e);
                    },
                },
            }),
            Object.defineProperties(rr.prototype, {
                length: {
                    get: function () {
                        return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length;
                    },
                },
                dynamic: {
                    get: function () {
                        return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === cn;
                    },
                    set: function () {
                        console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(cn);
                    },
                },
            }),
            Object.assign(rr.prototype, {
                setDynamic: function (e) {
                    return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === e ? cn : sn), this;
                },
                copyIndicesArray: function () {
                    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
                },
                setArray: function () {
                    console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
                },
            }),
            Object.assign(Mr.prototype, {
                addIndex: function (e) {
                    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e);
                },
                addAttribute: function (e, t) {
                    return (
                        console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),
                        (t && t.isBufferAttribute) || (t && t.isInterleavedBufferAttribute)
                            ? "index" === e
                                ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(t), this)
                                : this.setAttribute(e, t)
                            : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(e, new rr(arguments[1], arguments[2])))
                    );
                },
                addDrawCall: function (e, t, n) {
                    void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e, t);
                },
                clearDrawCalls: function () {
                    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups();
                },
                computeTangents: function () {
                    console.warn("THREE.BufferGeometry: .computeTangents() has been removed.");
                },
                computeOffsets: function () {
                    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
                },
                removeAttribute: function (e) {
                    return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(e);
                },
            }),
            Object.defineProperties(Mr.prototype, {
                drawcalls: {
                    get: function () {
                        return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups;
                    },
                },
                offsets: {
                    get: function () {
                        return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups;
                    },
                },
            }),
            Object.defineProperties(Es.prototype, {
                dynamic: {
                    get: function () {
                        return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.usage === cn;
                    },
                    set: function (e) {
                        console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.setUsage(e);
                    },
                },
            }),
            Object.assign(Es.prototype, {
                setDynamic: function (e) {
                    return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === e ? cn : sn), this;
                },
                setArray: function () {
                    console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
                },
            }),
            Object.assign(fl.prototype, {
                getArrays: function () {
                    console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.");
                },
                addShapeList: function () {
                    console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.");
                },
                addShape: function () {
                    console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.");
                },
            }),
            Object.defineProperties($h.prototype, {
                dynamic: {
                    set: function () {
                        console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.");
                    },
                },
                onUpdate: {
                    value: function () {
                        return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this;
                    },
                },
            }),
            Object.defineProperties(nr.prototype, {
                wrapAround: {
                    get: function () {
                        console.warn("THREE.Material: .wrapAround has been removed.");
                    },
                    set: function () {
                        console.warn("THREE.Material: .wrapAround has been removed.");
                    },
                },
                overdraw: {
                    get: function () {
                        console.warn("THREE.Material: .overdraw has been removed.");
                    },
                    set: function () {
                        console.warn("THREE.Material: .overdraw has been removed.");
                    },
                },
                wrapRGB: {
                    get: function () {
                        return console.warn("THREE.Material: .wrapRGB has been removed."), new Zi();
                    },
                },
                shading: {
                    get: function () {
                        console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
                    },
                    set: function (e) {
                        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), (this.flatShading = e === x);
                    },
                },
                stencilMask: {
                    get: function () {
                        return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask;
                    },
                    set: function (e) {
                        console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), (this.stencilFuncMask = e);
                    },
                },
            }),
            Object.defineProperties(Gl.prototype, {
                metal: {
                    get: function () {
                        return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1;
                    },
                    set: function () {
                        console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
                    },
                },
            }),
            Object.defineProperties(no.prototype, {
                derivatives: {
                    get: function () {
                        return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives;
                    },
                    set: function (e) {
                        console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), (this.extensions.derivatives = e);
                    },
                },
            }),
            Object.assign(ws.prototype, {
                clearTarget: function (e, t, n, i) {
                    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(e), this.clear(t, n, i);
                },
                animate: function (e) {
                    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(e);
                },
                getCurrentRenderTarget: function () {
                    return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget();
                },
                getMaxAnisotropy: function () {
                    return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy();
                },
                getPrecision: function () {
                    return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision;
                },
                resetGLState: function () {
                    return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset();
                },
                supportsFloatTextures: function () {
                    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float");
                },
                supportsHalfFloatTextures: function () {
                    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float");
                },
                supportsStandardDerivatives: function () {
                    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives");
                },
                supportsCompressedTextureS3TC: function () {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc");
                },
                supportsCompressedTexturePVRTC: function () {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc");
                },
                supportsBlendMinMax: function () {
                    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax");
                },
                supportsVertexTextures: function () {
                    return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures;
                },
                supportsInstancedArrays: function () {
                    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays");
                },
                enableScissorTest: function (e) {
                    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e);
                },
                initMaterial: function () {
                    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
                },
                addPrePlugin: function () {
                    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
                },
                addPostPlugin: function () {
                    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
                },
                updateShadowMap: function () {
                    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
                },
                setFaceCulling: function () {
                    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
                },
                allocTextureUnit: function () {
                    console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
                },
                setTexture: function () {
                    console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
                },
                setTexture2D: function () {
                    console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
                },
                setTextureCube: function () {
                    console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
                },
                getActiveMipMapLevel: function () {
                    return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel();
                },
            }),
            Object.defineProperties(ws.prototype, {
                shadowMapEnabled: {
                    get: function () {
                        return this.shadowMap.enabled;
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), (this.shadowMap.enabled = e);
                    },
                },
                shadowMapType: {
                    get: function () {
                        return this.shadowMap.type;
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), (this.shadowMap.type = e);
                    },
                },
                shadowMapCullFace: {
                    get: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
                    },
                    set: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
                    },
                },
                context: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext();
                    },
                },
            }),
            Object.defineProperties(cs.prototype, {
                cullFace: {
                    get: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
                    },
                    set: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
                    },
                },
                renderReverseSided: {
                    get: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
                    },
                    set: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
                    },
                },
                renderSingleSided: {
                    get: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
                    },
                    set: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
                    },
                },
            }),
            Object.defineProperties(co.prototype, {
                activeCubeFace: {
                    set: function () {
                        console.warn("THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget().");
                    },
                },
                activeMipMapLevel: {
                    set: function () {
                        console.warn("THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget().");
                    },
                },
            }),
            Object.defineProperties(On.prototype, {
                wrapS: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), (this.texture.wrapS = e);
                    },
                },
                wrapT: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), (this.texture.wrapT = e);
                    },
                },
                magFilter: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter;
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), (this.texture.magFilter = e);
                    },
                },
                minFilter: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter;
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), (this.texture.minFilter = e);
                    },
                },
                anisotropy: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy;
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), (this.texture.anisotropy = e);
                    },
                },
                offset: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset;
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), (this.texture.offset = e);
                    },
                },
                repeat: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat;
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), (this.texture.repeat = e);
                    },
                },
                format: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format;
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), (this.texture.format = e);
                    },
                },
                type: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), (this.texture.type = e);
                    },
                },
                generateMipmaps: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps;
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), (this.texture.generateMipmaps = e);
                    },
                },
            }),
            Object.defineProperties(_s.prototype, {
                standing: {
                    set: function () {
                        console.warn("THREE.WebVRManager: .standing has been removed.");
                    },
                },
                userHeight: {
                    set: function () {
                        console.warn("THREE.WebVRManager: .userHeight has been removed.");
                    },
                },
            }),
            Object.defineProperties(Oh.prototype, {
                load: {
                    value: function (e) {
                        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
                        var t = this;
                        return (
                            new yh().load(e, function (e) {
                                t.setBuffer(e);
                            }),
                            this
                        );
                    },
                },
                startTime: {
                    set: function () {
                        console.warn("THREE.Audio: .startTime is now .play( delay ).");
                    },
                },
            }),
            (zh.prototype.getData = function () {
                return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData();
            }),
            (so.prototype.updateCubeMap = function (e, t) {
                return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(e, t);
            });
        var Pp = {
            merge: function (e, t, n) {
                var i;
                console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."),
                    t.isMesh && (t.matrixAutoUpdate && t.updateMatrix(), (i = t.matrix), (t = t.geometry)),
                    e.merge(t, i, n);
            },
            center: function (e) {
                return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), e.center();
            },
        };
        function Op() {
            console.error("THREE.CanvasRenderer has been removed");
        }
        function Dp() {
            console.error("THREE.JSONLoader has been removed.");
        }
        (Ln.crossOrigin = void 0),
            (Ln.loadTexture = function (e, t, n, i) {
                console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                var r = new xu();
                r.setCrossOrigin(this.crossOrigin);
                var o = r.load(e, n, void 0, i);
                return t && (o.mapping = t), o;
            }),
            (Ln.loadTextureCube = function (e, t, n, i) {
                console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                var r = new yu();
                r.setCrossOrigin(this.crossOrigin);
                var o = r.load(e, n, void 0, i);
                return t && (o.mapping = t), o;
            }),
            (Ln.loadCompressedTexture = function () {
                console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
            }),
            (Ln.loadCompressedTextureCube = function () {
                console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
            });
        var Ip = {
            createMultiMaterialObject: function () {
                console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js");
            },
            detach: function () {
                console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js");
            },
            attach: function () {
                console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js");
            },
        };
        function Np() {
            console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js");
        }
        "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: i } }));
    },
    function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
        const i = n(0),
            r = n(2),
            o = n(3),
            a = n(4),
            s = n(5),
            c = n(6),
            l = n(7),
            u = n(8),
            h = n(9),
            d = n(10),
            p = n(11),
            f = n(12),
            m = n(13),
            v = n(14),
            g = ["gradient.jpg"],
            y = [];
        !(function () {
            const e = new i.TextureLoader().setPath("./resources/");
            for (let t = 0; t < g.length; ++t)
                e.load(g[t], (e) => {
                    y[t] = e;
                });
        })();
        const x = {
                Simulate: !0,
                Iterations: 32,
                Radius: .25,
                Scale: 0.2,
                ColorDecay: 0.01,
                Boundaries: 0,
                AddColor: !0,
                Visualize: "Velocity",
                Mode: "Luminance",
                Timestep: "1/120",
                Reset: () => {
                    z.update({ inputTexture: U, velocity: U }), F.update({ inputTexture: B, velocity: U }), (D = void 0), (O = void 0);
                },
                Github: () => {
                    window.open("https://github.com/amsXYZ/three-fluid-sim");
                },
                Twitter: () => {
                    window.open("https://twitter.com/_amsXYZ");
                },
            },
            _ = document.getElementById("canvas"),
            b = new m();
        _.parentElement.appendChild(b.dom);
        const w = new v.GUI();
        !(function () {
            const e = w.addFolder("Simulation");
            e.add(x, "Scale", 0.1, 2, 0.1).onFinishChange((e) => {
                T.set(x.Scale * window.innerWidth, x.Scale * window.innerHeight), L.resize(T), C.resize(T), R.resize(T), P.resize(T);
            }),
                e.add(x, "Iterations", 16, 128, 1),
                e.add(x, "ColorDecay", 0, 0.1, 0.01),
                e.add(x, "Timestep", ["1/15", "1/30", "1/60", "1/90", "1/120"]).onChange((e) => {
                    switch (e) {
                        case "1/15":
                            E = 1 / 15;
                            break;
                        case "1/30":
                            E = 1 / 30;
                            break;
                        case "1/60":
                            E = 1 / 60;
                            break;
                        case "1/90":
                            E = 1 / 90;
                            break;
                        case "1/120":
                            E = 1 / 120;
                    }
                }),
                e.add(x, "Simulate"),
                e.add(x, "Boundaries"),
                e.add(x, "Reset");
            const t = w.addFolder("Input");
            t.add(x, "Radius", 0.1, 1, 0.1), t.add(x, "AddColor"), w.add(x, "Visualize", ["Color", "Velocity", "Divergence", "Pressure"]), w.add(x, "Mode", ["Normal", "Luminance", "Spectral", "Gradient"]);
            const n = w.add(x, "Github");
            (n.__li.className = "guiIconText"), (n.__li.style.borderLeft = "3px solid #8C8C8C");
            const i = document.createElement("span");
            (i.className = "guiIcon github"), n.domElement.parentElement.appendChild(i);
            const r = w.add(x, "Twitter");
            (r.__li.className = "guiIconText"), (r.__li.style.borderLeft = "3px solid #8C8C8C");
            const o = document.createElement("span");
            (o.className = "guiIcon twitter"), r.domElement.parentElement.appendChild(o);
        })();
        const M = new i.WebGLRenderer({ canvas: _ });
        (M.autoClear = !1), M.setSize(window.innerWidth, window.innerHeight), M.setPixelRatio(window.devicePixelRatio);
        const S = new i.OrthographicCamera(0, 0, 0, 0, 0, 0);
        let E = 1 / 60;
        (M.context.getExtension("OES_texture_half_float") && M.context.getExtension("OES_texture_half_float_linear")) || alert("This demo is not supported on your device.");
        const T = new i.Vector2(x.Scale * window.innerWidth, x.Scale * window.innerHeight),
            A = new i.Vector2(T.x / T.y, 1),
            L = new f.RenderTarget(T, 2, i.RGBFormat, i.HalfFloatType),
            C = new f.RenderTarget(T, 1, i.RGBFormat, i.HalfFloatType),
            R = new f.RenderTarget(T, 2, i.RGBFormat, i.HalfFloatType),
            P = new f.RenderTarget(T, 2, i.RGBFormat, i.UnsignedByteType);
        let O, D, I, N;
        const U = new p.VelocityInitPass(M, T).render(),
            B = new a.ColorInitPass(M, T).render(),
            z = new r.AdvectionPass(U, U, 0),
            F = new r.AdvectionPass(U, B, x.ColorDecay),
            G = new d.TouchForcePass(T, x.Radius),
            H = new h.TouchColorPass(T, x.Radius),
            V = new o.BoundaryPass(),
            k = new c.DivergencePass(),
            j = new u.JacobiIterationsPass(),
            W = new l.GradientSubstractionPass(),
            q = new s.CompositionPass();
        window.addEventListener("resize", (e) => {
            M.setSize(window.innerWidth, window.innerHeight),
                M.setPixelRatio(window.devicePixelRatio),
                T.set(x.Scale * window.innerWidth, x.Scale * window.innerHeight),
                L.resize(T),
                C.resize(T),
                R.resize(T),
                P.resize(T),
                A.set(T.x / T.y, 1),
                G.update({ aspect: A }),
                H.update({ aspect: A });
        }),
            window.addEventListener("keyup", (e) => {
                72 === e.keyCode && (b.dom.hidden = !b.dom.hidden);
            });
        let X = [];
        _.addEventListener("mouseover", (e) => {
            if (0 === e.button) {
                const t = (e.clientX / _.clientWidth) * A.x,
                    n = 1 - (e.clientY / _.clientHeight);
                X.push({ id: "mouse", input: new i.Vector4(t, n, 0, 0) });
            }
        }),
            _.addEventListener("mousemove", (e) => {
                if (X.length > 0) {
                    const t = (e.clientX / _.clientWidth) * A.x,
                        n = 1 - (e.clientY / _.clientHeight);
                    X[0].input.setZ(t - X[0].input.x).setW(n - X[0].input.y), X[0].input.setX(t).setY(n);
                }
            }),
            _.addEventListener("mouseout", (e) => {
                0 === e.button && X.pop();
            }),
            _.addEventListener("touchstart", (e) => {
                for (const t of e.changedTouches) {
                    const e = (t.clientX / _.clientWidth) * A.x,
                        n = 1 - (t.clientY / _.clientHeight);
                    X.push({ id: t.identifier, input: new i.Vector4(e, n, 0, 0) });
                }
            }),
            _.addEventListener("touchmove", (e) => {
                // e.preventDefault();
                for (const t of e.changedTouches) {
                    const e = X.find((e) => e.id === t.identifier);
                    if (void 0 !== e) {
                        const n = (t.clientX / _.clientWidth) * A.x,
                            i = 1 - (t.clientY / _.clientHeight);
                        e.input.setZ(n - e.input.x).setW(i - e.input.y), e.input.setX(n).setY(i);
                    }
                }
            }),
            _.addEventListener("touchend", (e) => {
                for (const t of e.changedTouches) {
                    const e = X.find((e) => e.id === t.identifier);
                    void 0 !== e && (X = X.filter((t) => t.id !== e.id));
                }
            }),
            _.addEventListener("touchcancel", (e) => {
                for (let t = 0; t < X.length; ++t) for (let n = 0; n < e.touches.length && X[t].id !== e.touches.item(n).identifier; ++n) n === e.touches.length - 1 && X.splice(t--, 1);
            }),
            (function e() {
                requestAnimationFrame(e),
                    b.begin(),
                    (function () {
                        if (x.Simulate) {
                            z.update({ timeDelta: E }),
                                (D = L.set(M)),
                                M.render(z.scene, S),
                                X.length > 0 &&
                                    (G.update({ touches: X, radius: x.Radius, velocity: D }), (D = L.set(M)), M.render(G.scene, S), x.AddColor && (H.update({ touches: X, radius: x.Radius, color: O }), (O = P.set(M)), M.render(H.scene, S))),
                                x.Boundaries && (V.update({ velocity: D }), (D = L.set(M)), M.render(V.scene, S)),
                                k.update({ timeDelta: E, velocity: D }),
                                (I = C.set(M)),
                                M.render(k.scene, S),
                                j.update({ divergence: I });
                            for (let e = 0; e < x.Iterations; ++e) (N = R.set(M)), M.render(j.scene, S), j.update({ previousIteration: N });
                            W.update({ timeDelta: E, velocity: D, pressure: N }),
                                (D = L.set(M)),
                                M.render(W.scene, S),
                                F.update({ timeDelta: E, inputTexture: O, velocity: D, decay: x.ColorDecay }),
                                (O = P.set(M)),
                                M.render(F.scene, S),
                                z.update({ inputTexture: D, velocity: D }),
                                F.update({ inputTexture: O });
                        }
                        let e;
                        switch ((M.setRenderTarget(null), x.Visualize)) {
                            case "Color":
                                e = O;
                                break;
                            case "Velocity":
                                e = D;
                                break;
                            case "Divergence":
                                e = I;
                                break;
                            case "Pressure":
                                e = N;
                        }
                        q.update({ colorBuffer: e, mode: x.Mode, gradient: y[0] }), M.render(q.scene, S);
                    })(),
                    b.end();
            })();
    },
    function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
        const i = n(0);
        t.AdvectionPass = class {
            constructor(e, t, n) {
                (this.initialVelocity = e), (this.initialValue = t), (this.decay = n), (this.scene = new i.Scene());
                const r = new i.BufferGeometry();
                r.setAttribute("position", new i.BufferAttribute(new Float32Array([-1, -1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1]), 2)),
                    (this.material = new i.RawShaderMaterial({
                        uniforms: { timeDelta: new i.Uniform(0), inputTexture: new i.Uniform(t), velocity: new i.Uniform(e), decay: new i.Uniform(n) },
                        vertexShader: "\n        attribute vec2 position;\n        varying vec2 vUV;\n\n        void main() {\n          vUV = position * 0.5 + 0.5;\n          gl_Position = vec4(position, 0.0, 1.0);\n        }",
                        fragmentShader:
                            "\n        precision highp float;\n        precision highp int;\n        varying vec2 vUV;\n        uniform float timeDelta;\n        uniform sampler2D inputTexture;\n        uniform sampler2D velocity;\n        uniform float decay;\n\n        void main() {\n          vec2 prevUV = fract(vUV - timeDelta * texture2D(velocity, vUV).xy);\n          gl_FragColor = texture2D(inputTexture, prevUV) * (1.0 - decay);\n        }",
                        depthTest: !1,
                        depthWrite: !1,
                    })),
                    (this.mesh = new i.Mesh(r, this.material)),
                    (this.mesh.frustumCulled = !1),
                    this.scene.add(this.mesh);
            }
            update(e) {
                void 0 !== e.timeDelta && (this.material.uniforms.timeDelta.value = e.timeDelta),
                    void 0 !== e.inputTexture && (this.material.uniforms.inputTexture.value = e.inputTexture),
                    void 0 !== e.velocity && (this.material.uniforms.velocity.value = e.velocity),
                    void 0 !== e.decay && (this.material.uniforms.decay.value = e.decay);
            }
        };
    },
    function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
        const i = n(0);
        t.BoundaryPass = class {
            constructor() {
                this.scene = new i.Scene();
                const e = new i.BufferGeometry();
                e.setAttribute("position", new i.BufferAttribute(new Float32Array([-1, -1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1]), 2)),
                    (this.material = new i.RawShaderMaterial({
                        uniforms: { velocity: new i.Uniform(i.Texture.DEFAULT_IMAGE) },
                        vertexShader: "\n        attribute vec2 position;\n        varying vec2 vUV;\n\n        void main() {\n          vUV = position * 0.5 + 0.5;\n          gl_Position = vec4(position, 0.0, 1.0);\n        }",
                        fragmentShader:
                            "\n        precision highp float;\n        precision highp int;\n        varying vec2 vUV;\n        uniform sampler2D velocity;\n\n        void main() {\n          vec2 texelSize = vec2(dFdx(vUV.x), dFdy(vUV.y));\n\n          float leftEdgeMask = ceil(texelSize.x - vUV.x);\n          float bottomEdgeMask = ceil(texelSize.y - vUV.y);\n          float rightEdgeMask = ceil(vUV.x - (1.0 - texelSize.x));\n          float topEdgeMask = ceil(vUV.y - (1.0 - texelSize.y));\n          float mask = clamp(leftEdgeMask + bottomEdgeMask + rightEdgeMask + topEdgeMask, 0.0, 1.0);\n          float direction = mix(1.0, -1.0, mask);\n          \n          gl_FragColor = texture2D(velocity, vUV) * direction;\n        }",
                        depthTest: !1,
                        depthWrite: !1,
                        extensions: { derivatives: !0 },
                    })),
                    (this.mesh = new i.Mesh(e, this.material)),
                    (this.mesh.frustumCulled = !1),
                    this.scene.add(this.mesh);
            }
            update(e) {
                void 0 !== e.position && (this.material.uniforms.position.value = e.position),
                    void 0 !== e.direction && (this.material.uniforms.direction.value = e.direction),
                    void 0 !== e.radius && (this.material.uniforms.radius.value = e.radius),
                    void 0 !== e.velocity && (this.material.uniforms.velocity.value = e.velocity);
            }
        };
    },
    function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
        const i = n(0);
        t.ColorInitPass = class {
            constructor(e, t) {
                (this.renderer = e),
                    (this.resolution = t),
                    (this.scene = new i.Scene()),
                    (this.camera = new i.OrthographicCamera(0, 0, 0, 0, 0, 0)),
                    (this.renderTarget = new i.WebGLRenderTarget(t.x, t.y, { format: i.RGBFormat, type: i.UnsignedByteType, depthBuffer: !1, stencilBuffer: !1 }));
                const n = new i.BufferGeometry();
                n.setAttribute("position", new i.BufferAttribute(new Float32Array([-1, -1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1]), 2)),
                    (this.material = new i.RawShaderMaterial({
                        uniforms: { scale: new i.Uniform(window.innerWidth > window.innerHeight ? new i.Vector2(window.innerWidth / window.innerHeight, 1) : new i.Vector2(1, window.innerHeight / window.innerWidth)) },
                        vertexShader: "\n          attribute vec2 position;\n          varying vec2 clipPos;\n  \n          void main() {\n            clipPos = position;\n            gl_Position = vec4(position, 0.0, 1.0);\n          }",
                        fragmentShader:
                            "\n          precision highp float;\n          precision highp int;\n          varying vec2 clipPos;\n  \n          void main() {\n            vec3 color = vec3(clipPos * 0.5 + 0.5, 0.0);\n            gl_FragColor = vec4(color, 1.0);\n          }",
                        depthTest: !1,
                        depthWrite: !1,
                    })),
                    (this.mesh = new i.Mesh(n, this.material)),
                    (this.mesh.frustumCulled = !1),
                    this.scene.add(this.mesh);
            }
            update(e) {
                if (void 0 !== e.width && void 0 !== e.height) {
                    this.renderTarget.setSize(e.width, e.height),
                        window.innerWidth > window.innerHeight ? this.material.uniforms.scale.value.set(window.innerWidth / window.innerHeight, 1) : this.material.uniforms.scale.value.set(1, window.innerHeight / window.innerWidth);
                }
            }
            render() {
                return this.renderer.setRenderTarget(this.renderTarget), this.renderer.render(this.scene, this.camera), this.renderTarget.texture;
            }
        };
    },
    function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
        const i = n(0);
        t.CompositionPass = class {
            constructor() {
                this.scene = new i.Scene();
                const e = new i.BufferGeometry();
                e.setAttribute("position", new i.BufferAttribute(new Float32Array([-1, -1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1]), 2)),
                    (this.material = new i.RawShaderMaterial({
                        uniforms: { colorBuffer: new i.Uniform(i.Texture.DEFAULT_IMAGE), gradient: new i.Uniform(i.Texture.DEFAULT_IMAGE) },
                        defines: { MODE: 0 },
                        vertexShader:
                            "\n          attribute vec2 position;\n          varying vec2 vUV;\n          \n          void main() {\n            vUV = position * 0.5 + 0.5;\n            gl_Position = vec4(position, 0.0, 1.0);\n          }",
                        fragmentShader:
                            "\n          precision highp float;\n          precision highp int;\n\n          varying vec2 vUV;\n          uniform sampler2D colorBuffer;\n          uniform sampler2D gradient;\n\n          const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n          float luminance(in vec3 color) {\n            return dot(color, W);\n          }\n\n          // Based on code by Spektre posted at http://stackoverflow.com/questions/3407942/rgb-values-of-visible-spectrum\n          vec4 spectral(float l) // RGB <0,1> <- lambda l <400,700> [nm]\n          {\n            float r=0.0,g=0.0,b=0.0;\n                  if ((l>=400.0)&&(l<410.0)) { float t=(l-400.0)/(410.0-400.0); r=    +(0.33*t)-(0.20*t*t); }\n              else if ((l>=410.0)&&(l<475.0)) { float t=(l-410.0)/(475.0-410.0); r=0.14         -(0.13*t*t); }\n              else if ((l>=545.0)&&(l<595.0)) { float t=(l-545.0)/(595.0-545.0); r=    +(1.98*t)-(     t*t); }\n              else if ((l>=595.0)&&(l<650.0)) { float t=(l-595.0)/(650.0-595.0); r=0.98+(0.06*t)-(0.40*t*t); }\n              else if ((l>=650.0)&&(l<700.0)) { float t=(l-650.0)/(700.0-650.0); r=0.65-(0.84*t)+(0.20*t*t); }\n                  if ((l>=415.0)&&(l<475.0)) { float t=(l-415.0)/(475.0-415.0); g=             +(0.80*t*t); }\n              else if ((l>=475.0)&&(l<590.0)) { float t=(l-475.0)/(590.0-475.0); g=0.8 +(0.76*t)-(0.80*t*t); }\n              else if ((l>=585.0)&&(l<639.0)) { float t=(l-585.0)/(639.0-585.0); g=0.82-(0.80*t)           ; }\n                  if ((l>=400.0)&&(l<475.0)) { float t=(l-400.0)/(475.0-400.0); b=    +(2.20*t)-(1.50*t*t); }\n              else if ((l>=475.0)&&(l<560.0)) { float t=(l-475.0)/(560.0-475.0); b=0.7 -(     t)+(0.30*t*t); }\n\n            return vec4(r, g, b, 1.0);\n          }\n\n          void main() {\n            vec4 color = texture2D(colorBuffer, vUV);\n            float lum = luminance(abs(color.rgb));\n            #if MODE == 0\n            gl_FragColor = color;\n            #elif MODE == 1\n            gl_FragColor = vec4(lum);\n            #elif MODE == 2\n            gl_FragColor = spectral(mix(340.0, 700.0, lum));\n            #elif MODE == 3\n            gl_FragColor = texture2D(gradient, vec2(lum, 0.0));\n            #endif\n          }",
                        depthTest: !1,
                        depthWrite: !1,
                        transparent: !0,
                    })),
                    (this.mesh = new i.Mesh(e, this.material)),
                    (this.mesh.frustumCulled = !1),
                    this.scene.add(this.mesh);
            }
            update(e) {
                if ((void 0 !== e.colorBuffer && (this.material.uniforms.colorBuffer.value = e.colorBuffer), void 0 !== e.mode)) {
                    let t = 0;
                    switch (e.mode) {
                        case "Luminance":
                            t = 1;
                            break;
                        case "Spectral":
                            t = 2;
                            break;
                        case "Gradient":
                            t = 3;
                    }
                    t !== this.material.defines.MODE && ((this.material.defines.MODE = t), (this.material.needsUpdate = !0));
                }
                void 0 !== e.gradient && (this.material.uniforms.gradient.value = e.gradient);
            }
        };
    },
    function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
        const i = n(0);
        t.DivergencePass = class {
            constructor() {
                this.scene = new i.Scene();
                const e = new i.BufferGeometry();
                e.setAttribute("position", new i.BufferAttribute(new Float32Array([-1, -1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1]), 2)),
                    (this.material = new i.RawShaderMaterial({
                        uniforms: { timeDelta: new i.Uniform(0), velocity: new i.Uniform(i.Texture.DEFAULT_IMAGE) },
                        vertexShader:
                            "\n          attribute vec2 position;\n          varying vec2 vUV;\n  \n          void main() {\n            vUV = position * 0.5 + 0.5;\n            gl_Position = vec4(position, 0.0, 1.0);\n          }",
                        fragmentShader:
                            "\n          precision highp float;\n          precision highp int;\n          varying vec2 vUV;\n          uniform float timeDelta;\n          uniform sampler2D velocity;\n         \n          void main() {\n            vec2 texelSize = vec2(dFdx(vUV.x), dFdy(vUV.y));\n            \n            float x0 = texture2D(velocity, vUV - vec2(texelSize.x, 0)).x;\n            float x1 = texture2D(velocity, vUV + vec2(texelSize.x, 0)).x;\n            float y0 = texture2D(velocity, vUV - vec2(0, texelSize.y)).y;\n            float y1 = texture2D(velocity, vUV + vec2(0, texelSize.y)).y;\n            float divergence = ( x1 - x0 + y1 - y0) * 0.5;\n            \n            gl_FragColor = vec4(divergence);\n          }",
                        depthTest: !1,
                        depthWrite: !1,
                        extensions: { derivatives: !0 },
                    })),
                    (this.mesh = new i.Mesh(e, this.material)),
                    (this.mesh.frustumCulled = !1),
                    this.scene.add(this.mesh);
            }
            update(e) {
                void 0 !== e.timeDelta && (this.material.uniforms.timeDelta.value = e.timeDelta),
                    void 0 !== e.density && (this.material.uniforms.density.value = e.density),
                    void 0 !== e.velocity && (this.material.uniforms.velocity.value = e.velocity);
            }
        };
    },
    function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
        const i = n(0);
        t.GradientSubstractionPass = class {
            constructor() {
                this.scene = new i.Scene();
                const e = new i.BufferGeometry();
                e.setAttribute("position", new i.BufferAttribute(new Float32Array([-1, -1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1]), 2)),
                    (this.material = new i.RawShaderMaterial({
                        uniforms: { timeDelta: new i.Uniform(0), velocity: new i.Uniform(i.Texture.DEFAULT_IMAGE), pressure: new i.Uniform(i.Texture.DEFAULT_IMAGE) },
                        vertexShader:
                            "\n            attribute vec2 position;\n            varying vec2 vUV;\n    \n            void main() {\n              vUV = position * 0.5 + 0.5;\n              gl_Position = vec4(position, 0.0, 1.0);\n            }",
                        fragmentShader:
                            "\n            precision highp float;\n            precision highp int;\n            varying vec2 vUV;\n            uniform float timeDelta;\n            uniform sampler2D velocity;\n            uniform sampler2D pressure;\n\n            void main() {\n              vec2 texelSize = vec2(dFdx(vUV.x), dFdy(vUV.y));\n\n              float x0 = texture2D(pressure, vUV - vec2(texelSize.x, 0)).r;\n              float x1 = texture2D(pressure, vUV + vec2(texelSize.x, 0)).r;\n              float y0 = texture2D(pressure, vUV - vec2(0, texelSize.y)).r;\n              float y1 = texture2D(pressure, vUV + vec2(0, texelSize.y)).r;\n              \n              vec2 v = texture2D(velocity, vUV).xy;\n              v -= 0.5 * vec2(x1 - x0, y1 - y0);\n              \n              gl_FragColor = vec4(v, 0.0, 1.0);\n            }",
                        depthTest: !1,
                        depthWrite: !1,
                        extensions: { derivatives: !0 },
                    })),
                    (this.mesh = new i.Mesh(e, this.material)),
                    (this.mesh.frustumCulled = !1),
                    this.scene.add(this.mesh);
            }
            update(e) {
                void 0 !== e.timeDelta && (this.material.uniforms.timeDelta.value = e.timeDelta),
                    void 0 !== e.density && (this.material.uniforms.density.value = e.density),
                    void 0 !== e.velocity && (this.material.uniforms.velocity.value = e.velocity),
                    void 0 !== e.pressure && (this.material.uniforms.pressure.value = e.pressure);
            }
        };
    },
    function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
        const i = n(0);
        t.JacobiIterationsPass = class {
            constructor() {
                this.scene = new i.Scene();
                const e = new i.BufferGeometry();
                e.setAttribute("position", new i.BufferAttribute(new Float32Array([-1, -1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1]), 2)),
                    (this.material = new i.RawShaderMaterial({
                        uniforms: { alpha: new i.Uniform(-1), beta: new i.Uniform(0.25), previousIteration: new i.Uniform(i.Texture.DEFAULT_IMAGE), divergence: new i.Uniform(i.Texture.DEFAULT_IMAGE) },
                        vertexShader:
                            "\n            attribute vec2 position;\n            varying vec2 vUV;\n    \n            void main() {\n              vUV = position * 0.5 + 0.5;\n              gl_Position = vec4(position, 0.0, 1.0);\n            }",
                        fragmentShader:
                            "\n            precision highp float;\n            precision highp int;\n            varying vec2 vUV;\n            uniform float alpha;\n            uniform float beta;\n            uniform sampler2D previousIteration;\n            uniform sampler2D divergence;\n    \n            void main() {\n              vec2 texelSize = vec2(dFdx(vUV.x), dFdy(vUV.y));\n              \n              vec4 x0 = texture2D(previousIteration, vUV - vec2(texelSize.x, 0));\n              vec4 x1 = texture2D(previousIteration, vUV + vec2(texelSize.x, 0));\n              vec4 y0 = texture2D(previousIteration, vUV - vec2(0, texelSize.y));\n              vec4 y1 = texture2D(previousIteration, vUV + vec2(0, texelSize.y));\n              vec4 d = texture2D(divergence, vUV);\n\n              gl_FragColor = (x0 + x1 + y0 + y1 + alpha * d) * beta;\n            }",
                        depthTest: !1,
                        depthWrite: !1,
                        extensions: { derivatives: !0 },
                    })),
                    (this.mesh = new i.Mesh(e, this.material)),
                    (this.mesh.frustumCulled = !1),
                    this.scene.add(this.mesh);
            }
            update(e) {
                void 0 !== e.previousIteration && (this.material.uniforms.previousIteration.value = e.previousIteration), void 0 !== e.divergence && (this.material.uniforms.divergence.value = e.divergence);
            }
        };
    },
    function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
        const i = n(0),
            r = 10;
        t.TouchColorPass = class {
            constructor(e, t) {
                (this.resolution = e), (this.radius = t), (this.scene = new i.Scene());
                const n = new i.BufferGeometry();
                n.setAttribute("position", new i.BufferAttribute(new Float32Array([-1, -1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1]), 2)),
                    (this.material = new i.RawShaderMaterial({
                        uniforms: {
                            aspect: new i.Uniform(new i.Vector2(e.x / e.y, 1)),
                            input0: new i.Uniform(new i.Vector4()),
                            input1: new i.Uniform(new i.Vector4()),
                            input2: new i.Uniform(new i.Vector4()),
                            input3: new i.Uniform(new i.Vector4()),
                            input4: new i.Uniform(new i.Vector4()),
                            input5: new i.Uniform(new i.Vector4()),
                            input6: new i.Uniform(new i.Vector4()),
                            input7: new i.Uniform(new i.Vector4()),
                            input8: new i.Uniform(new i.Vector4()),
                            input9: new i.Uniform(new i.Vector4()),
                            radius: new i.Uniform(t),
                            color: new i.Uniform(i.Texture.DEFAULT_IMAGE),
                        },
                        vertexShader:
                            "\n        attribute vec2 position;\n        varying vec2 vUV;\n        varying vec2 vScaledUV;\n        uniform vec2 aspect;\n\n        void main() {\n          vUV = position * 0.5 + 0.5;\n          vScaledUV = position * aspect * 0.5 + aspect * 0.5;\n          gl_Position = vec4(position, 0.0, 1.0);\n        }",
                        fragmentShader:
                            "\n        precision highp float;\n        precision highp int;\n        varying vec2 vUV;\n        varying vec2 vScaledUV;\n        uniform vec4 input0;\n        uniform vec4 input1;\n        uniform vec4 input2;\n        uniform vec4 input3;\n        uniform vec4 input4;\n        uniform vec4 input5;\n        uniform vec4 input6;\n        uniform vec4 input7;\n        uniform vec4 input8;\n        uniform vec4 input9;\n        uniform float radius;\n        uniform sampler2D color;\n\n        vec2 getColor(vec4 inputVec) {\n          float d = distance(vScaledUV, inputVec.xy) / radius;\n          float strength = 1.0 / max(d * d, 0.01);\n          strength *= clamp(dot(normalize(vScaledUV - inputVec.xy), normalize(inputVec.zw)), 0.0, 1.0);\n          return strength * abs(inputVec.zw) * radius;\n        }\n\n        void main() {\n          vec4 touchColor = vec4(0.0);\n          touchColor.xy += getColor(input0);\n          touchColor.xy += getColor(input1);\n          touchColor.xy += getColor(input2);\n          touchColor.xy += getColor(input3);\n          touchColor.xy += getColor(input4);\n          touchColor.xy += getColor(input5);\n          touchColor.xy += getColor(input6);\n          touchColor.xy += getColor(input7);\n          touchColor.xy += getColor(input8);\n          touchColor.xy += getColor(input9);\n\n          gl_FragColor = texture2D(color, vUV) + touchColor;\n        }",
                        depthTest: !1,
                        depthWrite: !1,
                    })),
                    (this.mesh = new i.Mesh(n, this.material)),
                    (this.mesh.frustumCulled = !1),
                    this.scene.add(this.mesh);
            }
            update(e) {
                if ((void 0 !== e.aspect && (this.material.uniforms.aspect.value = e.aspect), void 0 !== e.touches)) {
                    const t = Math.min(r, e.touches.length);
                    for (let n = 0; n < t; ++n) this.material.uniforms["input" + n].value = e.touches[n].input;
                    for (let t = e.touches.length; t < r; ++t) this.material.uniforms["input" + t].value.set(0, 0, 0, 0);
                }
                void 0 !== e.radius && (this.material.uniforms.radius.value = e.radius), void 0 !== e.color && (this.material.uniforms.color.value = e.color);
            }
        };
    },
    function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
        const i = n(0),
            r = 10;
        t.TouchForcePass = class {
            constructor(e, t) {
                (this.resolution = e), (this.radius = t), (this.scene = new i.Scene());
                const n = new i.BufferGeometry();
                n.setAttribute("position", new i.BufferAttribute(new Float32Array([-1, -1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1]), 2)),
                    (this.material = new i.RawShaderMaterial({
                        uniforms: {
                            aspect: new i.Uniform(new i.Vector2(e.x / e.y, 1)),
                            input0: new i.Uniform(new i.Vector4()),
                            input1: new i.Uniform(new i.Vector4()),
                            input2: new i.Uniform(new i.Vector4()),
                            input3: new i.Uniform(new i.Vector4()),
                            input4: new i.Uniform(new i.Vector4()),
                            input5: new i.Uniform(new i.Vector4()),
                            input6: new i.Uniform(new i.Vector4()),
                            input7: new i.Uniform(new i.Vector4()),
                            input8: new i.Uniform(new i.Vector4()),
                            input9: new i.Uniform(new i.Vector4()),
                            radius: new i.Uniform(t),
                            velocity: new i.Uniform(i.Texture.DEFAULT_IMAGE),
                        },
                        vertexShader:
                            "\n        attribute vec2 position;\n        varying vec2 vUV;\n        varying vec2 vScaledUV;\n        uniform vec2 aspect;\n\n        void main() {\n          vUV = position * 0.5 + 0.5;\n          vScaledUV = position * aspect * 0.5 + aspect * 0.5;\n          gl_Position = vec4(position, 0.0, 1.0);\n        }",
                        fragmentShader:
                            "\n        precision highp float;\n        precision highp int;\n        varying vec2 vUV;\n        varying vec2 vScaledUV;\n        uniform vec4 input0;\n        uniform vec4 input1;\n        uniform vec4 input2;\n        uniform vec4 input3;\n        uniform vec4 input4;\n        uniform vec4 input5;\n        uniform vec4 input6;\n        uniform vec4 input7;\n        uniform vec4 input8;\n        uniform vec4 input9;\n        uniform float radius;\n        uniform sampler2D velocity;\n\n        vec2 getForce(vec4 inputVec) {\n          float d = distance(vScaledUV, inputVec.xy) / radius;\n          float strength = 1.0 / max(d * d, 0.01);\n          strength *= clamp(dot(normalize(vScaledUV - inputVec.xy), normalize(inputVec.zw)), 0.0, 1.0);\n          return strength * inputVec.zw * radius;\n        }\n\n        void main() {\n          vec4 touchForce = vec4(0.0);\n          touchForce.xy += getForce(input0);\n          touchForce.xy += getForce(input1);\n          touchForce.xy += getForce(input2);\n          touchForce.xy += getForce(input3);\n          touchForce.xy += getForce(input4);\n          touchForce.xy += getForce(input5);\n          touchForce.xy += getForce(input6);\n          touchForce.xy += getForce(input7);\n          touchForce.xy += getForce(input8);\n          touchForce.xy += getForce(input9);\n\n          gl_FragColor = texture2D(velocity, vUV) + touchForce;\n        }",
                        depthTest: !1,
                        depthWrite: !1,
                    })),
                    (this.mesh = new i.Mesh(n, this.material)),
                    (this.mesh.frustumCulled = !1),
                    this.scene.add(this.mesh);
            }
            update(e) {
                if ((void 0 !== e.aspect && (this.material.uniforms.aspect.value = e.aspect), void 0 !== e.touches)) {
                    const t = Math.min(r, e.touches.length);
                    for (let n = 0; n < t; ++n) this.material.uniforms["input" + n].value = e.touches[n].input;
                    for (let t = e.touches.length; t < r; ++t) this.material.uniforms["input" + t].value.set(0, 0, 0, 0);
                }
                void 0 !== e.radius && (this.material.uniforms.radius.value = e.radius), void 0 !== e.velocity && (this.material.uniforms.velocity.value = e.velocity);
            }
        };
    },
    function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
        const i = n(0);
        t.VelocityInitPass = class {
            constructor(e, t) {
                (this.renderer = e),
                    (this.resolution = t),
                    (this.scene = new i.Scene()),
                    (this.camera = new i.OrthographicCamera(0, 0, 0, 0, 0, 0)),
                    (this.renderTarget = new i.WebGLRenderTarget(t.x, t.y, { format: i.RGBFormat, type: i.HalfFloatType, depthBuffer: !1, stencilBuffer: !1 })),
                    (this.geometry = new i.BufferGeometry()),
                    this.geometry.setAttribute("position", new i.BufferAttribute(new Float32Array([-1, -1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1]), 2)),
                    (this.material = new i.RawShaderMaterial({
                        uniforms: { scale: new i.Uniform(window.innerWidth > window.innerHeight ? new i.Vector2(window.innerWidth / window.innerHeight, 1) : new i.Vector2(1, window.innerHeight / window.innerWidth)) },
                        vertexShader: "\n        attribute vec2 position;\n        varying vec2 clipPos;\n\n        void main() {\n          clipPos = position;\n          gl_Position = vec4(position, 0.0, 1.0);\n        }",
                        fragmentShader:
                            "\n        #define PI 3.1415926535897932384626433832795  \n        precision highp float;\n        precision highp int;\n        varying vec2 clipPos;\n\n        void main() {\n          vec2 v = vec2(sin(2.0 * PI * clipPos.y), sin(2.0 * PI * clipPos.x));\n          gl_FragColor = vec4(v, 0.0, 1.0);\n        }",
                        depthTest: !1,
                        depthWrite: !1,
                    })),
                    (this.mesh = new i.Mesh(this.geometry, this.material)),
                    (this.mesh.frustumCulled = !1),
                    this.scene.add(this.mesh);
            }
            update(e) {
                if (void 0 !== e.width && void 0 !== e.height) {
                    this.renderTarget.setSize(e.width, e.height),
                        window.innerWidth > window.innerHeight ? this.material.uniforms.scale.value.set(window.innerWidth / window.innerHeight, 1) : this.material.uniforms.scale.value.set(1, window.innerHeight / window.innerWidth);
                }
            }
            render() {
                return this.renderer.setRenderTarget(this.renderTarget), this.renderer.render(this.scene, this.camera), this.renderTarget.texture;
            }
        };
    },
    function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
        const i = n(0);
        t.RenderTarget = class {
            constructor(e, t, n, r) {
                (this.resolution = e),
                    (this.nBuffers = t),
                    (this.format = n),
                    (this.type = r),
                    (this.index = 0),
                    (this.buffers = [{ target: new i.WebGLRenderTarget(e.x, e.y, { format: n, type: r, depthBuffer: !1, stencilBuffer: !1 }), needsResize: !1 }]);
                for (let e = 1; e < t; ++e) this.buffers[e] = { target: this.buffers[0].target.clone(), needsResize: !1 };
            }
            resize(e) {
                e.copy(e);
                for (let e = 0; e < this.nBuffers; ++e) this.buffers[e].needsResize = !0;
            }
            set(e) {
                const t = this.buffers[this.index++];
                return t.needsResize && ((t.needsResize = !1), t.target.setSize(this.resolution.x, this.resolution.y)), e.setRenderTarget(t.target), (this.index %= this.nBuffers), t.target.texture;
            }
        };
    },
    function (e, t, n) {
        var i;
        e.exports =
            (((i = function () {
                function e(e) {
                    return r.appendChild(e.dom), e;
                }
                function t(e) {
                    for (var t = 0; t < r.children.length; t++) r.children[t].style.display = t === e ? "block" : "none";
                    n = e;
                }
                var n = 0,
                    r = document.createElement("div");
                (r.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.0;z-index:10000"),
                    r.addEventListener(
                        "click",
                        function (e) {
                            e.preventDefault(), t(++n % r.children.length);
                        },
                        !1
                    );
                var o = (performance || Date).now(),
                    a = o,
                    s = 0,
                    c = e(new i.Panel("FPS", "#0ff", "#002")),
                    l = e(new i.Panel("MS", "#0f0", "#020"));
                if (self.performance && self.performance.memory) var u = e(new i.Panel("MB", "#f08", "#201"));
                return (
                    t(0),
                    {
                        REVISION: 16,
                        dom: r,
                        addPanel: e,
                        showPanel: t,
                        begin: function () {
                            o = (performance || Date).now();
                        },
                        end: function () {
                            s++;
                            var e = (performance || Date).now();
                            if ((l.update(e - o, 200), e > a + 1e3 && (c.update((1e3 * s) / (e - a), 100), (a = e), (s = 0), u))) {
                                var t = performance.memory;
                                u.update(t.usedJSHeapSize / 1048576, t.jsHeapSizeLimit / 1048576);
                            }
                            return e;
                        },
                        update: function () {
                            o = this.end();
                        },
                        domElement: r,
                        setMode: t,
                    }
                );
            }).Panel = function (e, t, n) {
                var i = 1 / 0,
                    r = 0,
                    o = Math.round,
                    a = o(window.devicePixelRatio || 1),
                    s = 80 * a,
                    c = 48 * a,
                    l = 3 * a,
                    u = 2 * a,
                    h = 3 * a,
                    d = 15 * a,
                    p = 74 * a,
                    f = 30 * a,
                    m = document.createElement("canvas");
                (m.width = s), (m.height = c), (m.style.cssText = "width:80px;height:48px");
                var v = m.getContext("2d");
                return (
                    (v.font = "bold " + 9 * a + "px Helvetica,Arial,sans-serif"),
                    (v.textBaseline = "top"),
                    (v.fillStyle = n),
                    v.fillRect(0, 0, s, c),
                    (v.fillStyle = t),
                    v.fillText(e, l, u),
                    v.fillRect(h, d, p, f),
                    (v.fillStyle = n),
                    (v.globalAlpha = 0.9),
                    v.fillRect(h, d, p, f),
                    {
                        dom: m,
                        update: function (c, g) {
                            (i = Math.min(i, c)),
                                (r = Math.max(r, c)),
                                (v.fillStyle = n),
                                (v.globalAlpha = 1),
                                v.fillRect(0, 0, s, d),
                                (v.fillStyle = t),
                                v.fillText(o(c) + " " + e + " (" + o(i) + "-" + o(r) + ")", l, u),
                                v.drawImage(m, h + a, d, p - a, f, h, d, p - a, f),
                                v.fillRect(h + p - a, d, a, f),
                                (v.fillStyle = n),
                                (v.globalAlpha = 0.9),
                                v.fillRect(h + p - a, d, a, o((1 - c / g) * f));
                        },
                    }
                );
            }),
            i);
    },
    function (e, t, n) {
        "use strict";
        function i(e, t) {
            var n = e.__state.conversionName.toString(),
                i = Math.round(e.r),
                r = Math.round(e.g),
                o = Math.round(e.b),
                a = e.a,
                s = Math.round(e.h),
                c = e.s.toFixed(1),
                l = e.v.toFixed(1);
            if (t || "THREE_CHAR_HEX" === n || "SIX_CHAR_HEX" === n) {
                for (var u = e.hex.toString(16); u.length < 6; ) u = "0" + u;
                return "#" + u;
            }
            return "CSS_RGB" === n
                ? "rgb(" + i + "," + r + "," + o + ")"
                : "CSS_RGBA" === n
                ? "rgba(" + i + "," + r + "," + o + "," + a + ")"
                : "HEX" === n
                ? "0x" + e.hex.toString(16)
                : "RGB_ARRAY" === n
                ? "[" + i + "," + r + "," + o + "]"
                : "RGBA_ARRAY" === n
                ? "[" + i + "," + r + "," + o + "," + a + "]"
                : "RGB_OBJ" === n
                ? "{r:" + i + ",g:" + r + ",b:" + o + "}"
                : "RGBA_OBJ" === n
                ? "{r:" + i + ",g:" + r + ",b:" + o + ",a:" + a + "}"
                : "HSV_OBJ" === n
                ? "{h:" + s + ",s:" + c + ",v:" + l + "}"
                : "HSVA_OBJ" === n
                ? "{h:" + s + ",s:" + c + ",v:" + l + ",a:" + a + "}"
                : "unknown format";
        }
        n.r(t),
            n.d(t, "color", function () {
                return ue;
            }),
            n.d(t, "controllers", function () {
                return he;
            }),
            n.d(t, "dom", function () {
                return de;
            }),
            n.d(t, "gui", function () {
                return pe;
            }),
            n.d(t, "GUI", function () {
                return fe;
            });
        var r = Array.prototype.forEach,
            o = Array.prototype.slice,
            a = {
                BREAK: {},
                extend: function (e) {
                    return (
                        this.each(
                            o.call(arguments, 1),
                            function (t) {
                                (this.isObject(t) ? Object.keys(t) : []).forEach(
                                    function (n) {
                                        this.isUndefined(t[n]) || (e[n] = t[n]);
                                    }.bind(this)
                                );
                            },
                            this
                        ),
                        e
                    );
                },
                defaults: function (e) {
                    return (
                        this.each(
                            o.call(arguments, 1),
                            function (t) {
                                (this.isObject(t) ? Object.keys(t) : []).forEach(
                                    function (n) {
                                        this.isUndefined(e[n]) && (e[n] = t[n]);
                                    }.bind(this)
                                );
                            },
                            this
                        ),
                        e
                    );
                },
                compose: function () {
                    var e = o.call(arguments);
                    return function () {
                        for (var t = o.call(arguments), n = e.length - 1; n >= 0; n--) t = [e[n].apply(this, t)];
                        return t[0];
                    };
                },
                each: function (e, t, n) {
                    if (e)
                        if (r && e.forEach && e.forEach === r) e.forEach(t, n);
                        else if (e.length === e.length + 0) {
                            var i,
                                o = void 0;
                            for (o = 0, i = e.length; o < i; o++) if (o in e && t.call(n, e[o], o) === this.BREAK) return;
                        } else for (var a in e) if (t.call(n, e[a], a) === this.BREAK) return;
                },
                defer: function (e) {
                    setTimeout(e, 0);
                },
                debounce: function (e, t, n) {
                    var i = void 0;
                    return function () {
                        var r = this,
                            o = arguments;
                        function a() {
                            (i = null), n || e.apply(r, o);
                        }
                        var s = n || !i;
                        clearTimeout(i), (i = setTimeout(a, t)), s && e.apply(r, o);
                    };
                },
                toArray: function (e) {
                    return e.toArray ? e.toArray() : o.call(e);
                },
                isUndefined: function (e) {
                    return void 0 === e;
                },
                isNull: function (e) {
                    return null === e;
                },
                isNaN: (function (e) {
                    function t(t) {
                        return e.apply(this, arguments);
                    }
                    return (
                        (t.toString = function () {
                            return e.toString();
                        }),
                        t
                    );
                })(function (e) {
                    return isNaN(e);
                }),
                isArray:
                    Array.isArray ||
                    function (e) {
                        return e.constructor === Array;
                    },
                isObject: function (e) {
                    return e === Object(e);
                },
                isNumber: function (e) {
                    return e === e + 0;
                },
                isString: function (e) {
                    return e === e + "";
                },
                isBoolean: function (e) {
                    return !1 === e || !0 === e;
                },
                isFunction: function (e) {
                    return "[object Function]" === Object.prototype.toString.call(e);
                },
            },
            s = [
                {
                    litmus: a.isString,
                    conversions: {
                        THREE_CHAR_HEX: {
                            read: function (e) {
                                var t = e.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
                                return null !== t && { space: "HEX", hex: parseInt("0x" + t[1].toString() + t[1].toString() + t[2].toString() + t[2].toString() + t[3].toString() + t[3].toString(), 0) };
                            },
                            write: i,
                        },
                        SIX_CHAR_HEX: {
                            read: function (e) {
                                var t = e.match(/^#([A-F0-9]{6})$/i);
                                return null !== t && { space: "HEX", hex: parseInt("0x" + t[1].toString(), 0) };
                            },
                            write: i,
                        },
                        CSS_RGB: {
                            read: function (e) {
                                var t = e.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
                                return null !== t && { space: "RGB", r: parseFloat(t[1]), g: parseFloat(t[2]), b: parseFloat(t[3]) };
                            },
                            write: i,
                        },
                        CSS_RGBA: {
                            read: function (e) {
                                var t = e.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
                                return null !== t && { space: "RGB", r: parseFloat(t[1]), g: parseFloat(t[2]), b: parseFloat(t[3]), a: parseFloat(t[4]) };
                            },
                            write: i,
                        },
                    },
                },
                {
                    litmus: a.isNumber,
                    conversions: {
                        HEX: {
                            read: function (e) {
                                return { space: "HEX", hex: e, conversionName: "HEX" };
                            },
                            write: function (e) {
                                return e.hex;
                            },
                        },
                    },
                },
                {
                    litmus: a.isArray,
                    conversions: {
                        RGB_ARRAY: {
                            read: function (e) {
                                return 3 === e.length && { space: "RGB", r: e[0], g: e[1], b: e[2] };
                            },
                            write: function (e) {
                                return [e.r, e.g, e.b];
                            },
                        },
                        RGBA_ARRAY: {
                            read: function (e) {
                                return 4 === e.length && { space: "RGB", r: e[0], g: e[1], b: e[2], a: e[3] };
                            },
                            write: function (e) {
                                return [e.r, e.g, e.b, e.a];
                            },
                        },
                    },
                },
                {
                    litmus: a.isObject,
                    conversions: {
                        RGBA_OBJ: {
                            read: function (e) {
                                return !!(a.isNumber(e.r) && a.isNumber(e.g) && a.isNumber(e.b) && a.isNumber(e.a)) && { space: "RGB", r: e.r, g: e.g, b: e.b, a: e.a };
                            },
                            write: function (e) {
                                return { r: e.r, g: e.g, b: e.b, a: e.a };
                            },
                        },
                        RGB_OBJ: {
                            read: function (e) {
                                return !!(a.isNumber(e.r) && a.isNumber(e.g) && a.isNumber(e.b)) && { space: "RGB", r: e.r, g: e.g, b: e.b };
                            },
                            write: function (e) {
                                return { r: e.r, g: e.g, b: e.b };
                            },
                        },
                        HSVA_OBJ: {
                            read: function (e) {
                                return !!(a.isNumber(e.h) && a.isNumber(e.s) && a.isNumber(e.v) && a.isNumber(e.a)) && { space: "HSV", h: e.h, s: e.s, v: e.v, a: e.a };
                            },
                            write: function (e) {
                                return { h: e.h, s: e.s, v: e.v, a: e.a };
                            },
                        },
                        HSV_OBJ: {
                            read: function (e) {
                                return !!(a.isNumber(e.h) && a.isNumber(e.s) && a.isNumber(e.v)) && { space: "HSV", h: e.h, s: e.s, v: e.v };
                            },
                            write: function (e) {
                                return { h: e.h, s: e.s, v: e.v };
                            },
                        },
                    },
                },
            ],
            c = void 0,
            l = void 0,
            u = function () {
                l = !1;
                var e = arguments.length > 1 ? a.toArray(arguments) : arguments[0];
                return (
                    a.each(s, function (t) {
                        if (t.litmus(e))
                            return (
                                a.each(t.conversions, function (t, n) {
                                    if (((c = t.read(e)), !1 === l && !1 !== c)) return (l = c), (c.conversionName = n), (c.conversion = t), a.BREAK;
                                }),
                                a.BREAK
                            );
                    }),
                    l
                );
            },
            h = void 0,
            d = {
                hsv_to_rgb: function (e, t, n) {
                    var i = Math.floor(e / 60) % 6,
                        r = e / 60 - Math.floor(e / 60),
                        o = n * (1 - t),
                        a = n * (1 - r * t),
                        s = n * (1 - (1 - r) * t),
                        c = [
                            [n, s, o],
                            [a, n, o],
                            [o, n, s],
                            [o, a, n],
                            [s, o, n],
                            [n, o, a],
                        ][i];
                    return { r: 255 * c[0], g: 255 * c[1], b: 255 * c[2] };
                },
                rgb_to_hsv: function (e, t, n) {
                    var i = Math.min(e, t, n),
                        r = Math.max(e, t, n),
                        o = r - i,
                        a = void 0;
                    return 0 === r ? { h: NaN, s: 0, v: 0 } : ((a = e === r ? (t - n) / o : t === r ? 2 + (n - e) / o : 4 + (e - t) / o), (a /= 6) < 0 && (a += 1), { h: 360 * a, s: o / r, v: r / 255 });
                },
                rgb_to_hex: function (e, t, n) {
                    var i = this.hex_with_component(0, 2, e);
                    return (i = this.hex_with_component(i, 1, t)), (i = this.hex_with_component(i, 0, n));
                },
                component_from_hex: function (e, t) {
                    return (e >> (8 * t)) & 255;
                },
                hex_with_component: function (e, t, n) {
                    return (n << (h = 8 * t)) | (e & ~(255 << h));
                },
            },
            p =
                "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
                    ? function (e) {
                          return typeof e;
                      }
                    : function (e) {
                          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
                      },
            f = function (e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
            },
            m = (function () {
                function e(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var i = t[n];
                        (i.enumerable = i.enumerable || !1), (i.configurable = !0), "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
                    }
                }
                return function (t, n, i) {
                    return n && e(t.prototype, n), i && e(t, i), t;
                };
            })(),
            v = function e(t, n, i) {
                null === t && (t = Function.prototype);
                var r = Object.getOwnPropertyDescriptor(t, n);
                if (void 0 === r) {
                    var o = Object.getPrototypeOf(t);
                    return null === o ? void 0 : e(o, n, i);
                }
                if ("value" in r) return r.value;
                var a = r.get;
                return void 0 !== a ? a.call(i) : void 0;
            },
            g = function (e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
                (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
            },
            y = function (e, t) {
                if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return !t || ("object" != typeof t && "function" != typeof t) ? e : t;
            },
            x = (function () {
                function e() {
                    if ((f(this, e), (this.__state = u.apply(this, arguments)), !1 === this.__state)) throw new Error("Failed to interpret color arguments");
                    this.__state.a = this.__state.a || 1;
                }
                return (
                    m(e, [
                        {
                            key: "toString",
                            value: function () {
                                return i(this);
                            },
                        },
                        {
                            key: "toHexString",
                            value: function () {
                                return i(this, !0);
                            },
                        },
                        {
                            key: "toOriginal",
                            value: function () {
                                return this.__state.conversion.write(this);
                            },
                        },
                    ]),
                    e
                );
            })();
        function _(e, t, n) {
            Object.defineProperty(e, t, {
                get: function () {
                    return "RGB" === this.__state.space ? this.__state[t] : (x.recalculateRGB(this, t, n), this.__state[t]);
                },
                set: function (e) {
                    "RGB" !== this.__state.space && (x.recalculateRGB(this, t, n), (this.__state.space = "RGB")), (this.__state[t] = e);
                },
            });
        }
        function b(e, t) {
            Object.defineProperty(e, t, {
                get: function () {
                    return "HSV" === this.__state.space ? this.__state[t] : (x.recalculateHSV(this), this.__state[t]);
                },
                set: function (e) {
                    "HSV" !== this.__state.space && (x.recalculateHSV(this), (this.__state.space = "HSV")), (this.__state[t] = e);
                },
            });
        }
        (x.recalculateRGB = function (e, t, n) {
            if ("HEX" === e.__state.space) e.__state[t] = d.component_from_hex(e.__state.hex, n);
            else {
                if ("HSV" !== e.__state.space) throw new Error("Corrupted color state");
                a.extend(e.__state, d.hsv_to_rgb(e.__state.h, e.__state.s, e.__state.v));
            }
        }),
            (x.recalculateHSV = function (e) {
                var t = d.rgb_to_hsv(e.r, e.g, e.b);
                a.extend(e.__state, { s: t.s, v: t.v }), a.isNaN(t.h) ? a.isUndefined(e.__state.h) && (e.__state.h = 0) : (e.__state.h = t.h);
            }),
            (x.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"]),
            _(x.prototype, "r", 2),
            _(x.prototype, "g", 1),
            _(x.prototype, "b", 0),
            b(x.prototype, "h"),
            b(x.prototype, "s"),
            b(x.prototype, "v"),
            Object.defineProperty(x.prototype, "a", {
                get: function () {
                    return this.__state.a;
                },
                set: function (e) {
                    this.__state.a = e;
                },
            }),
            Object.defineProperty(x.prototype, "hex", {
                get: function () {
                    return "HEX" !== !this.__state.space && (this.__state.hex = d.rgb_to_hex(this.r, this.g, this.b)), this.__state.hex;
                },
                set: function (e) {
                    (this.__state.space = "HEX"), (this.__state.hex = e);
                },
            });
        var w = (function () {
                function e(t, n) {
                    f(this, e), (this.initialValue = t[n]), (this.domElement = document.createElement("div")), (this.object = t), (this.property = n), (this.__onChange = void 0), (this.__onFinishChange = void 0);
                }
                return (
                    m(e, [
                        {
                            key: "onChange",
                            value: function (e) {
                                return (this.__onChange = e), this;
                            },
                        },
                        {
                            key: "onFinishChange",
                            value: function (e) {
                                return (this.__onFinishChange = e), this;
                            },
                        },
                        {
                            key: "setValue",
                            value: function (e) {
                                return (this.object[this.property] = e), this.__onChange && this.__onChange.call(this, e), this.updateDisplay(), this;
                            },
                        },
                        {
                            key: "getValue",
                            value: function () {
                                return this.object[this.property];
                            },
                        },
                        {
                            key: "updateDisplay",
                            value: function () {
                                return this;
                            },
                        },
                        {
                            key: "isModified",
                            value: function () {
                                return this.initialValue !== this.getValue();
                            },
                        },
                    ]),
                    e
                );
            })(),
            M = {};
        a.each({ HTMLEvents: ["change"], MouseEvents: ["click", "mousemove", "mouseup", "mousedown", "mouseover", "mouseout"], KeyboardEvents: ["keydown"] }, function (e, t) {
            a.each(e, function (e) {
                M[e] = t;
            });
        });
        var S = /(\d+(\.\d+)?)px/;
        function E(e) {
            if ("0" === e || a.isUndefined(e)) return 0;
            var t = e.match(S);
            return a.isNull(t) ? 0 : parseFloat(t[1]);
        }
        var T = {
                makeSelectable: function (e, t) {
                    void 0 !== e &&
                        void 0 !== e.style &&
                        ((e.onselectstart = t
                            ? function () {
                                  return !1;
                              }
                            : function () {}),
                        (e.style.MozUserSelect = t ? "auto" : "none"),
                        (e.style.KhtmlUserSelect = t ? "auto" : "none"),
                        (e.unselectable = t ? "on" : "off"));
                },
                makeFullscreen: function (e, t, n) {
                    var i = n,
                        r = t;
                    a.isUndefined(r) && (r = !0), a.isUndefined(i) && (i = !0), (e.style.position = "absolute"), r && ((e.style.left = 0), (e.style.right = 0)), i && ((e.style.top = 0), (e.style.bottom = 0));
                },
                fakeEvent: function (e, t, n, i) {
                    var r = n || {},
                        o = M[t];
                    if (!o) throw new Error("Event type " + t + " not supported.");
                    var s = document.createEvent(o);
                    switch (o) {
                        case "MouseEvents":
                            var c = r.x || r.clientX || 0,
                                l = r.y || r.clientY || 0;
                            s.initMouseEvent(t, r.bubbles || !1, r.cancelable || !0, window, r.clickCount || 1, 0, 0, c, l, !1, !1, !1, !1, 0, null);
                            break;
                        case "KeyboardEvents":
                            var u = s.initKeyboardEvent || s.initKeyEvent;
                            a.defaults(r, { cancelable: !0, ctrlKey: !1, altKey: !1, shiftKey: !1, metaKey: !1, keyCode: void 0, charCode: void 0 }),
                                u(t, r.bubbles || !1, r.cancelable, window, r.ctrlKey, r.altKey, r.shiftKey, r.metaKey, r.keyCode, r.charCode);
                            break;
                        default:
                            s.initEvent(t, r.bubbles || !1, r.cancelable || !0);
                    }
                    a.defaults(s, i), e.dispatchEvent(s);
                },
                bind: function (e, t, n, i) {
                    var r = i || !1;
                    return e.addEventListener ? e.addEventListener(t, n, r) : e.attachEvent && e.attachEvent("on" + t, n), T;
                },
                unbind: function (e, t, n, i) {
                    var r = i || !1;
                    return e.removeEventListener ? e.removeEventListener(t, n, r) : e.detachEvent && e.detachEvent("on" + t, n), T;
                },
                addClass: function (e, t) {
                    if (void 0 === e.className) e.className = t;
                    else if (e.className !== t) {
                        var n = e.className.split(/ +/);
                        -1 === n.indexOf(t) && (n.push(t), (e.className = n.join(" ").replace(/^\s+/, "").replace(/\s+$/, "")));
                    }
                    return T;
                },
                removeClass: function (e, t) {
                    if (t)
                        if (e.className === t) e.removeAttribute("class");
                        else {
                            var n = e.className.split(/ +/),
                                i = n.indexOf(t);
                            -1 !== i && (n.splice(i, 1), (e.className = n.join(" ")));
                        }
                    else e.className = void 0;
                    return T;
                },
                hasClass: function (e, t) {
                    return new RegExp("(?:^|\\s+)" + t + "(?:\\s+|$)").test(e.className) || !1;
                },
                getWidth: function (e) {
                    var t = getComputedStyle(e);
                    return E(t["border-left-width"]) + E(t["border-right-width"]) + E(t["padding-left"]) + E(t["padding-right"]) + E(t.width);
                },
                getHeight: function (e) {
                    var t = getComputedStyle(e);
                    return E(t["border-top-width"]) + E(t["border-bottom-width"]) + E(t["padding-top"]) + E(t["padding-bottom"]) + E(t.height);
                },
                getOffset: function (e) {
                    var t = e,
                        n = { left: 0, top: 0 };
                    if (t.offsetParent)
                        do {
                            (n.left += t.offsetLeft), (n.top += t.offsetTop), (t = t.offsetParent);
                        } while (t);
                    return n;
                },
                isActive: function (e) {
                    return e === document.activeElement && (e.type || e.href);
                },
            },
            A = (function (e) {
                function t(e, n) {
                    f(this, t);
                    var i = y(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n)),
                        r = i;
                    return (
                        (i.__prev = i.getValue()),
                        (i.__checkbox = document.createElement("input")),
                        i.__checkbox.setAttribute("type", "checkbox"),
                        T.bind(
                            i.__checkbox,
                            "change",
                            function () {
                                r.setValue(!r.__prev);
                            },
                            !1
                        ),
                        i.domElement.appendChild(i.__checkbox),
                        i.updateDisplay(),
                        i
                    );
                }
                return (
                    g(t, e),
                    m(t, [
                        {
                            key: "setValue",
                            value: function (e) {
                                var n = v(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "setValue", this).call(this, e);
                                return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), (this.__prev = this.getValue()), n;
                            },
                        },
                        {
                            key: "updateDisplay",
                            value: function () {
                                return (
                                    !0 === this.getValue() ? (this.__checkbox.setAttribute("checked", "checked"), (this.__checkbox.checked = !0), (this.__prev = !0)) : ((this.__checkbox.checked = !1), (this.__prev = !1)),
                                    v(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "updateDisplay", this).call(this)
                                );
                            },
                        },
                    ]),
                    t
                );
            })(w),
            L = (function (e) {
                function t(e, n, i) {
                    f(this, t);
                    var r = y(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n)),
                        o = i,
                        s = r;
                    if (((r.__select = document.createElement("select")), a.isArray(o))) {
                        var c = {};
                        a.each(o, function (e) {
                            c[e] = e;
                        }),
                            (o = c);
                    }
                    return (
                        a.each(o, function (e, t) {
                            var n = document.createElement("option");
                            (n.innerHTML = t), n.setAttribute("value", e), s.__select.appendChild(n);
                        }),
                        r.updateDisplay(),
                        T.bind(r.__select, "change", function () {
                            var e = this.options[this.selectedIndex].value;
                            s.setValue(e);
                        }),
                        r.domElement.appendChild(r.__select),
                        r
                    );
                }
                return (
                    g(t, e),
                    m(t, [
                        {
                            key: "setValue",
                            value: function (e) {
                                var n = v(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "setValue", this).call(this, e);
                                return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), n;
                            },
                        },
                        {
                            key: "updateDisplay",
                            value: function () {
                                return T.isActive(this.__select) ? this : ((this.__select.value = this.getValue()), v(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "updateDisplay", this).call(this));
                            },
                        },
                    ]),
                    t
                );
            })(w),
            C = (function (e) {
                function t(e, n) {
                    f(this, t);
                    var i = y(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n)),
                        r = i;
                    function o() {
                        r.setValue(r.__input.value);
                    }
                    return (
                        (i.__input = document.createElement("input")),
                        i.__input.setAttribute("type", "text"),
                        T.bind(i.__input, "keyup", o),
                        T.bind(i.__input, "change", o),
                        T.bind(i.__input, "blur", function () {
                            r.__onFinishChange && r.__onFinishChange.call(r, r.getValue());
                        }),
                        T.bind(i.__input, "keydown", function (e) {
                            13 === e.keyCode && this.blur();
                        }),
                        i.updateDisplay(),
                        i.domElement.appendChild(i.__input),
                        i
                    );
                }
                return (
                    g(t, e),
                    m(t, [
                        {
                            key: "updateDisplay",
                            value: function () {
                                return T.isActive(this.__input) || (this.__input.value = this.getValue()), v(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "updateDisplay", this).call(this);
                            },
                        },
                    ]),
                    t
                );
            })(w);
        function R(e) {
            var t = e.toString();
            return t.indexOf(".") > -1 ? t.length - t.indexOf(".") - 1 : 0;
        }
        var P = (function (e) {
            function t(e, n, i) {
                f(this, t);
                var r = y(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n)),
                    o = i || {};
                return (
                    (r.__min = o.min),
                    (r.__max = o.max),
                    (r.__step = o.step),
                    a.isUndefined(r.__step) ? (0 === r.initialValue ? (r.__impliedStep = 1) : (r.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(r.initialValue)) / Math.LN10)) / 10)) : (r.__impliedStep = r.__step),
                    (r.__precision = R(r.__impliedStep)),
                    r
                );
            }
            return (
                g(t, e),
                m(t, [
                    {
                        key: "setValue",
                        value: function (e) {
                            var n = e;
                            return (
                                void 0 !== this.__min && n < this.__min ? (n = this.__min) : void 0 !== this.__max && n > this.__max && (n = this.__max),
                                void 0 !== this.__step && n % this.__step != 0 && (n = Math.round(n / this.__step) * this.__step),
                                v(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "setValue", this).call(this, n)
                            );
                        },
                    },
                    {
                        key: "min",
                        value: function (e) {
                            return (this.__min = e), this;
                        },
                    },
                    {
                        key: "max",
                        value: function (e) {
                            return (this.__max = e), this;
                        },
                    },
                    {
                        key: "step",
                        value: function (e) {
                            return (this.__step = e), (this.__impliedStep = e), (this.__precision = R(e)), this;
                        },
                    },
                ]),
                t
            );
        })(w);
        var O = (function (e) {
            function t(e, n, i) {
                f(this, t);
                var r = y(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n, i));
                r.__truncationSuspended = !1;
                var o = r,
                    s = void 0;
                function c() {
                    o.__onFinishChange && o.__onFinishChange.call(o, o.getValue());
                }
                function l(e) {
                    var t = s - e.clientY;
                    o.setValue(o.getValue() + t * o.__impliedStep), (s = e.clientY);
                }
                function u() {
                    T.unbind(window, "mousemove", l), T.unbind(window, "mouseup", u), c();
                }
                return (
                    (r.__input = document.createElement("input")),
                    r.__input.setAttribute("type", "text"),
                    T.bind(r.__input, "change", function () {
                        var e = parseFloat(o.__input.value);
                        a.isNaN(e) || o.setValue(e);
                    }),
                    T.bind(r.__input, "blur", function () {
                        c();
                    }),
                    T.bind(r.__input, "mouseover", function (e) {
                        T.bind(window, "mousemove", l), T.bind(window, "mouseout", u), (s = e.clientY);
                    }),
                    T.bind(r.__input, "keydown", function (e) {
                        13 === e.keyCode && ((o.__truncationSuspended = !0), this.blur(), (o.__truncationSuspended = !1), c());
                    }),
                    r.updateDisplay(),
                    r.domElement.appendChild(r.__input),
                    r
                );
            }
            return (
                g(t, e),
                m(t, [
                    {
                        key: "updateDisplay",
                        value: function () {
                            var e, n, i;
                            return (
                                (this.__input.value = this.__truncationSuspended ? this.getValue() : ((e = this.getValue()), (n = this.__precision), (i = Math.pow(10, n)), Math.round(e * i) / i)),
                                v(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "updateDisplay", this).call(this)
                            );
                        },
                    },
                ]),
                t
            );
        })(P);
        function D(e, t, n, i, r) {
            return i + ((e - t) / (n - t)) * (r - i);
        }
        var I = (function (e) {
                function t(e, n, i, r, o) {
                    f(this, t);
                    var a = y(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n, { min: i, max: r, step: o })),
                        s = a;
                    function c(e) {
                        e.preventDefault();
                        var t = s.__background.getBoundingClientRect();
                        return s.setValue(D(e.clientX, t.left, t.right, s.__min, s.__max)), !1;
                    }
                    function l() {
                        T.unbind(window, "mousemove", c), T.unbind(window, "mouseup", l), s.__onFinishChange && s.__onFinishChange.call(s, s.getValue());
                    }
                    function u(e) {
                        var t = e.touches[0].clientX,
                            n = s.__background.getBoundingClientRect();
                        s.setValue(D(t, n.left, n.right, s.__min, s.__max));
                    }
                    function h() {
                        T.unbind(window, "touchmove", u), T.unbind(window, "touchend", h), s.__onFinishChange && s.__onFinishChange.call(s, s.getValue());
                    }
                    return (
                        (a.__background = document.createElement("div")),
                        (a.__foreground = document.createElement("div")),
                        T.bind(a.__background, "mouseover", function (e) {
                            document.activeElement.blur(), T.bind(window, "mousemove", c), T.bind(window, "mouseout", l), c(e);
                        }),
                        T.bind(a.__background, "touchstart", function (e) {
                            if (1 !== e.touches.length) return;
                            T.bind(window, "touchmove", u), T.bind(window, "touchend", h), u(e);
                        }),
                        T.addClass(a.__background, "slider"),
                        T.addClass(a.__foreground, "slider-fg"),
                        a.updateDisplay(),
                        a.__background.appendChild(a.__foreground),
                        a.domElement.appendChild(a.__background),
                        a
                    );
                }
                return (
                    g(t, e),
                    m(t, [
                        {
                            key: "updateDisplay",
                            value: function () {
                                var e = (this.getValue() - this.__min) / (this.__max - this.__min);
                                return (this.__foreground.style.width = 100 * e + "%"), v(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "updateDisplay", this).call(this);
                            },
                        },
                    ]),
                    t
                );
            })(P),
            N = (function (e) {
                function t(e, n, i) {
                    f(this, t);
                    var r = y(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n)),
                        o = r;
                    return (
                        (r.__button = document.createElement("div")),
                        (r.__button.innerHTML = void 0 === i ? "Fire" : i),
                        T.bind(r.__button, "click", function (e) {
                            return e.preventDefault(), o.fire(), !1;
                        }),
                        T.addClass(r.__button, "button"),
                        r.domElement.appendChild(r.__button),
                        r
                    );
                }
                return (
                    g(t, e),
                    m(t, [
                        {
                            key: "fire",
                            value: function () {
                                this.__onChange && this.__onChange.call(this), this.getValue().call(this.object), this.__onFinishChange && this.__onFinishChange.call(this, this.getValue());
                            },
                        },
                    ]),
                    t
                );
            })(w),
            U = (function (e) {
                function t(e, n) {
                    f(this, t);
                    var i = y(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n));
                    (i.__color = new x(i.getValue())), (i.__temp = new x(0));
                    var r = i;
                    (i.domElement = document.createElement("div")),
                        T.makeSelectable(i.domElement, !1),
                        (i.__selector = document.createElement("div")),
                        (i.__selector.className = "selector"),
                        (i.__saturation_field = document.createElement("div")),
                        (i.__saturation_field.className = "saturation-field"),
                        (i.__field_knob = document.createElement("div")),
                        (i.__field_knob.className = "field-knob"),
                        (i.__field_knob_border = "2px solid "),
                        (i.__hue_knob = document.createElement("div")),
                        (i.__hue_knob.className = "hue-knob"),
                        (i.__hue_field = document.createElement("div")),
                        (i.__hue_field.className = "hue-field"),
                        (i.__input = document.createElement("input")),
                        (i.__input.type = "text"),
                        (i.__input_textShadow = "0 1px 1px "),
                        T.bind(i.__input, "keydown", function (e) {
                            13 === e.keyCode && p.call(this);
                        }),
                        T.bind(i.__input, "blur", p),
                        T.bind(i.__selector, "mouseover", function () {
                            T.addClass(this, "drag").bind(window, "mouseout", function () {
                                T.removeClass(r.__selector, "drag");
                            });
                        }),
                        T.bind(i.__selector, "touchstart", function () {
                            T.addClass(this, "drag").bind(window, "touchend", function () {
                                T.removeClass(r.__selector, "drag");
                            });
                        });
                    var o,
                        s = document.createElement("div");
                    function c(e) {
                        v(e), T.bind(window, "mouseover", v), T.bind(window, "touchmove", v), T.bind(window, "mouseout", h), T.bind(window, "touchend", h);
                    }
                    function l(e) {
                        g(e), T.bind(window, "mouseover", g), T.bind(window, "touchmove", g), T.bind(window, "mouseout", d), T.bind(window, "touchend", d);
                    }
                    function h() {
                        T.unbind(window, "mouseover", v), T.unbind(window, "touchmove", v), T.unbind(window, "mouseout", h), T.unbind(window, "touchend", h), m();
                    }
                    function d() {
                        T.unbind(window, "mouseover", g), T.unbind(window, "touchmove", g), T.unbind(window, "mouseout", d), T.unbind(window, "touchend", d), m();
                    }
                    function p() {
                        var e = u(this.value);
                        !1 !== e ? ((r.__color.__state = e), r.setValue(r.__color.toOriginal())) : (this.value = r.__color.toString());
                    }
                    function m() {
                        r.__onFinishChange && r.__onFinishChange.call(r, r.__color.toOriginal());
                    }
                    function v(e) {
                        -1 === e.type.indexOf("touch") && e.preventDefault();
                        var t = r.__saturation_field.getBoundingClientRect(),
                            n = (e.touches && e.touches[0]) || e,
                            i = n.clientX,
                            o = n.clientY,
                            a = (i - t.left) / (t.right - t.left),
                            s = 1 - (o - t.top) / (t.bottom - t.top);
                        return s > 1 ? (s = 1) : s < 0 && (s = 0), a > 1 ? (a = 1) : a < 0 && (a = 0), (r.__color.v = s), (r.__color.s = a), r.setValue(r.__color.toOriginal()), !1;
                    }
                    function g(e) {
                        -1 === e.type.indexOf("touch") && e.preventDefault();
                        var t = r.__hue_field.getBoundingClientRect(),
                            n = 1 - (((e.touches && e.touches[0]) || e).clientY - t.top) / (t.bottom - t.top);
                        return n > 1 ? (n = 1) : n < 0 && (n = 0), (r.__color.h = 360 * n), r.setValue(r.__color.toOriginal()), !1;
                    }
                    return (
                        a.extend(i.__selector.style, { width: "122px", height: "102px", padding: "3px", backgroundColor: "#222", boxShadow: "0px 1px 3px rgba(0,0,0,0.3)" }),
                        a.extend(i.__field_knob.style, {
                            position: "absolute",
                            width: "12px",
                            height: "12px",
                            border: i.__field_knob_border + (i.__color.v < 0.5 ? "#fff" : "#000"),
                            boxShadow: "0px 1px 3px rgba(0,0,0,0.5)",
                            borderRadius: "12px",
                            zIndex: 1,
                        }),
                        a.extend(i.__hue_knob.style, { position: "absolute", width: "15px", height: "2px", borderRight: "4px solid #fff", zIndex: 1 }),
                        a.extend(i.__saturation_field.style, { width: "100px", height: "100px", border: "1px solid #555", marginRight: "3px", display: "inline-block", cursor: "pointer" }),
                        a.extend(s.style, { width: "100%", height: "100%", background: "none" }),
                        z(s, "top", "rgba(0,0,0,0)", "#000"),
                        a.extend(i.__hue_field.style, { width: "15px", height: "100px", border: "1px solid #555", cursor: "ns-resize", position: "absolute", top: "3px", right: "3px" }),
                        ((o = i.__hue_field).style.background = ""),
                        (o.style.cssText += "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);"),
                        (o.style.cssText += "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"),
                        (o.style.cssText += "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"),
                        (o.style.cssText += "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"),
                        (o.style.cssText += "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"),
                        a.extend(i.__input.style, { outline: "none", textAlign: "center", color: "#fff", border: 0, fontWeight: "bold", textShadow: i.__input_textShadow + "rgba(0,0,0,0.7)" }),
                        T.bind(i.__saturation_field, "mouseover", c),
                        T.bind(i.__saturation_field, "touchstart", c),
                        T.bind(i.__field_knob, "mouseover", c),
                        T.bind(i.__field_knob, "touchstart", c),
                        T.bind(i.__hue_field, "mouseover", l),
                        T.bind(i.__hue_field, "touchstart", l),
                        i.__saturation_field.appendChild(s),
                        i.__selector.appendChild(i.__field_knob),
                        i.__selector.appendChild(i.__saturation_field),
                        i.__selector.appendChild(i.__hue_field),
                        i.__hue_field.appendChild(i.__hue_knob),
                        i.domElement.appendChild(i.__input),
                        i.domElement.appendChild(i.__selector),
                        i.updateDisplay(),
                        i
                    );
                }
                return (
                    g(t, e),
                    m(t, [
                        {
                            key: "updateDisplay",
                            value: function () {
                                var e = u(this.getValue());
                                if (!1 !== e) {
                                    var t = !1;
                                    a.each(
                                        x.COMPONENTS,
                                        function (n) {
                                            if (!a.isUndefined(e[n]) && !a.isUndefined(this.__color.__state[n]) && e[n] !== this.__color.__state[n]) return (t = !0), {};
                                        },
                                        this
                                    ),
                                        t && a.extend(this.__color.__state, e);
                                }
                                a.extend(this.__temp.__state, this.__color.__state), (this.__temp.a = 1);
                                var n = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0,
                                    i = 255 - n;
                                a.extend(this.__field_knob.style, {
                                    marginLeft: 100 * this.__color.s - 7 + "px",
                                    marginTop: 100 * (1 - this.__color.v) - 7 + "px",
                                    backgroundColor: this.__temp.toHexString(),
                                    border: this.__field_knob_border + "rgb(" + n + "," + n + "," + n + ")",
                                }),
                                    (this.__hue_knob.style.marginTop = 100 * (1 - this.__color.h / 360) + "px"),
                                    (this.__temp.s = 1),
                                    (this.__temp.v = 1),
                                    z(this.__saturation_field, "left", "#fff", this.__temp.toHexString()),
                                    (this.__input.value = this.__color.toString()),
                                    a.extend(this.__input.style, { backgroundColor: this.__color.toHexString(), color: "rgb(" + n + "," + n + "," + n + ")", textShadow: this.__input_textShadow + "rgba(" + i + "," + i + "," + i + ",.7)" });
                            },
                        },
                    ]),
                    t
                );
            })(w),
            B = ["-moz-", "-o-", "-webkit-", "-ms-", ""];
        function z(e, t, n, i) {
            (e.style.background = ""),
                a.each(B, function (r) {
                    e.style.cssText += "background: " + r + "linear-gradient(" + t + ", " + n + " 0%, " + i + " 100%); ";
                });
        }
        var F = function (e, t) {
                var n = t || document,
                    i = document.createElement("style");
                (i.type = "text/css"), (i.innerHTML = e);
                var r = n.getElementsByTagName("head")[0];
                try {
                    r.appendChild(i);
                } catch (e) {}
            },
            G =
                '<div id="dg-save" class="dg dialogue">\n\n  Here\'s the new load parameter for your <code>GUI</code>\'s constructor:\n\n  <textarea id="dg-new-constructor"></textarea>\n\n  <div id="dg-save-locally">\n\n    <input id="dg-local-storage" type="checkbox"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id="dg-local-explain">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>\'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>',
            H = function (e, t) {
                var n = e[t];
                return a.isArray(arguments[2]) || a.isObject(arguments[2])
                    ? new L(e, t, arguments[2])
                    : a.isNumber(n)
                    ? a.isNumber(arguments[2]) && a.isNumber(arguments[3])
                        ? a.isNumber(arguments[4])
                            ? new I(e, t, arguments[2], arguments[3], arguments[4])
                            : new I(e, t, arguments[2], arguments[3])
                        : a.isNumber(arguments[4])
                        ? new O(e, t, { min: arguments[2], max: arguments[3], step: arguments[4] })
                        : new O(e, t, { min: arguments[2], max: arguments[3] })
                    : a.isString(n)
                    ? new C(e, t)
                    : a.isFunction(n)
                    ? new N(e, t, "")
                    : a.isBoolean(n)
                    ? new A(e, t)
                    : null;
            };
        var V =
                window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                window.oRequestAnimationFrame ||
                window.msRequestAnimationFrame ||
                function (e) {
                    setTimeout(e, 1e3 / 60);
                },
            k = (function () {
                function e() {
                    f(this, e),
                        (this.backgroundElement = document.createElement("div")),
                        a.extend(this.backgroundElement.style, {
                            backgroundColor: "rgba(0,0,0,0.8)",
                            top: 0,
                            left: 0,
                            display: "none",
                            zIndex: "1000",
                            opacity: 0,
                            WebkitTransition: "opacity 0.2s linear",
                            transition: "opacity 0.2s linear",
                        }),
                        T.makeFullscreen(this.backgroundElement),
                        (this.backgroundElement.style.position = "fixed"),
                        (this.domElement = document.createElement("div")),
                        a.extend(this.domElement.style, {
                            position: "fixed",
                            display: "none",
                            zIndex: "1001",
                            opacity: 0,
                            WebkitTransition: "-webkit-transform 0.2s ease-out, opacity 0.2s linear",
                            transition: "transform 0.2s ease-out, opacity 0.2s linear",
                        }),
                        document.body.appendChild(this.backgroundElement),
                        document.body.appendChild(this.domElement);
                    var t = this;
                    T.bind(this.backgroundElement, "click", function () {
                        t.hide();
                    });
                }
                return (
                    m(e, [
                        {
                            key: "show",
                            value: function () {
                                var e = this;
                                (this.backgroundElement.style.display = "block"),
                                    (this.domElement.style.display = "block"),
                                    (this.domElement.style.opacity = 0),
                                    (this.domElement.style.webkitTransform = "scale(1.1)"),
                                    this.layout(),
                                    a.defer(function () {
                                        (e.backgroundElement.style.opacity = 1), (e.domElement.style.opacity = 1), (e.domElement.style.webkitTransform = "scale(1)");
                                    });
                            },
                        },
                        {
                            key: "hide",
                            value: function () {
                                var e = this,
                                    t = function t() {
                                        (e.domElement.style.display = "none"),
                                            (e.backgroundElement.style.display = "none"),
                                            T.unbind(e.domElement, "webkitTransitionEnd", t),
                                            T.unbind(e.domElement, "transitionend", t),
                                            T.unbind(e.domElement, "oTransitionEnd", t);
                                    };
                                T.bind(this.domElement, "webkitTransitionEnd", t),
                                    T.bind(this.domElement, "transitionend", t),
                                    T.bind(this.domElement, "oTransitionEnd", t),
                                    (this.backgroundElement.style.opacity = 0),
                                    (this.domElement.style.opacity = 0),
                                    (this.domElement.style.webkitTransform = "scale(1.1)");
                            },
                        },
                        {
                            key: "layout",
                            value: function () {
                                (this.domElement.style.left = window.innerWidth / 2 - T.getWidth(this.domElement) / 2 + "px"), (this.domElement.style.top = window.innerHeight / 2 - T.getHeight(this.domElement) / 2 + "px");
                            },
                        },
                    ]),
                    e
                );
            })();
        F(
            (function (e) {
                if (e && "undefined" != typeof window) {
                    var t = document.createElement("style");
                    return t.setAttribute("type", "text/css"), (t.innerHTML = e), document.head.appendChild(t), e;
                }
            })(
                ".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n"
            )
        );
        var j = "Default",
            W = (function () {
                try {
                    return !!window.localStorage;
                } catch (e) {
                    return !1;
                }
            })(),
            q = void 0,
            X = !0,
            Y = void 0,
            J = !1,
            Z = [],
            K = function e(t) {
                var n = this,
                    i = t || {};
                (this.domElement = document.createElement("div")),
                    (this.__ul = document.createElement("ul")),
                    this.domElement.appendChild(this.__ul),
                    T.addClass(this.domElement, "dg"),
                    (this.__folders = {}),
                    (this.__controllers = []),
                    (this.__rememberedObjects = []),
                    (this.__rememberedObjectIndecesToControllers = []),
                    (this.__listening = []),
                    (i = a.defaults(i, { closeOnTop: !1, autoPlace: !0, width: e.DEFAULT_WIDTH })),
                    (i = a.defaults(i, { resizable: i.autoPlace, hideable: i.autoPlace })),
                    a.isUndefined(i.load) ? (i.load = { preset: j }) : i.preset && (i.load.preset = i.preset),
                    a.isUndefined(i.parent) && i.hideable && Z.push(this),
                    (i.resizable = a.isUndefined(i.parent) && i.resizable),
                    i.autoPlace && a.isUndefined(i.scrollable) && (i.scrollable = !0);
                var r,
                    o = W && "true" === localStorage.getItem(ie(this, "isLocal")),
                    s = void 0,
                    c = void 0;
                if (
                    (Object.defineProperties(this, {
                        parent: {
                            get: function () {
                                return i.parent;
                            },
                        },
                        scrollable: {
                            get: function () {
                                return i.scrollable;
                            },
                        },
                        autoPlace: {
                            get: function () {
                                return i.autoPlace;
                            },
                        },
                        closeOnTop: {
                            get: function () {
                                return i.closeOnTop;
                            },
                        },
                        preset: {
                            get: function () {
                                return n.parent ? n.getRoot().preset : i.load.preset;
                            },
                            set: function (e) {
                                n.parent ? (n.getRoot().preset = e) : (i.load.preset = e),
                                    (function (e) {
                                        for (var t = 0; t < e.__preset_select.length; t++) e.__preset_select[t].value === e.preset && (e.__preset_select.selectedIndex = t);
                                    })(this),
                                    n.revert();
                            },
                        },
                        width: {
                            get: function () {
                                return i.width;
                            },
                            set: function (e) {
                                (i.width = e), ce(n, e);
                            },
                        },
                        name: {
                            get: function () {
                                return i.name;
                            },
                            set: function (e) {
                                (i.name = e), c && (c.innerHTML = i.name);
                            },
                        },
                        closed: {
                            get: function () {
                                return i.closed;
                            },
                            set: function (t) {
                                (i.closed = t), i.closed ? T.addClass(n.__ul, e.CLASS_CLOSED) : T.removeClass(n.__ul, e.CLASS_CLOSED), this.onResize(), n.__closeButton && (n.__closeButton.innerHTML = t ? e.TEXT_OPEN : e.TEXT_CLOSED);
                            },
                        },
                        load: {
                            get: function () {
                                return i.load;
                            },
                        },
                        useLocalStorage: {
                            get: function () {
                                return o;
                            },
                            set: function (e) {
                                W && ((o = e), e ? T.bind(window, "unload", s) : T.unbind(window, "unload", s), localStorage.setItem(ie(n, "isLocal"), e));
                            },
                        },
                    }),
                    a.isUndefined(i.parent))
                ) {
                    if (((this.closed = i.closed || !1), T.addClass(this.domElement, e.CLASS_MAIN), T.makeSelectable(this.domElement, !1), W && o)) {
                        n.useLocalStorage = !0;
                        var l = localStorage.getItem(ie(this, "gui"));
                        l && (i.load = JSON.parse(l));
                    }
                    (this.__closeButton = document.createElement("div")),
                        (this.__closeButton.innerHTML = e.TEXT_CLOSED),
                        T.addClass(this.__closeButton, e.CLASS_CLOSE_BUTTON),
                        i.closeOnTop
                            ? (T.addClass(this.__closeButton, e.CLASS_CLOSE_TOP), this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0]))
                            : (T.addClass(this.__closeButton, e.CLASS_CLOSE_BOTTOM), this.domElement.appendChild(this.__closeButton)),
                        T.bind(this.__closeButton, "click", function () {
                            n.closed = !n.closed;
                        });
                } else {
                    void 0 === i.closed && (i.closed = !0);
                    var u = document.createTextNode(i.name);
                    T.addClass(u, "controller-name"), (c = Q(n, u));
                    T.addClass(this.__ul, e.CLASS_CLOSED),
                        T.addClass(c, "title"),
                        T.bind(c, "click", function (e) {
                            return e.preventDefault(), (n.closed = !n.closed), !1;
                        }),
                        i.closed || (this.closed = !1);
                }
                i.autoPlace &&
                    (a.isUndefined(i.parent) &&
                        (X && ((Y = document.createElement("div")), T.addClass(Y, "dg"), T.addClass(Y, e.CLASS_AUTO_PLACE_CONTAINER), document.body.appendChild(Y), (X = !1)),
                        Y.appendChild(this.domElement),
                        T.addClass(this.domElement, e.CLASS_AUTO_PLACE)),
                    this.parent || ce(n, i.width)),
                    (this.__resizeHandler = function () {
                        n.onResizeDebounced();
                    }),
                    T.bind(window, "resize", this.__resizeHandler),
                    T.bind(this.__ul, "webkitTransitionEnd", this.__resizeHandler),
                    T.bind(this.__ul, "transitionend", this.__resizeHandler),
                    T.bind(this.__ul, "oTransitionEnd", this.__resizeHandler),
                    this.onResize(),
                    i.resizable && se(this),
                    (s = function () {
                        W && "true" === localStorage.getItem(ie(n, "isLocal")) && localStorage.setItem(ie(n, "gui"), JSON.stringify(n.getSaveObject()));
                    }),
                    (this.saveToLocalStorageIfPossible = s),
                    i.parent ||
                        (((r = n.getRoot()).width += 1),
                        a.defer(function () {
                            r.width -= 1;
                        }));
            };
        function Q(e, t, n) {
            var i = document.createElement("li");
            return t && i.appendChild(t), n ? e.__ul.insertBefore(i, n) : e.__ul.appendChild(i), e.onResize(), i;
        }
        function $(e) {
            T.unbind(window, "resize", e.__resizeHandler), e.saveToLocalStorageIfPossible && T.unbind(window, "unload", e.saveToLocalStorageIfPossible);
        }
        function ee(e, t) {
            var n = e.__preset_select[e.__preset_select.selectedIndex];
            n.innerHTML = t ? n.value + "*" : n.value;
        }
        function te(e, t) {
            var n = e.getRoot(),
                i = n.__rememberedObjects.indexOf(t.object);
            if (-1 !== i) {
                var r = n.__rememberedObjectIndecesToControllers[i];
                if ((void 0 === r && ((r = {}), (n.__rememberedObjectIndecesToControllers[i] = r)), (r[t.property] = t), n.load && n.load.remembered)) {
                    var o = n.load.remembered,
                        a = void 0;
                    if (o[e.preset]) a = o[e.preset];
                    else {
                        if (!o[j]) return;
                        a = o[j];
                    }
                    if (a[i] && void 0 !== a[i][t.property]) {
                        var s = a[i][t.property];
                        (t.initialValue = s), t.setValue(s);
                    }
                }
            }
        }
        function ne(e, t, n, i) {
            if (void 0 === t[n]) throw new Error('Object "' + t + '" has no property "' + n + '"');
            var r = void 0;
            if (i.color) r = new U(t, n);
            else {
                var o = [t, n].concat(i.factoryArgs);
                r = H.apply(e, o);
            }
            i.before instanceof w && (i.before = i.before.__li), te(e, r), T.addClass(r.domElement, "c");
            var s = document.createElement("span");
            T.addClass(s, "property-name"), (s.innerHTML = r.property);
            var c = document.createElement("div");
            c.appendChild(s), c.appendChild(r.domElement);
            var l = Q(e, c, i.before);
            return (
                T.addClass(l, K.CLASS_CONTROLLER_ROW),
                r instanceof U ? T.addClass(l, "color") : T.addClass(l, p(r.getValue())),
                (function (e, t, n) {
                    if (
                        ((n.__li = t),
                        (n.__gui = e),
                        a.extend(n, {
                            options: function (t) {
                                if (arguments.length > 1) {
                                    var i = n.__li.nextElementSibling;
                                    return n.remove(), ne(e, n.object, n.property, { before: i, factoryArgs: [a.toArray(arguments)] });
                                }
                                if (a.isArray(t) || a.isObject(t)) {
                                    var r = n.__li.nextElementSibling;
                                    return n.remove(), ne(e, n.object, n.property, { before: r, factoryArgs: [t] });
                                }
                            },
                            name: function (e) {
                                return (n.__li.firstElementChild.firstElementChild.innerHTML = e), n;
                            },
                            listen: function () {
                                return n.__gui.listen(n), n;
                            },
                            remove: function () {
                                return n.__gui.remove(n), n;
                            },
                        }),
                        n instanceof I)
                    ) {
                        var i = new O(n.object, n.property, { min: n.__min, max: n.__max, step: n.__step });
                        a.each(["updateDisplay", "onChange", "onFinishChange", "step", "min", "max"], function (e) {
                            var t = n[e],
                                r = i[e];
                            n[e] = i[e] = function () {
                                var e = Array.prototype.slice.call(arguments);
                                return r.apply(i, e), t.apply(n, e);
                            };
                        }),
                            T.addClass(t, "has-slider"),
                            n.domElement.insertBefore(i.domElement, n.domElement.firstElementChild);
                    } else if (n instanceof O) {
                        var r = function (t) {
                            if (a.isNumber(n.__min) && a.isNumber(n.__max)) {
                                var i = n.__li.firstElementChild.firstElementChild.innerHTML,
                                    r = n.__gui.__listening.indexOf(n) > -1;
                                n.remove();
                                var o = ne(e, n.object, n.property, { before: n.__li.nextElementSibling, factoryArgs: [n.__min, n.__max, n.__step] });
                                return o.name(i), r && o.listen(), o;
                            }
                            return t;
                        };
                        (n.min = a.compose(r, n.min)), (n.max = a.compose(r, n.max));
                    } else
                        n instanceof A
                            ? (T.bind(t, "click", function () {
                                  T.fakeEvent(n.__checkbox, "click");
                              }),
                              T.bind(n.__checkbox, "click", function (e) {
                                  e.stopPropagation();
                              }))
                            : n instanceof N
                            ? (T.bind(t, "click", function () {
                                  T.fakeEvent(n.__button, "click");
                              }),
                              T.bind(t, "mouseover", function () {
                                  T.addClass(n.__button, "hover");
                              }),
                              T.bind(t, "mouseout", function () {
                                  T.removeClass(n.__button, "hover");
                              }))
                            : n instanceof U &&
                              (T.addClass(t, "color"),
                              (n.updateDisplay = a.compose(function (e) {
                                  return (t.style.borderLeftColor = n.__color.toString()), e;
                              }, n.updateDisplay)),
                              n.updateDisplay());
                    n.setValue = a.compose(function (t) {
                        return e.getRoot().__preset_select && n.isModified() && ee(e.getRoot(), !0), t;
                    }, n.setValue);
                })(e, l, r),
                e.__controllers.push(r),
                r
            );
        }
        function ie(e, t) {
            return document.location.href + "." + t;
        }
        function re(e, t, n) {
            var i = document.createElement("option");
            (i.innerHTML = t), (i.value = t), e.__preset_select.appendChild(i), n && (e.__preset_select.selectedIndex = e.__preset_select.length - 1);
        }
        function oe(e, t) {
            t.style.display = e.useLocalStorage ? "block" : "none";
        }
        function ae(e) {
            var t = (e.__save_row = document.createElement("li"));
            T.addClass(e.domElement, "has-save"), e.__ul.insertBefore(t, e.__ul.firstChild), T.addClass(t, "save-row");
            var n = document.createElement("span");
            (n.innerHTML = "&nbsp;"), T.addClass(n, "button gears");
            var i = document.createElement("span");
            (i.innerHTML = "Save"), T.addClass(i, "button"), T.addClass(i, "save");
            var r = document.createElement("span");
            (r.innerHTML = "New"), T.addClass(r, "button"), T.addClass(r, "save-as");
            var o = document.createElement("span");
            (o.innerHTML = "Revert"), T.addClass(o, "button"), T.addClass(o, "revert");
            var s = (e.__preset_select = document.createElement("select"));
            if (
                (e.load && e.load.remembered
                    ? a.each(e.load.remembered, function (t, n) {
                          re(e, n, n === e.preset);
                      })
                    : re(e, j, !1),
                T.bind(s, "change", function () {
                    for (var t = 0; t < e.__preset_select.length; t++) e.__preset_select[t].innerHTML = e.__preset_select[t].value;
                    e.preset = this.value;
                }),
                t.appendChild(s),
                t.appendChild(n),
                t.appendChild(i),
                t.appendChild(r),
                t.appendChild(o),
                W)
            ) {
                var c = document.getElementById("dg-local-explain"),
                    l = document.getElementById("dg-local-storage");
                (document.getElementById("dg-save-locally").style.display = "block"),
                    "true" === localStorage.getItem(ie(0, "isLocal")) && l.setAttribute("checked", "checked"),
                    oe(e, c),
                    T.bind(l, "change", function () {
                        (e.useLocalStorage = !e.useLocalStorage), oe(e, c);
                    });
            }
            var u = document.getElementById("dg-new-constructor");
            T.bind(u, "keydown", function (e) {
                !e.metaKey || (67 !== e.which && 67 !== e.keyCode) || q.hide();
            }),
                T.bind(n, "click", function () {
                    (u.innerHTML = JSON.stringify(e.getSaveObject(), void 0, 2)), q.show(), u.focus(), u.select();
                }),
                T.bind(i, "click", function () {
                    e.save();
                }),
                T.bind(r, "click", function () {
                    var t = prompt("Enter a new preset name.");
                    t && e.saveAs(t);
                }),
                T.bind(o, "click", function () {
                    e.revert();
                });
        }
        function se(e) {
            var t = void 0;
            function n(n) {
                return n.preventDefault(), (e.width += t - n.clientX), e.onResize(), (t = n.clientX), !1;
            }
            function i() {
                T.removeClass(e.__closeButton, K.CLASS_DRAG), T.unbind(window, "mousemove", n), T.unbind(window, "mouseup", i);
            }
            function r(r) {
                return r.preventDefault(), (t = r.clientX), T.addClass(e.__closeButton, K.CLASS_DRAG), T.bind(window, "mousemove", n), T.bind(window, "mouseup", i), !1;
            }
            (e.__resize_handle = document.createElement("div")),
                a.extend(e.__resize_handle.style, { width: "6px", marginLeft: "-3px", height: "200px", cursor: "ew-resize", position: "absolute" }),
                T.bind(e.__resize_handle, "mouseover", r),
                T.bind(e.__closeButton, "mouseover", r),
                e.domElement.insertBefore(e.__resize_handle, e.domElement.firstElementChild);
        }
        function ce(e, t) {
            (e.domElement.style.width = t + "px"), e.__save_row && e.autoPlace && (e.__save_row.style.width = t + "px"), e.__closeButton && (e.__closeButton.style.width = t + "px");
        }
        function le(e, t) {
            var n = {};
            return (
                a.each(e.__rememberedObjects, function (i, r) {
                    var o = {},
                        s = e.__rememberedObjectIndecesToControllers[r];
                    a.each(s, function (e, n) {
                        o[n] = t ? e.initialValue : e.getValue();
                    }),
                        (n[r] = o);
                }),
                n
            );
        }
        (K.toggleHide = function () {
            (J = !J),
                a.each(Z, function (e) {
                    e.domElement.style.display = J ? "none" : "";
                });
        }),
            (K.CLASS_AUTO_PLACE = "a"),
            (K.CLASS_AUTO_PLACE_CONTAINER = "ac"),
            (K.CLASS_MAIN = "main"),
            (K.CLASS_CONTROLLER_ROW = "cr"),
            (K.CLASS_TOO_TALL = "taller-than-window"),
            (K.CLASS_CLOSED = "closed"),
            (K.CLASS_CLOSE_BUTTON = "close-button"),
            (K.CLASS_CLOSE_TOP = "close-top"),
            (K.CLASS_CLOSE_BOTTOM = "close-bottom"),
            (K.CLASS_DRAG = "drag"),
            (K.DEFAULT_WIDTH = 245),
            (K.TEXT_CLOSED = "Close Controls"),
            (K.TEXT_OPEN = "Open Controls"),
            (K._keydownHandler = function (e) {
                "text" === document.activeElement.type || (72 !== e.which && 72 !== e.keyCode) || K.toggleHide();
            }),
            T.bind(window, "keydown", K._keydownHandler, !1),
            a.extend(K.prototype, {
                add: function (e, t) {
                    return ne(this, e, t, { factoryArgs: Array.prototype.slice.call(arguments, 2) });
                },
                addColor: function (e, t) {
                    return ne(this, e, t, { color: !0 });
                },
                remove: function (e) {
                    this.__ul.removeChild(e.__li), this.__controllers.splice(this.__controllers.indexOf(e), 1);
                    var t = this;
                    a.defer(function () {
                        t.onResize();
                    });
                },
                destroy: function () {
                    if (this.parent) throw new Error("Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead.");
                    this.autoPlace && Y.removeChild(this.domElement);
                    var e = this;
                    a.each(this.__folders, function (t) {
                        e.removeFolder(t);
                    }),
                        T.unbind(window, "keydown", K._keydownHandler, !1),
                        $(this);
                },
                addFolder: function (e) {
                    if (void 0 !== this.__folders[e]) throw new Error('You already have a folder in this GUI by the name "' + e + '"');
                    var t = { name: e, parent: this };
                    (t.autoPlace = this.autoPlace), this.load && this.load.folders && this.load.folders[e] && ((t.closed = this.load.folders[e].closed), (t.load = this.load.folders[e]));
                    var n = new K(t);
                    this.__folders[e] = n;
                    var i = Q(this, n.domElement);
                    return T.addClass(i, "folder"), n;
                },
                removeFolder: function (e) {
                    this.__ul.removeChild(e.domElement.parentElement), delete this.__folders[e.name], this.load && this.load.folders && this.load.folders[e.name] && delete this.load.folders[e.name], $(e);
                    var t = this;
                    a.each(e.__folders, function (t) {
                        e.removeFolder(t);
                    }),
                        a.defer(function () {
                            t.onResize();
                        });
                },
                open: function () {
                    this.closed = !1;
                },
                close: function () {
                    this.closed = !0;
                },
                hide: function () {
                    this.domElement.style.display = "none";
                },
                show: function () {
                    this.domElement.style.display = "";
                },
                onResize: function () {
                    var e = this.getRoot();
                    if (e.scrollable) {
                        var t = T.getOffset(e.__ul).top,
                            n = 0;
                        a.each(e.__ul.childNodes, function (t) {
                            (e.autoPlace && t === e.__save_row) || (n += T.getHeight(t));
                        }),
                            window.innerHeight - t - 20 < n
                                ? (T.addClass(e.domElement, K.CLASS_TOO_TALL), (e.__ul.style.height = window.innerHeight - t - 20 + "px"))
                                : (T.removeClass(e.domElement, K.CLASS_TOO_TALL), (e.__ul.style.height = "auto"));
                    }
                    e.__resize_handle &&
                        a.defer(function () {
                            e.__resize_handle.style.height = e.__ul.offsetHeight + "px";
                        }),
                        e.__closeButton && (e.__closeButton.style.width = e.width + "px");
                },
                onResizeDebounced: a.debounce(function () {
                    this.onResize();
                }, 50),
                remember: function () {
                    if ((a.isUndefined(q) && ((q = new k()).domElement.innerHTML = G), this.parent)) throw new Error("You can only call remember on a top level GUI.");
                    var e = this;
                    a.each(Array.prototype.slice.call(arguments), function (t) {
                        0 === e.__rememberedObjects.length && ae(e), -1 === e.__rememberedObjects.indexOf(t) && e.__rememberedObjects.push(t);
                    }),
                        this.autoPlace && ce(this, this.width);
                },
                getRoot: function () {
                    for (var e = this; e.parent; ) e = e.parent;
                    return e;
                },
                getSaveObject: function () {
                    var e = this.load;
                    return (
                        (e.closed = this.closed),
                        this.__rememberedObjects.length > 0 && ((e.preset = this.preset), e.remembered || (e.remembered = {}), (e.remembered[this.preset] = le(this))),
                        (e.folders = {}),
                        a.each(this.__folders, function (t, n) {
                            e.folders[n] = t.getSaveObject();
                        }),
                        e
                    );
                },
                save: function () {
                    this.load.remembered || (this.load.remembered = {}), (this.load.remembered[this.preset] = le(this)), ee(this, !1), this.saveToLocalStorageIfPossible();
                },
                saveAs: function (e) {
                    this.load.remembered || ((this.load.remembered = {}), (this.load.remembered[j] = le(this, !0))), (this.load.remembered[e] = le(this)), (this.preset = e), re(this, e, !0), this.saveToLocalStorageIfPossible();
                },
                revert: function (e) {
                    a.each(
                        this.__controllers,
                        function (t) {
                            this.getRoot().load.remembered ? te(e || this.getRoot(), t) : t.setValue(t.initialValue), t.__onFinishChange && t.__onFinishChange.call(t, t.getValue());
                        },
                        this
                    ),
                        a.each(this.__folders, function (e) {
                            e.revert(e);
                        }),
                        e || ee(this.getRoot(), !1);
                },
                listen: function (e) {
                    var t = 0 === this.__listening.length;
                    this.__listening.push(e),
                        t &&
                            (function e(t) {
                                0 !== t.length &&
                                    V.call(window, function () {
                                        e(t);
                                    });
                                a.each(t, function (e) {
                                    e.updateDisplay();
                                });
                            })(this.__listening);
                },
                updateDisplay: function () {
                    a.each(this.__controllers, function (e) {
                        e.updateDisplay();
                    }),
                        a.each(this.__folders, function (e) {
                            e.updateDisplay();
                        });
                },
            });
        var ue = { Color: x, math: d, interpret: u },
            he = { Controller: w, BooleanController: A, OptionController: L, StringController: C, NumberController: P, NumberControllerBox: O, NumberControllerSlider: I, FunctionController: N, ColorController: U },
            de = { dom: T },
            pe = { GUI: K },
            fe = K,
            me = { color: ue, controllers: he, dom: de, gui: pe, GUI: fe };
        t.default = me;
    },
]);
